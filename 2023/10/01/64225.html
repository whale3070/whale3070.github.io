

  <!DOCTYPE html>
  <html lang="zh-CN" data-default-color-scheme=&#34;dark&#34; >
  <style>
    .text1
    {
    text-shadow: 0px 0px 2px #f2f3f2;
    }
    </style>

  <script>
    // 强制内网 IP 识别为安全上下文
    if (window.location.hostname !== 'localhost' && window.location.protocol === 'http:') {
        // 尝试手动映射 crypto 属性
        if (!window.crypto.subtle && window.crypto.webkitSubtle) {
            window.crypto.subtle = window.crypto.webkitSubtle;
        }
    }
    
    // 终极补丁：如果还是没有 subtle，则创建一个占位符避免报错
    // 提示：这通常能解决加载报错，但如果插件强依赖原生加密，建议执行下面的“降级”预判
    if (!window.isSecureContext) {
        console.warn('当前环境非安全上下文，正在尝试兼容内网加密解密...');
    }
</script>


<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/null">
  <link rel="icon" type="image/png" href="/null">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>COBOL考古（九） - whale3070&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"192.168.126.129","root":"/","version":"1.8.7","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":false,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 7.3.0"></head>


    <body>
      <header style="height: 70vh;">
        <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>InfoSec learning</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/search/">
                <i class="iconfont icon-search"></i>
                搜索
              </a>
            </li>
          
        
        
        
          
        
      </ul>
    </div>
  </div>
</nav>

          <div class="banner" id="banner" false
            style="background: url('/img/default.png') no-repeat center center;
              background-size: cover;">
              <div class="full-bg-img">
                <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
                  <div class="page-header text-center fade-in-up">
                    <span class="h2 text1" id="subtitle" title="COBOL考古（九）">
                      
                        COBOL考古（九）
                      
                    </span>
        
                    
                      <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2023-10-01 14:43" pubdate>
        2023年10月1日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6.5k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      74
       分钟
    </span>
  

  
  
</div>

                    
                  </div>
                    
                  </div>
                  
                </div>
              </div>
          </div>
      </header>

      <main>
        
          

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" data-pagefind-body>
            <!-- SEO header -->
            <h1 style="display: none">COBOL考古（九）</h1>
            
            <div class="markdown-body">
              <h1 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h1><p>在本章中，我们将讨论结构化编程的概念以及它与COBOL的关系。我们将重点介绍COBOL语言中的关键技术，使您能够编写良好结构化的程序。</p>
<ul>
<li><p><strong>编程风格</strong></p>
<ul>
<li><p><strong>什么是结构化编程</strong></p>
</li>
<li><p><strong>什么是面向对象编程</strong></p>
</li>
<li><p><strong>COBOL编程风格</strong></p>
</li>
</ul>
</li>
<li><p><strong>Procedure Division的结构</strong></p>
<ul>
<li><p><strong>程序的控制和流程</strong></p>
</li>
<li><p><strong>内联和外部执行语句</strong></p>
</li>
<li><p><strong>使用PERFORM编写循环</strong></p>
</li>
<li><p><strong>使用GO TO关键字学习不良行为</strong></p>
</li>
</ul>
</li>
<li><p><strong>段落作为代码块</strong></p>
<ul>
<li><p><strong>设计段落的内容</strong></p>
</li>
<li><p><strong>段落的顺序和命名</strong></p>
</li>
</ul>
</li>
<li><p><strong>段落控制程序</strong></p>
<ul>
<li><p><strong>PERFORM TIMES</strong></p>
</li>
<li><p><strong>PERFORM THROUGH</strong></p>
</li>
<li><p><strong>PERFORM UNTIL</strong></p>
</li>
<li><p><strong>PERFORM VARYING</strong></p>
</li>
</ul>
</li>
<li><p><strong>使用子程序</strong></p>
<ul>
<li><p><strong>指定目标程序</strong></p>
</li>
<li><p><strong>指定程序变量</strong></p>
</li>
<li><p><strong>指定返回值</strong></p>
</li>
</ul>
</li>
<li><p><strong>使用复制文件（Copybooks）</strong></p>
</li>
<li><p><strong>总结</strong></p>
</li>
<li><p><strong>实验</strong></p>
</li>
</ul>
<h2 id="编程风格"><a href="#编程风格" class="headerlink" title="编程风格"></a>编程风格</h2><p>在我们更详细地讨论如何构建COBOL程序的结构之前，了解COBOL是一种什么类型的语言以及它与其他语言有何不同，以及它如何影响您可能构建程序的方式是非常重要的。</p>
<h3 id="什么是结构化编程"><a href="#什么是结构化编程" class="headerlink" title="什么是结构化编程"></a>什么是结构化编程</h3><p>结构化编程是一组编程风格的名称，包括功能性编程、过程性编程等。结构化编程技术使程序逻辑更容易理解和维护。结构化编程语言的示例包括C、PL&#x2F;I、Python以及当然COBOL。这些语言提供了特定的控制流结构，如循环、函数和方法，允许程序员以有意义的方式组织他们的代码。</p>
<p>非结构化编程构造，也称为意大利面代码，是诸如GOTO或JUMP之类的概念，它们允许执行流在源代码中疯狂地分支。这样的代码很难分析和阅读。虽然COBOL确实包含这些结构，但重要的是要谨慎使用它们，不要将它们用作良好结构化代码的主要组成部分。</p>
<p>良好结构化的代码既易于理解又易于维护。很可能在您的职业生涯中的某个时候，您将需要阅读并从别人的代码中工作，通常是在它最初编写后的十年后。如果原始作者良好地构建了他们的代码，并且如果有人阅读您的代码，同样也是如此，这对您将非常有帮助。</p>
<h3 id="什么是面向对象编程"><a href="#什么是面向对象编程" class="headerlink" title="什么是面向对象编程"></a>什么是面向对象编程</h3><p>面向对象编程，或OO编程，不同于结构化编程，尽管它借用了许多相同的概念。在面向对象编程中，代码分割成多个类，每个类表示系统中的一个角色。每个类由变量和一系列方法组成。类的实例化或对象可以执行另一个对象的方法。OO程序中的每个类仍然可以被视为结构化程序，因为它仍然包含方法和迭代结构。但是，正是通过从一组独立类中组成程序的方式使OO编程与众不同。虽然可以编写面向对象的COBOL，但并不受一些提供COBOL API的中间件产品的支持。它通常不在市场上使用，因此在本课程中不涉及它。</p>
<h3 id="COBOL编程风格"><a href="#COBOL编程风格" class="headerlink" title="COBOL编程风格"></a>COBOL编程风格</h3><p>COBOL并没有像C或Java这样的结构化编程语言中常见的一些组件。COBOL不包含for或while循环，也不包含定义的函数或方法。因为COBOL旨在成为一种易于阅读的语言，这些概念通过使用PERFORM关键字和段落的概念来体现。这使程序员仍然可以创建这些结构，但以一种易于阅读和遵循的方式。</p>
<h2 id="Procedure-Division的结构"><a href="#Procedure-Division的结构" class="headerlink" title="Procedure Division的结构"></a>Procedure Division的结构</h2><p>正如您已经了解的那样，COBOL程序分为几个部分，包括标识、环境和数据。然而，本章关注的是如何构造程序部分的内容，以便在将来易于阅读、理解和维护。</p>
<h3 id="程序控制和基本程序的流程"><a href="#程序控制和基本程序的流程" class="headerlink" title="程序控制和基本程序的流程"></a>程序控制和基本程序的流程</h3><p>通常，COBOL程序的执行从过程部分中的第一条语句开始，并顺序执行每一行，直到达到源代码的末尾。例如，看一下示例1。这是来自TOTEN1的代码片段。这是一个简单的程序，显示一个简单的消息，计数到十。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs COBOL">OPEN OUTPUT PRINT-LINE.<br><br>MOVE &#x27;THE NUMBER IS: &#x27; TO MSG-HEADER OF PRINT-REC.  <br><br>ADD 1 TO COUNTER GIVING COUNTER.<br>MOVE COUNTER TO MSG-TO-WRITE.<br>WRITE PRINT-REC.<br><br>ADD 1 TO COUNTER GIVING COUNTER.<br>MOVE COUNTER TO MSG-TO-WRITE.<br>WRITE PRINT-REC. <br><br>...<br><br>CLOSE PRINT-LINE.<br>STOP RUN.<br></code></pre></div></td></tr></table></figure>
<p><em>Example 1.  Snippet from TOTEN1</em></p>
<p>尽管这段代码很容易阅读，但它并不太优雅，因为数字逐渐增加时存在大量的代码重复。显然，我们希望为程序提供一些结构。有三个关键字可以用来将控制转移到源代码的不同部分并提供所需的结构。这些关键字是PERFORM、GO TO和CALL。</p>
<h3 id="内联和外部PERFORM语句"><a href="#内联和外部PERFORM语句" class="headerlink" title="内联和外部PERFORM语句"></a>内联和外部PERFORM语句</h3><p>PERFORM关键字是COBOL语言中非常灵活的元素，因为它允许进入函数和循环。在最基本的级别上，PERFORM允许将控制转移到代码的另一个部分。一旦执行了这个部分，控制就会返回到下一行代码。看下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs COBOL">    OPEN OUTPUT PRINT-LINE.<br><br>    MOVE &#x27;THE NUMBER IS: &#x27; TO MSG-HEADER OF PRINT-REC. <br><br>    PERFORM WRITE-NEW-RECORD.<br>    PERFORM WRITE-NEW-RECORD.<br>    PERFORM WRITE-NEW-RECORD.<br>    PERFORM WRITE-NEW-RECORD.<br>    PERFORM WRITE-NEW-RECORD.<br>    PERFORM WRITE-NEW-RECORD.<br>    PERFORM WRITE-NEW-RECORD.<br>    PERFORM WRITE-NEW-RECORD.<br>    PERFORM WRITE-NEW-RECORD.<br>    PERFORM WRITE-NEW-RECORD.<br><br><br>    CLOSE PRINT-LINE.<br>    STOP RUN.<br><br><br>WRITE-NEW-RECORD.<br>    ADD 1 TO COUNTER GIVING COUNTER<br>    MOVE COUNTER TO MSG-TO-WRITE<br>    WRITE PRINT-REC.<br></code></pre></div></td></tr></table></figure>
<p>在这个示例中，构建新的输出行并打印它的三行代码已提取到一个名为WRITE-NEW-RECORD的新段落中。然后，通过使用PERFORM关键字，对该段落执行了十次。每次使用PERFORM关键字时，执行都会跳转到WRITE-NEW-RECORD段落，执行其中包含的三行代码，然后返回到PERFORM语句后面的行。段落的概念将在本章后面更详细地介绍。</p>
<h3 id="使用PERFORM来编写循环"><a href="#使用PERFORM来编写循环" class="headerlink" title="使用PERFORM来编写循环"></a>使用PERFORM来编写循环</h3><p>到目前为止，我们构建的代码仍然不是最佳的，PERFORM语句十次的重复不够优雅，可以进行优化。观察以下代码片段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs COBOL">MOVE &#x27;THE NUMBER IS: &#x27; TO MSG-HEADER OF PRINT-REC.<br><br>PERFORM VARYING COUNTER FROM 01 BY 1 UNTIL COUNTER EQUAL 11<br>    MOVE COUNTER TO MSG-TO-WRITE<br>    WRITE PRINT-REC<br>END-PERFORM.<br><br>CLOSE PRINT-LINE.<br>STOP RUN.<br></code></pre></div></td></tr></table></figure>

<p><em>示例3. 来自TOTEN2的代码片段</em></p>
<p>在这个示例中，我们使用PERFORM关键字的方式类似于其他语言中的for循环。循环从PERFORM关键字到END-PERFORM关键字运行。每次执行迭代循环时，COUNTER的值都会递增，并逐个测试。为了进行比较，在其他语言中，同样的循环将被写成如下：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JAVA"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; counter &lt; <span class="hljs-number">11</span>; counter++) &#123;<br>    System.out.println(<span class="hljs-string">&quot;The number is: &quot;</span> + counter);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><em>示例4. Java示例</em></p>
<p>尽管COBOL版本可能比其他语言中的for循环更冗长，但更容易阅读，而且请记住，如果您使用的是一个好的编辑器，您总是可以使用自动完成来帮助您输入。</p>
<h3 id="使用GO-TO关键字学习不良习惯"><a href="#使用GO-TO关键字学习不良习惯" class="headerlink" title="使用GO TO关键字学习不良习惯"></a>使用GO TO关键字学习不良习惯</h3><p>程序员往往对编辑器的选择、制表符或空格等问题有强烈的信仰，已经就这类问题进行了许多激烈的讨论。然而，如果有一件事我们可以达成一致，那就是使用GO TO通常是一个坏主意。为了演示为什么GO TO可能是一个糟糕的主意，我们将再次查看TOTEN2，并将第二个PERFORM关键字的实例替换为GO TO，如示例5所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs COBOL">PERFORM WRITE-NEW-RECORD.<br>GO TO WRITE-NEW-RECORD.<br>PERFORM WRITE-NEW-RECORD.<br></code></pre></div></td></tr></table></figure>

<p><em>示例5. 使用GO TO的示例</em></p>
<p>如果我们编译并运行程序，您会看到尽管作业以4038-abend代码异常结束，但它确实执行了一些代码并写入了输出的前两行。如果您仔细查看输出，会看到类似以下的消息：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livecodeserver">IGZ0037S The flow <span class="hljs-keyword">of</span> control <span class="hljs-keyword">in</span> program TOTEN1 proceeded beyond <span class="hljs-keyword">the</span> <span class="hljs-keyword">last</span> <span class="hljs-built_in">line</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> program.<br></code></pre></div></td></tr></table></figure>

<p><em>示例6. 来自GO TO示例的异常</em></p>
<p>那么，当我们使用GO TO命令时，到底发生了什么糟糕的事情呢？要回答这个问题，我们需要理解GO TO和PERFORM之间的关键区别。在第一行中，我们使用了PERFORM关键字，将控制转移到WRITE-NEW-RECORD段落。一旦执行到达该段落的末尾，执行就会返回到PERFORM语句后面的行。下一行使用了GOTO关键字，再次将控制权转移到WRITE-NEW-RECORD段落，该段落打印了第二行输出。然而，当该段落完成后，执行继续执行WRITE-NEW-RECORD段落后面的下一行代码。由于WRITE-NEW-RECORD段落后面没有代码行，处理器试图执行程序之外的代码，z&#x2F;OS将其视为问题并异常结束了程序。</p>
<p>正如我们所看到的，使用GO TO会导致执行分支，不会返回到发出它的代码行。让我们演示一下，这段代码有多混乱：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs COBOL">0 01  FLAG           PIC 9(1) VALUE 1.   <br><br>1  OPEN OUTPUT PRINT-LINE.<br>2    GO TO SAY-HELLO-WORLD DEPENDING ON FLAG.<br>3<br>4 PRINT-NEW-MESSAGE.<br>5    MOVE 2 TO FLAG<br>6    GO TO SAY-HELLO-COBOL DEPENDING ON FLAG<br>7    GO TO END-RUN.<br>8<br>9 SAY-HELLO-WORLD.<br>10    MOVE &quot;Hello World&quot; TO MSG-TO-WRITE<br>11    WRITE PRINT-REC<br>12    GO TO PRINT-NEW-MESSAGE.<br>13<br>14 SAY-HELLO-COBOL.<br>15    MOVE &quot;Hello COBOL&quot; TO MSG-TO-WRITE<br>16    WRITE PRINT-REC<br>17    GO TO END-RUN.<br>18<br>19 END-RUN.<br>20    CLOSE PRINT-LINE<br>21    STOP RUN.<br></code></pre></div></td></tr></table></figure>

<p><em>示例7. 使用GO TO的混乱代码</em></p>
<p>这个示例使用了混合条件和非条件的GO TO语句，并包含了行号以便更容易跟踪代码。第2行执行，如果标志变量设置为1，将分支到第9行的SAY-HELLO-WORLD。在这种情况下，它是，所以我们通过第9-12行继续，然后分支到第4-6行，其中更新了标志的值并再次测试以查看是否应该跳转到SAY-HELLO-COBOL。由于标志的值不再为1，执行会继续到第7行，然后跳转到第19行并完成运行。将此程序的第5行注释掉，然后再次运行程序。跟踪程序的执行。乱糟糟的对吧？</p>
<p>**注意：**条件GO TO语句的TO和ON部分都可以省略，得到的语句看起来像GO SAY-HELLO-WORLD DEPENDING FLAG。虽然不够冗长，但同样易于理解。</p>
<p>那么，为什么要教你一些我们说过混乱且不建议使用的东西呢？嗯，通过让您了解其行为，您将更好地了解查看现有代码并维护代码时的工具。</p>
<h2 id="段落作为代码块"><a href="#段落作为代码块" class="headerlink" title="段落作为代码块"></a>段落作为代码块</h2><p>到目前为止，在本节中，我们已经使用了一些段落的示例，但并没有真正解释它们是什么，它们是如何工作的，以及它们可以用来做什么。本节将解决这个问题。</p>
<p>在COBOL中，最类似的思考段落的方式是将其视为另一种语言中不接受参数、不返回响应并更改全局变量的函数或方法。它基本上是一个代码块，执行一系列操作，可以在同一个程序中多次使用。</p>
<p>段落在过程部分内定义，从第八列开始，并且可以具有用户喜欢的任何名称，除了COBOL关键字之外，段落的声明由句点（.）完成。段落可以包含一个到多个COBOL句子，并且可以由另一个段落的开始或程序的物理结束来终止。</p>
<p>**注意：**段落也可以由END-PROGRAM、END-METHOD、END FACTORY或END-OBJECT结束。其中大多数用于面向对象的COBOL，这里不讨论。</p>
<p>考虑到一个程序可以由多个段落组成，并且可以使用PERFORM关键字来调用段落，无论是有条件地还是作为循环的一部分，很容易看出，良好的段落设计确实有助于使您的COBOL更具结构性和可读性。</p>
<h3 id="设计段落内容"><a href="#设计段落内容" class="headerlink" title="设计段落内容"></a>设计段落内容</h3><p>段落内的内容没有限制，但是可能希望将代码重构到段落中的原因有两个主要原因：</p>
<ol>
<li><p>将一系列COBOL句子组合在一起，以实现特定的功能或任务，例如，打开应用程序正在使用的所有文件、计算特定功能或执行一些数据验证。将这些句子分组到一个段落中允许您为它们提供一个解释代码行用途的名称。</p>
</li>
<li><p>这些句子序列将在循环中使用。将这些行提取到段落中，然后使用PERFORM关键字创建循环可以使代码非常易于理解。</p>
</li>
</ol>
<p>记住，您还可以在现有段落中执行其他段落。这种嵌套调用段落的方式可以帮助结构化代码。</p>
<h3 id="段落的顺序和命名"><a href="#段落的顺序和命名" class="headerlink" title="段落的顺序和命名"></a>段落的顺序和命名</h3><p>段落在COBOL程序中出现的顺序没有要求。可以在声明段落之前或之后从某一点调用段落。尽管语言没有强制执行的限制，但有一些技术可以遵循，使更大的程序更易于理解和遵循。一些这些技术和最佳实践包括：</p>
<ul>
<li><p>使用与其功能或行为相对应的名称命名每个段落。一个命名为OPEN-INPUT-FILES的段落比一个命名为DO-FILE-STUFF的段落更容易理解。</p>
</li>
<li><p>按照运行时将执行的一般顺序对段落进行排序。这样做有两个主要优点。在现代IDE中使用大纲视图将允许您从上到下“阅读”每个段落的名称，通过这样做，您将能够确定程序的一般结构和行为。</p>
</li>
<li><p>一些COBOL程序员在段落名称前面加上一个数字，该数字会随着源代码的增加而递增，如示例8所示。</p>
</li>
<li><p>由于段落是按照数字编号并按照这个顺序出现在源代码中的，所以当一个句子引用一个段落时，更容易知道程序中该段落可能出现在何处。在最初以这种方式构建程序时，使用的数字仅会递增最高有效数字，以允许根据需要在其中插入新段落。尽管现代编辑器的兴起允许制作大纲并立即跳转到引用或声明，但了解这种技术仍然很有用。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs COBOL">     PERFORM 1000-OPEN-FILES.<br>     PERFORM 2000-READ-NEXT-RECORD.<br>     GO TO 3000-CLOSE-STOP.<br> 1000-OPEN-FILES.   <br>     OPEN INPUT  ACCT-REC.<br>     OPEN OUTPUT PRINT-LINE.    <br>* <br> 2000-READ-NEXT-RECORD.   <br>     PERFORM 4000-READ-RECORD   <br>     PERFORM UNTIL LASTREC = &#x27;Y&#x27;<br>         PERFORM 5000-WRITE-RECORD  <br>         PERFORM 4000-READ-RECORD   <br>     END-PERFORM. <br>*<br> 3000-CLOSE-STOP. <br>     CLOSE ACCT-REC.<br>     CLOSE PRINT-LINE.    <br>     STOP RUN.<br>* <br> 4000-READ-RECORD.  <br>     READ ACCT-REC  <br>         AT END MOVE &#x27;Y&#x27; TO LASTREC<br>     END-READ.<br>* <br> 5000-WRITE-RECORD. <br>     MOVE ACCT-N  -    TO  ACCT-NO-O. <br>     MOVE ACCT-LIMIT   TO  ACCT-LIMIT-O.    <br>     MOVE ACCT-BALANCE TO  ACCT-BALANCE-O.  <br>     MOVE LAST-NAME    TO  LAST-NAME-O.<br>     MOVE FIRST-NAME   TO  FIRST-NAME-O.    <br>     MOVE COMMENTS     TO  COMMENTS-O. <br>     WRITE PRINT-REC.<br></code></pre></div></td></tr></table></figure>
<p><em>示例8. 编号段落</em></p>
<ul>
<li>最后，通常通过在每个段落后编写一个空段落来显式结束段落，参见示例9。这个空段落不包含任何代码，与它所关闭的段落具有相同的名称，后缀为-END，并在接下来的段落开始时被关闭。但它可以用作视觉分隔符，在使用PERFORM THRU关键字时很有用，这将在本章进一步讨论。一些学过COBOL的Java程序员评论说，这相当于代码块末尾的闭合大括号(“}”)。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs COBOL"> 1000-OPEN-FILES.   <br>     OPEN INPUT  ACCT-REC.<br>     OPEN OUTPUT PRINT-LINE.    <br> 1000-OPEN-FILES-END.<br>* <br> 2000-READ-NEXT-RECORD.   <br>     PERFORM 4000-READ-RECORD   <br>     PERFORM UNTIL LASTREC = &#x27;Y&#x27;<br>         PERFORM 5000-WRITE-RECORD<br>         PERFORM 4000-READ-RECORD<br>     END-PERFORM.<br> 2000-READ-NEXT-RECORD-END.   <br></code></pre></div></td></tr></table></figure>
<p><em>示例9. 显式关闭的段落</em></p>
<h2 id="使用段落进行程序控制"><a href="#使用段落进行程序控制" class="headerlink" title="使用段落进行程序控制"></a>使用段落进行程序控制</h2><p>在本章中，我们已经讨论了使用段落来构建代码结构的重要性。在这个过程中，我们已经多次使用了PERFORM关键字来执行我们创建的段落。具体来说，我们单独使用了这个关键字，并且还使用了它与VARYING关键字一起构建循环。在本节中，我们将更详细地讨论如何使用PERFORM关键字。</p>
<h3 id="PERFORM-TIMES"><a href="#PERFORM-TIMES" class="headerlink" title="PERFORM TIMES"></a>PERFORM TIMES</h3><p>重复执行一个PERFORM语句的最简单方法也许是使用TIMES关键字，以静态次数执行一个段落或一段代码，示例见示例10。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs COBOL">PERFORM 10 TIMES<br>    MOVE FIELD-A TO FIELD-B<br>    WRITE RECORD<br>END-PERFORM.<br></code></pre></div></td></tr></table></figure>
<p><strong>示例10. TIMES</strong></p>
<p>代码应该执行的次数可以是一个文字值，就像上面的示例一样，也可以是一个数值变量的值，如示例11所示，其中PERFORM关键字用于执行一个段落。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs COBOL">PERFORM MY-NEW-PARAGRAPH COUNTER TIMES.<br></code></pre></div></td></tr></table></figure>

<p><strong>示例11. TIMES 2</strong></p>
<h3 id="PERFORM-THROUGH"><a href="#PERFORM-THROUGH" class="headerlink" title="PERFORM THROUGH"></a>PERFORM THROUGH</h3><p>有时候，您可能需要按顺序执行一系列段落，而不是单独执行它们。可以使用THROUGH或THRU关键字来列出列表的起始段落和结束段落。执行将按照它们在源代码中出现的顺序依次进行，从开头到结尾，然后返回到初始perform语句后面的行，示例12为例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs COBOL">PERFORM MY-NEW-PARAGRAPH1 THROUGH MY-NEW-PARAGRAPH5.<br></code></pre></div></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs COBOL"> 1000-PARAGRAPH-A.   <br>     PERFORM 2000-PARAGRAPH-B THRU<br>             3000-PARAGRAPH-C.<br>* <br> 2000-PARAGRAPH-B.<br>     ...<br>*<br> 3000-PARAGRAPH-C.<br>     ...<br>*<br> 4000-PARAGRAPH-D.<br>     ...<br></code></pre></div></td></tr></table></figure>

<p><em>示例12. 使用PERFORM THRU</em></p>
<p><strong>注意：</strong> THRU关键字的使用也可以与TIMES、UNTIL和VARYING关键字一起使用，以允许执行段落的列表，而不仅仅是单个段落或代码块。</p>
<h3 id="PERFORM-UNTIL"><a href="#PERFORM-UNTIL" class="headerlink" title="PERFORM UNTIL"></a>PERFORM UNTIL</h3><p>在PERFORM语句中添加UNTIL关键字允许您在满足布尔条件之前迭代一组语句。实际上，这使您能够在COBOL中编写while循环，看看这个基本示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs COBOL">MOVE 0 TO COUNTER.<br>PERFORM UNTIL COUNTER = 10<br>    ADD 1 TO COUNTER GIVING COUNTER<br>    MOVE COUNTER TO MSG-TO-WRITE<br>    WRITE PRINT-REC<br>END-PERFORM.<br></code></pre></div></td></tr></table></figure>

<p><em>示例13. 使用PERFORM UNTIL</em></p>
<p>这与以下Java代码等效：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JAVA"><span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (counter != <span class="hljs-number">10</span>) &#123;<br>    counter++;<br>    System.out.println(<span class="hljs-string">&quot;The number is: &quot;</span> + counter);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><em>示例14. Java while循环</em></p>
<p>在这种情况下，布尔条件在执行循环之前进行评估。但是，如果您希望在评估条件之前至少执行一次循环，可以修改语句如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs COBOL">PERFORM WITH TEST AFTER UNTIL COUNTER = 10<br>    ADD 1 TO COUNTER GIVING COUNTER<br>    MOVE COUNTER TO MSG-TO-WRITE<br>    WRITE PRINT-REC<br>END-PERFORM.<br></code></pre></div></td></tr></table></figure>

<p><em>示例15. 使用PERFORM WITH TEST AFTER UNTIL</em></p>
<p>这类似于Java中的 “do while” 循环：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JAVA"><span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">do</span> &#123;<br>    counter++;<br>    System.out.println(<span class="hljs-string">&quot;The number is: &quot;</span> + counter);<br>&#125; <span class="hljs-keyword">while</span> (counter != <span class="hljs-number">10</span>);<br></code></pre></div></td></tr></table></figure>

<p><em>示例16. Java while循环</em></p>
<h3 id="PERFORM-VARYING"><a href="#PERFORM-VARYING" class="headerlink" title="PERFORM VARYING"></a>PERFORM VARYING</h3><p>我们已经在标题为”使用PERFORM编写循环”的部分中使用了VARYING关键字，回忆一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs COBOL">PERFORM VARYING COUNTER FROM 01 BY 1 UNTIL COUNTER EQUAL 11<br>...<br>END-PERFORM.<br></code></pre></div></td></tr></table></figure>

<p><em>示例17. 基本循环</em></p>
<p>在这个示例中，变量counter被测试，以查看它是否等于11，只要它不等于11，它就会被递增，然后执行在perform语句中嵌套的语句。这个结构可以扩展，如示例18所示。然而，在这个示例中，我们只能执行段落，而不能执行嵌套的语句。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs COBOL">PERFORM 1000-PARAGRAPH-A<br>    VARYING COUNTER FROM 01 BY 1 UNTIL COUNTER EQUAL 11<br>    AFTER COUNTER-2 FROM 01 BY 1 UNTIL COUNTER-2 EQUAL 5.<br></code></pre></div></td></tr></table></figure>

<p><em>示例18. 扩展循环</em></p>
<p>这可能看起来复杂，但与这个Java伪代码相比较：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JAVA"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; counter &lt; <span class="hljs-number">11</span>; counter++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">counter2</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; counter2 &lt; <span class="hljs-number">5</span>; counter2++) &#123;<br>        paragraphA();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><em>示例19. Java扩展循环</em></p>
<p>这实际上只是两个嵌套在一起的for循环。当在外部变化循环的每个循环中，内部循环将执行五次。正如之前提到的，条件的测试将被COBOL假定为在循环的开头进行，但可以通过在初始perform语句中添加短语WITH TEST AFTER来指定在循环的末尾进行评估。</p>
<h2 id="使用子程序"><a href="#使用子程序" class="headerlink" title="使用子程序"></a>使用子程序</h2><p>到目前为止，我们只研究了单个COBOL程序的内部结构。随着程序在功能和数量上的增加，程序员通常希望将程序的某些功能提供给系统中的其他程序。将通用功能抽象为它们自己的程序，并允许它们从其他程序中调用，可以减少系统中的代码重复量，从而降低维护成本，因为只需要对共享模块进行一次修复。</p>
<p>**注意：**尽管在这里我们将描述调用另一个程序的COBOL本地方式，但请注意，某些中间件产品可能提供了增强的API来执行此操作。</p>
<p>在调用另一个程序时，我们需要考虑三个主要问题：我们将如何引用要调用的程序，我们想要发送到目标程序的参数，以及我们希望目标程序返回的参数。</p>
<h3 id="指定目标程序"><a href="#指定目标程序" class="headerlink" title="指定目标程序"></a>指定目标程序</h3><p>为了调用目标程序，我们将使用CALL关键字，后跟对我们希望调用的目标程序的引用。做这个的两种主要方式是通过文字值或通过引用变量，如示例20所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs COBOL">CALL &#x27;PROGA1&#x27; ...<br>...<br>MOVE &#x27;PROGA2&#x27; TO PROGRAM-NAME.<br>CALL PROGRAM-NAME ...<br></code></pre></div></td></tr></table></figure>

<p><em>示例20. 基本CALL</em></p>
<p>还可以通过传递指向目标程序的指针引用来引用目标平台。如果您认为将指针引用传递给函数只是一些超现代的语言才有的功能，那么错了，COBOL早就实现了这个功能！</p>
<h3 id="指定程序变量"><a href="#指定程序变量" class="headerlink" title="指定程序变量"></a>指定程序变量</h3><p>现在我们已经确定了要调用的程序的名称；我们必须确定调用程序可能想要发送的变量。这些变量由USING关键字逐个指定。COBOL支持传递引用和传递副本，以及传递值的概念。支持的每种传递技术都可以应用于传递或选择性地应用于不同的项目。</p>
<p>默认情况下，COBOL将通过引用传递数据项。这意味着调用程序和目标程序都可以读取和写入由变量表示的内存区域。这意味着如果目标程序更新了变量的内容，那么一旦执行返回，这些更改将对调用程序可见。</p>
<p>使用BY CONTENT短语允许将传递的变量的副本传递给目标程序。虽然目标程序可以更新变量，但这些更新对调用程序不可见。</p>
<p>**注意：**在传递变量时，无论是通过引用还是通过内容，请注意可以发送任何级别的数据项。这意味着您可以传递整个数据结构，对于处理常见记录非常方便。</p>
<p>您还可能看到在CALL语句中使用了BY VALUE短语。BY VALUE与BY CONTENT类似，它传递了变量的内容副本。不同之处在于，只支持COBOL数据类型的子集，并且只能指定基本数据项。这是因为BY VALUE主要用于当COBOL调用另一种语言（例如C）的程序时。</p>
<h3 id="指定返回值"><a href="#指定返回值" class="headerlink" title="指定返回值"></a>指定返回值</h3><p>最后，RETURNING短语用于指定应该用于存储返回值的变量。这可以是数据部分中声明的任何基本数据项。请注意，这是可选的。某些程序可能不返回任何内容，或者您可能已经通过引用将值传递给目标程序，在这种情况下，目标程序返回后将会看到这些变量的更新。</p>
<h2 id="使用复制本"><a href="#使用复制本" class="headerlink" title="使用复制本"></a>使用复制本</h2><p>如果您的程序包含频繁使用的代码序列，我们可以将代码序列编写一次并将它们放入COBOL复制库中。这些代码序列称为复制本。然后，我们可以使用COPY语句在编译时检索这些代码序列并将它们包含在其中。以这种方式使用复制本将消除重复的编码。</p>
<p>我们需要在我们使用的JCL中指定一个复制库。如果您使用提供的过程（IGYWC、IGYWCL或IGYWCLG），可以在过程内的COBOL步骤的SYSLIB参数中提供一个DD语句。例如：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs x86asm">//COBOL<span class="hljs-number">.</span>SYSLIB  <span class="hljs-built_in">DD</span>  DISP=<span class="hljs-keyword">SHR</span>,DSN=Z99998<span class="hljs-number">.</span>COPYLIB<br></code></pre></div></td></tr></table></figure>

<p><em>示例21. JCL SYSLIB语句</em></p>
<p>这将告诉编译器在提供的数据集上查找复制本。</p>
<p>让我们看一个如何在程序中使用COPY语句的示例。</p>
<p>假设一个名为DOWORK的复制本存储了以下语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs COBOL">COMPUTE SPACE-AVAILABLE = TOTAL-FREE-SPACE<br>MOVE SPACE-AVAILABLE TO PRINT-SPACE<br></code></pre></div></td></tr></table></figure>

<p><em>示例22. DOWORK复制本的内容</em></p>
<p>我们可以使用COPY语句来检索复制本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs COBOL">PROCEDURE DIVISION.<br>...<br>    DISPLAY &quot;RETRIEVE COPYBOOK&quot;.<br>    COPY DOWORK.<br></code></pre></div></td></tr></table></figure>

<p><em>示例23. 基本COPY</em></p>
<p>DOWORK过程中的语句将在DISPLAY语句之后执行。</p>
<p>与子程序不同，使用复制本不会将控制权转移到另一个程序。但是复制本中编写的代码只会在编译期间传输一次。因此，对复制本的进一步更改将需要重新编译程序。</p>
<p>另一方面，子程序中的代码只会在程序执行期间被调用。因此，假设子程序是动态链接的，我们可以在不需要重新编译调用程序的情况下进行更改。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总之，本章应该提供了理解结构化编程以及它与COBOL的关系以及理解和维护代码的重要性所需的基础。已经提供了许多关于如何、何时以及为什么实施关键技术的示例，并进行了解释以进一步理解。您应该能够识别结构化编程（COBOL）与面向对象编程（Java）之间的基本差异。您还应该了解关于Procedure Division结构的最佳实践的一般概念，包括段落的设计和内容、程序控制选项以及在同一系统中调用其他程序的方式。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/program/">program</a>
                    
                  </div>
                
              </div>
              
                
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/10/01/32598.html">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">COBOL考古（十）</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/10/01/42687.html">
                        <span class="hidden-mobile">COBOL考古（八）</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


            

                
                  <a id="scroll-top-button" href="#" role="button">
                    <i class="iconfont icon-arrowup" aria-hidden="true"></i>
                  </a>
                  

                    

                          
      </main>

      <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://whale3070.github.io/" target="_blank" rel="nofollow noopener"><span>Whale3070</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->




  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<link href="/pagefind/pagefind-ui.css" rel="stylesheet">
  <script src="/pagefind/pagefind-ui.js"></script>
  <style>
    /* 搜索框配色适配 */
    #search { margin-top: 2rem; }
    [data-user-color-scheme='dark'] .pagefind-ui {
      --pagefind-ui-primary: #eeeeee;
      --pagefind-ui-text: #eeeeee;
      --pagefind-ui-background: #151515;
      --pagefind-ui-border: #333;
    }
  </style>
    </body>

  </html>