

  <!DOCTYPE html>
  <html lang="zh-CN" data-default-color-scheme=&#34;dark&#34; >
  <style>
    .text1
    {
    text-shadow: 0px 0px 2px #f2f3f2;
    }
    </style>

  <script>
    // 强制内网 IP 识别为安全上下文
    if (window.location.hostname !== 'localhost' && window.location.protocol === 'http:') {
        // 尝试手动映射 crypto 属性
        if (!window.crypto.subtle && window.crypto.webkitSubtle) {
            window.crypto.subtle = window.crypto.webkitSubtle;
        }
    }
    
    // 终极补丁：如果还是没有 subtle，则创建一个占位符避免报错
    // 提示：这通常能解决加载报错，但如果插件强依赖原生加密，建议执行下面的“降级”预判
    if (!window.isSecureContext) {
        console.warn('当前环境非安全上下文，正在尝试兼容内网加密解密...');
    }
</script>


<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/null">
  <link rel="icon" type="image/png" href="/null">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>COBOL考古（八） - whale3070&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.4.0/styles/github-gist.min.css" />
    
  

  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"192.168.126.129","root":"/","version":"1.8.7","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":false,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 7.3.0"></head>


    <body>
      <header style="height: 70vh;">
        <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>InfoSec learning</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/search/">
                <i class="iconfont icon-search"></i>
                搜索
              </a>
            </li>
          
        
        
        
          
        
      </ul>
    </div>
  </div>
</nav>

          <div class="banner" id="banner" false
            style="background: url('/img/default.png') no-repeat center center;
              background-size: cover;">
              <div class="full-bg-img">
                <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
                  <div class="page-header text-center fade-in-up">
                    <span class="h2 text1" id="subtitle" title="COBOL考古（八）">
                      
                        COBOL考古（八）
                      
                    </span>
        
                    
                      <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2023-10-01 14:18" pubdate>
        2023年10月1日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      4.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      50
       分钟
    </span>
  

  
  
</div>

                    
                  </div>
                    
                  </div>
                  
                </div>
              </div>
          </div>
      </header>

      <main>
        
          

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" data-pagefind-body>
            <!-- SEO header -->
            <h1 style="display: none">COBOL考古（八）</h1>
            
            <div class="markdown-body">
              <h1 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h1><p>前一章和实验侧重于变量和将文字值移动到变量中，然后使用COBOL DISPLAY语句编写变量内容。本节介绍将记录从文件中读取到变量中，将变量移动到输出变量中，然后将输出变量写入不同的文件。一个简单的COBOL程序用于读取文件中的每个记录，并将每个记录写入不同的文件，以说明从输入外部数据源读取记录并将记录写入输出外部数据源所需的COBOL代码。</p>
<p>有经验的COBOL程序员可以回答这个问题：“一个企业COBOL程序如何从输入外部数据源读取数据并将数据写入输出外部数据源？”本章的目标是提供足够全面的信息，以便读者能够回答这个问题。</p>
<ul>
<li><p><strong>用于顺序文件处理的COBOL代码</strong></p>
<ul>
<li><p><strong>COBOL输入和输出</strong></p>
</li>
<li><p><strong>FILE-CONTROL段</strong></p>
</li>
<li><p><strong>COBOL外部数据源</strong></p>
</li>
<li><p><strong>数据集、记录和字段</strong></p>
</li>
<li><p><strong>块</strong></p>
</li>
<li><p><strong>ASSIGN子句</strong></p>
</li>
</ul>
</li>
<li><p><strong>PROCEDURE DIVISION 顺序文件处理</strong></p>
<ul>
<li><p><strong>打开输入和输出进行读取和写入</strong></p>
</li>
<li><p><strong>关闭输入和输出</strong></p>
</li>
</ul>
</li>
<li><p><strong>用于顺序读写记录的COBOL编程技巧</strong></p>
<ul>
<li><p><strong>READ-NEXT-RECORD 段的执行</strong></p>
</li>
<li><p><strong>READ-RECORD 段</strong></p>
</li>
<li><p><strong>WRITE-RECORD 段</strong></p>
</li>
<li><p><strong>对 READ-NEXT-RECORD 段的迭代处理</strong></p>
</li>
</ul>
</li>
<li><p><strong>实验</strong></p>
</li>
</ul>
<h2 id="用于顺序文件处理的COBOL代码"><a href="#用于顺序文件处理的COBOL代码" class="headerlink" title="用于顺序文件处理的COBOL代码"></a>用于顺序文件处理的COBOL代码</h2><p>用于顺序文件处理的COBOL代码包括：</p>
<ul>
<li><p>环境部分（ENVIRONMENT DIVISION）。</p>
<ul>
<li><p>SELECT子句（SELECT clauses）</p>
</li>
<li><p>ASSIGN子句（ASSIGN clauses）</p>
</li>
</ul>
</li>
<li><p>数据部分（DATA DIVISION）。</p>
<ul>
<li>FD语句（FD statements）</li>
</ul>
</li>
<li><p>过程部分（PROCEDURE DIVISION）。</p>
<ul>
<li><p>OPEN语句（OPEN statements）</p>
</li>
<li><p>CLOSE语句（CLOSE statements）</p>
</li>
<li><p>READ INTO语句（READ INTO statement）</p>
</li>
<li><p>WRITE FROM语句（WRITE FROM statement）</p>
</li>
</ul>
</li>
</ul>
<h3 id="COBOL输入和输出"><a href="#COBOL输入和输出" class="headerlink" title="COBOL输入和输出"></a>COBOL输入和输出</h3><p>环境部分（ENVIRONMENT DIVISION）和数据部分（DATA DIVISION）描述了在PROCEDURE DIVISION程序逻辑中使用的输入和输出。之前的章节介绍了在数据部分中的变量描述，并将文字值移动到定义的变量中。环境部分，尤其是INPUT-OUTPUT SECTION和FILE-CONTROL段，介绍了访问外部数据源的方式，其中来自外部数据源的数据被移动到定义的变量中。</p>
<h3 id="FILE-CONTROL段"><a href="#FILE-CONTROL段" class="headerlink" title="FILE-CONTROL段"></a>FILE-CONTROL段</h3><p>FILE-CONTROL段将每个COBOL内部文件名与外部数据集名称关联起来。在FILE-CONTROL段内，SELECT子句创建了一个内部文件名，而ASSIGN子句创建了一个外部数据集名称。图1显示了PRINT-LINE内部文件名与PRTLINE外部数据集名称关联，以及ACCT-REC内部文件名与ACCTREC外部数据集名称关联。标题为Assign Clause的部分进一步解释了SELECT ASSIGN TO的关系。</p>
<p><img src="/image125.png" alt="FILE-CONTROL"></p>
<p><em>图1. FILE-CONTROL</em></p>
<p>虽然SELECT为内部文件提供了一个名称，ASSIGN为外部数据集名称提供了一个描述，但COBOL程序需要有关两者的更多信息。在DATA DIVISION的FILE SECTION中，提供了有关两者的更多信息。</p>
<p>COBOL保留字’FD’用于在FILE-SECTION中为COBOL内部文件名提供更多信息。FD语句下的代码是记录布局。记录布局包括级别号、变量名称、数据类型和长度，如图2所示。</p>
<p><img src="/image126.png" alt="FILE-SECTION"></p>
<p><em>图2. FILE-SECTION</em></p>
<h3 id="COBOL外部数据源"><a href="#COBOL外部数据源" class="headerlink" title="COBOL外部数据源"></a>COBOL外部数据源</h3><p>Enterprise COBOL源代码编译并在IBM Z主机硬件上执行，其中z&#x2F;OS是操作系统软件。z&#x2F;OS将数据存储在数据集和Unix文件中。z&#x2F;OS包括许多数据存储方法。本章将重点介绍z&#x2F;OS顺序数据存储方法。顺序数据集是记录的集合。</p>
<h3 id="数据集、记录和字段"><a href="#数据集、记录和字段" class="headerlink" title="数据集、记录和字段"></a>数据集、记录和字段</h3><p>数据集包含多个记录。记录是数据集中的单行，具有定义的长度。每个记录可以细分为字段，其中每个字段具有定义的长度。因此，所有字段长度的总和将等于记录的长度。请参阅图3。</p>
<h3 id="块"><a href="#块" class="headerlink" title="块"></a>块</h3><p>程序读取的每个记录可能导致磁盘存储访问。程序通常按顺序一次读取1个记录，直到读取所有记录为止。当读取记录时，从磁盘检索的记录存储在内存中供程序访问。每次读取下一个记录时，都需要从磁盘检索记录，这会对系统性能产生负面影响。记录可以被分组为块，块是一组记录。结果是当读取第一个记录时，假设程序将读取第二个、第三个等记录，整个块记录将被读入内存，避免不必要的磁盘检索和负面的系统性能。保存记录或记录块的内存，以供程序读取，被称为缓冲区。COBOL BLOCK CONTAINS子句可用于指定缓冲区中块的大小。请参阅图3。</p>
<p><img src="/image127.png" alt="Records, fields, and blocks"></p>
<p><em>图3. 记录、字段和块</em></p>
<h3 id="ASSIGN子句"><a href="#ASSIGN子句" class="headerlink" title="ASSIGN子句"></a>ASSIGN子句</h3><p>虽然SELECT子句名称是内部文件名，但ASSIGN子句名称描述了程序外部的数据源。z&#x2F;OS使用作业控制语言（JCL）操作来告诉系统要加载和执行的程序，然后是程序所需的输入和输出名称。JCL输入和输出名称称为DDNAMEs。JCL DDNAME语句包括一个JCL DD操作，其中DD是Data Definition的缩写。在同一个DDNAME语句中是系统控制的数据集名称。</p>
<p>COBOL代码“SELECT ACCT-REC ASSIGN TO ACCTREC”需要一个JCL DDNAME ACCTREC，其中DD将ACCTREC重定向到z&#x2F;OS控制的数据集名称MY.DATA。示例1中显示了COBOL程序。</p>
<p>将ACCT-REC通过ASSIGN TO重定向到JCL DDNAME ACCTREC的目的是为了灵活性。ACCT-REC在程序中使用，ACCTREC是与JCL的桥梁，如示例1所示，DD JCL语句将ACCTREC连接到实际数据集，如示例2所示。这种灵活性允许同一个COBOL程序通过简单的JCL修改访问不同的数据源，而无需更改源代码以引用备用数据源。</p>
<figure class="highlight tp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tp"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ACC</span>T-REC ASSIGN <span class="hljs-keyword">TO</span> **<span class="hljs-keyword">ACC</span>TREC**<br></code></pre></div></td></tr></table></figure>
<p><em>示例1. COBOL程序</em></p>
<p>在执行期间，编译后的COBOL程序需要的JCL语句，用于将ACCTREC重定向到z&#x2F;OS控制的数据集名称MY.DATA，如示例2所示。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs x86asm">//**ACCTREC**   <span class="hljs-built_in">DD</span>  DSN=MY<span class="hljs-number">.</span>DATA,DISP=<span class="hljs-keyword">SHR</span><br></code></pre></div></td></tr></table></figure>
<p><em>示例2. JCL语句</em></p>
<p>总之，ACCT-REC是内部文件名。ACCTREC是外部名称，其中JCL DDNAME必须与COBOL ASSIGN TO ACCTREC名称匹配。在程序执行期间，JCL ACCTREC DDNAME语句被重定向到紧</p>
<p>随JCL DD操作之后的数据集名称。</p>
<p><code>ACCT-REC &gt;&gt;&gt; ACCTREC &gt;&gt;&gt; //ACCTREC  &gt;&gt;&gt; DD &gt;&gt;&gt; MY.DATA</code></p>
<p>因此，COBOL内部文件名ACCT-REC从名为MY.DATA的顺序数据集中读取数据记录。</p>
<p>JCL是一个独立的z&#x2F;OS技术技能。COBOL简介仅介绍了有关JCL的足够信息，以了解COBOL内部文件名如何定位外部顺序数据集名称。要了解更多关于JCL的信息，请访问IBM知识中心：</p>
<p><a target="_blank" rel="noopener" href="https://www.ibm.com/docs/en/zos-basic-skills?topic=collection-basic-jcl-concepts">https://www.ibm.com/docs/en/zos-basic-skills?topic=collection-basic-jcl-concepts</a></p>
<h2 id="PROCEDURE-DIVISION-顺序文件处理"><a href="#PROCEDURE-DIVISION-顺序文件处理" class="headerlink" title="PROCEDURE DIVISION 顺序文件处理"></a>PROCEDURE DIVISION 顺序文件处理</h2><p>在COBOL程序运行时，SELECT ASSIGN TO JCL DDNAME是强制性的。如果ASSIGN TO名称未能与相同拼写的JCL DDNAME关联，运行时将发生程序运行时错误，当尝试执行OPEN操作时。运行时输出中将显示一条消息，指示未找到DDNAME。READ和WRITE操作依赖于成功完成OPEN操作。编译器无法检测运行时错误，因为编译器不知道实际运行时的JCL DDNAME数据集名称，该名称受OPEN、READ或WRITE操作的影响。数据记录字段的FD（File Descriptor）映射要求成功的OPEN操作才能由后续的READ或WRITE操作填充。</p>
<h3 id="打开输入和输出进行读取和写入"><a href="#打开输入和输出进行读取和写入" class="headerlink" title="打开输入和输出进行读取和写入"></a>打开输入和输出进行读取和写入</h3><p>必须打开COBOL输入和输出，以将所选的内部名称连接到分配的外部名称。图4打开文件名ACCT-REC作为程序输入和文件名PRINT-LINE作为程序输出。</p>
<p><img src="/image128.png" alt="OPEN-FILES"></p>
<p><em>图4. 打开文件</em></p>
<h3 id="关闭输入和输出"><a href="#关闭输入和输出" class="headerlink" title="关闭输入和输出"></a>关闭输入和输出</h3><p>在程序完成或更好地说是在程序不再从内部文件名读取或写入时，应关闭COBOL输入和输出。图5关闭内部文件名ACCT-REC和内部文件名PRINT-LINE，然后停止处理，STOP RUN。</p>
<p><img src="/image129.png" alt="CLOSE-STOP"></p>
<p><em>图5. 关闭和停止</em></p>
<h2 id="顺序读写记录的COBOL编程技巧"><a href="#顺序读写记录的COBOL编程技巧" class="headerlink" title="顺序读写记录的COBOL编程技巧"></a>顺序读写记录的COBOL编程技巧</h2><p>在读取记录时，程序首先需要检查是否没有记录需要读取，或者是否没有更多记录需要读取。如果存在记录，那么读取的记录中的字段将填充由FD子句定义的变量名。COBOL使用PERFORM语句进行迭代。在计算机编程中，迭代用于描述可以多次执行一系列指令或语句的情况。通过该序列的一次通行称为迭代。迭代执行也称为循环。在其他编程语言中，使用“DO”或“FOR”语句进行迭代执行。COBOL使用PERFORM语句进行迭代执行。图6显示了PROCEDURE DIVISION中的四个由程序员选择的段落名称。</p>
<ul>
<li><p>READ-NEXT-RECORD</p>
</li>
<li><p>CLOSE-STOP</p>
</li>
<li><p>READ-RECORD</p>
</li>
<li><p>WRITE-RECORD</p>
</li>
</ul>
<p>READ-NEXT-RECORD反复执行READ-RECORD和WRITE-RECORD，直到遇到最后一条记录。当遇到最后一条记录时，将执行CLOSE-STOP以停止程序。</p>
<p><img src="/image130.png" alt="Reading and writing records"></p>
<p><em>图6. 读写记录</em></p>
<p>**注意：**COBOL类似于英语，COBOL保留字也类似于英语。程序员可以自由使用类似于英语的变量名来帮助记住变量名的用途。PROCEDURE DIVISION的结构类似于英语。一个段落包含一个或多个句子。一个句子包含一个或多个语句。隐式的范围终结符，即句点（.），终止一个句子，或者终止多个连续的语句，这相当于复合句，其中“and”将可能是独立的句子连接在一起。</p>
<h3 id="READ-NEXT-RECORD段的执行"><a href="#READ-NEXT-RECORD段的执行" class="headerlink" title="READ-NEXT-RECORD段的执行"></a>READ-NEXT-RECORD段的执行</h3><p>READ-NEXT-RECORD段是一种COBOL编程技巧，用于从顺序文件中读取所有记录，直到读取最后一条记录为止。该段包含一个由隐式范围终结符（.）终止的复合句，该终结符位于END-PERFORM语句后的单独行上。通过PERFORM UNTIL和END-PERFORM之间的明确范围终结符，将反复执行，直到LASTREC变量包含Y。第一个PERFORM READ-RECORD导致分支到READ-RECORD段。请参阅图7中的＃1。</p>
<h3 id="READ-RECORD段"><a href="#READ-RECORD段" class="headerlink" title="READ-RECORD段"></a>READ-RECORD段</h3><p>READ-RECORD段执行COBOL READ语句，导致外部顺序文件填充与ACCT-REC内部文件名关联的变量。如果在读取的记录的“AT END”处，然后将Y移入LASTREC变量。READ语句由明确的范围终结符END-READ终止。该段由隐式范围终结符（.）终止。控制权返回到READ-NEXT-RECORD段，以执行下一个语句，即执行PERFORM WRITE-RECORD。</p>
<h3 id="WRITE-RECORD段"><a href="#WRITE-RECORD段" class="headerlink" title="WRITE-RECORD段"></a>WRITE-RECORD段</h3><p>WRITE-RECORD段包含由隐式范围终结符（.）终止的多个句子。MOVE语句导致将每个输入文件变量名移动到输出文件变量名。该段中的最后一个句子写入了输出文件变量名的集合，即PRINT-REC。</p>
<p>PRINT-REC分配给了PRTREC。使用JCL执行COBOL程序。关联的JCL PRTREC DDNAME将写入的输出重定向到z&#x2F;OS控制的数据集名称等，使用JCL DD操作在JCL DDNAME语句上。请参阅图7中的＃2。</p>
<h3 id="READ-NEXT-RECORD段的迭代处理"><a href="#READ-NEXT-RECORD段的迭代处理" class="headerlink" title="READ-NEXT-RECORD段的迭代处理"></a>READ-NEXT-RECORD段的迭代处理</h3><p>一旦执行了WRITE-RECORD段中的所有语句，控制权就会返回到READ-NEXT-RECORD段，其中要执行的下一个语句是第二个PERFORM READ-RECORD语句。</p>
<p>同样，READ-RECORD段执行COBOL READ语句，导致外部顺序文件填充与ACCT-REC内部文件名关联的变量。如果在读取的记录的“AT END”处找到Y，然后将控制权返回给READ-NEXT-RECORD段。READ-NEXT-RECORD段将继续迭代过程，直到LASTREC变量中找到Y。请参阅图7中的＃3。</p>
<p><img src="/2023/10/01/42687/image131.png" alt="Iterative processing"></p>
<p><em>图7. 迭代处理</em></p>
<h2 id="COBOL编程技巧用于按顺序读取和写入记录"><a href="#COBOL编程技巧用于按顺序读取和写入记录" class="headerlink" title="COBOL编程技巧用于按顺序读取和写入记录"></a>COBOL编程技巧用于按顺序读取和写入记录</h2><p>在读取记录时，程序首先需要检查是否没有要读取的记录，或者是否没有更多要读取的记录。如果存在记录，则从外部顺序文件中读取的字段将填充由FD子句定义的变量名。COBOL使用PERFORM语句进行迭代。在计算机编程中，迭代用于描述可以多次执行的一系列指令或语句的情况。一次通过序列被称为一个迭代。迭代执行也称为循环。在其他编程语言中，’DO’或’FOR’语句用于迭代执行。COBOL使用PERFORM语句进行迭代执行。图6显示了PROCEDURE DIVISION中的四个由程序员选择的段落名称。</p>
<ul>
<li><p>READ-NEXT-RECORD</p>
</li>
<li><p>CLOSE-STOP</p>
</li>
<li><p>READ-RECORD</p>
</li>
<li><p>WRITE-RECORD</p>
</li>
</ul>
<p>READ-NEXT-RECORD重复执行READ-RECORD和WRITE-RECORD，直到遇到最后一条记录。当遇到最后一条记录时，CLOSE-STOP被执行，停止程序的运行。</p>
<p><img src="/2023/10/01/42687/image131.png" alt="Figure 6. Reading and writing records"></p>
<p><strong>注意</strong>：COBOL类似于英语，COBOL保留字也类似于英语。程序员可以自由使用类似于英语的变量名，以帮助记住变量名的用途。PROCEDURE DIVISION的结构类似于英语。一个段落包含一个或多个句子。一个句子包含一个或多个语句。隐含的范围终结符，句号（.），用于终止句子或终止多个连续的语句，这相当于将潜在的独立句子连接在一起的复合句，其中“and”将潜在的独立句子连接在一起。</p>
<h3 id="READ-NEXT-RECORD段落的执行"><a href="#READ-NEXT-RECORD段落的执行" class="headerlink" title="READ-NEXT-RECORD段落的执行"></a>READ-NEXT-RECORD段落的执行</h3><p>READ-NEXT-RECORD段是一种用于从顺序文件读取所有记录的COBOL编程技巧，直到读取到最后一条记录为止。该段包含一个由隐式范围终结符（.）终止的复合句，该终结符在END-PERFORM语句之后的单独一行上。通过PERFORM UNTIL到END-PERFORM，显式的范围终结符，重复执行，直到LASTREC变量包含Y。首次执行PERFORM READ-RECORD会导致跳转到READ-RECORD段落。请参见图7中的#1。</p>
<h3 id="READ-RECORD段-1"><a href="#READ-RECORD段-1" class="headerlink" title="READ-RECORD段"></a>READ-RECORD段</h3><p>READ-RECORD段执行COBOL READ语句，导致外部顺序文件填充与ACCT-REC内部文件名关联的变量。如果“AT END”处于读取的记录之后，将Y移入LASTREC变量。READ语句由显式范围终结符END-READ终止。该段由隐式范围终结符（.）终止。控制返回到READ-NEXT-RECORD段，以执行下一个语句，即PERFORM WRITE-RECORD。</p>
<h3 id="WRITE-RECORD段-1"><a href="#WRITE-RECORD段-1" class="headerlink" title="WRITE-RECORD段"></a>WRITE-RECORD段</h3><p>WRITE-RECORD段包含多个由隐式范围终结符（.）终止的句子。MOVE语句导致将每个输入文件变量名移动到输出文件变量名。段的最后一个句子写入输出文件变量名的集合，即PRINT-REC。</p>
<p>PRINT-REC分配给PRTREC。使用JCL执行COBOL程序。相关联的JCL PRTREC DDNAME通过JCL DD操作将写入的输出重定向到z&#x2F;OS控制的数据集名称等。请参见图7中的＃2。</p>
<h3 id="READ-NEXT-RECORD段的迭代处理-1"><a href="#READ-NEXT-RECORD段的迭代处理-1" class="headerlink" title="READ-NEXT-RECORD段的迭代处理"></a>READ-NEXT-RECORD段的迭代处理</h3><p>一旦执行WRITE-RECORD段中的所有语</p>
<p>句，控制就会返回到READ-NEXT-RECORD段，下一个要执行的语句是第二个PERFORM READ-RECORD语句。</p>
<p>同样，READ-RECORD段执行COBOL READ语句，导致外部顺序文件填充与ACCT-REC内部文件名关联的变量。如果“AT END”处于读取的记录之后，将Y移入LASTREC变量，然后返回控制到READ-NEXT-RECORD段。READ-NEXT-RECORD段将继续进行迭代处理，直到LASTREC变量中找到Y。请参见图7中的＃3。</p>
<p><img src="/2023/10/01/42687/image131.png" alt="Figure 7. Iterative processing"></p>
<p><strong>实验</strong></p>
<p>下面是与本章节相关的实验，演示了用于从顺序文件中读取所有数据记录的“文件结束”COBOL编码技巧。如果某个步骤旁边有星号（*），则它将在实验内容的末尾具有相关的提示。</p>
<ol>
<li><p>如果尚未打开VS Code，请选择左侧边栏中的Zowe Explorer。</p>
<p><strong>注意</strong>：如果您正在打开VS Code的新实例（即在之前使用后关闭了它），则可能需要再次“选择筛选器”。您可以通过在数据集部分中选择左侧边栏中的命名连接旁边的搜索图标！<a href="image132.png"></a>，然后重新选择以前使用的筛选器。在您选择搜索符号后，它应该出现在列出的筛选器中。</p>
</li>
<li><p>查看id.CBL数据集中列出的以下COBOL源代码成员：</p>
<ul>
<li><p>CBL0001</p>
</li>
<li><p>CBL0002</p>
</li>
</ul>
</li>
<li><p>查看id.JCL数据集中列出的以下三个JCL成员：</p>
<ul>
<li><p>CBL0001J</p>
</li>
<li><p>CBL0002J</p>
</li>
<li><p>CBL0003J</p>
</li>
</ul>
<p><img src="/2023/10/01/42687/image133.png" alt="Figure 8. Id.JCL(CBL0001J).jcl"></p>
</li>
<li><p>在DATA SET部分内提交作业JCL(CBL0001J)。</p>
</li>
<li><p>使用JOBS部分查看该作业的输出。</p>
<ul>
<li><p>COBRUN:SYSPRINT(101) - COBOL程序编译器输出</p>
</li>
<li><p>RUN:PRTLINE(103) - COBOL程序执行输出，如图9所示。</p>
</li>
</ul>
<p><img src="/2023/10/01/42687/image134.png" alt="Figure 9. RUN:PRTLINE(103) for JCL(CBL0001J)"></p>
</li>
<li><p>在DATA SET部分内提交作业JCL(CBL0002J)。</p>
</li>
<li><p>使用JOBS部分查看该作业的输出。</p>
<ul>
<li>COBRUN:SYSPRINT(101) - COBOL程序编译器输出</li>
</ul>
<p>在步骤7中的输出文件中查找COBOL编译器的严重消息IGYPS2121-S，如图10所示。</p>
<p><img src="/2023/10/01/42687/image135.png" alt="Figure 10. IGYPS2121-S message"></p>
</li>
<li><p>编辑CBL(CBL0002)：</p>
<ul>
<li>确定PRINT-REX的正确拼写，然后在源代码中进行更正，并保存更新后的源代码。</li>
</ul>
</li>
<li><p>使用DATA SET部分重新提交作业JCL(CBL0002J)，并在JOBS部分查看输出。</p>
<ul>
<li><p>COBRUN:SYSPRINT(101) - COBOL程序编译器输出</p>
</li>
<li><p>RUN:PRTLINE(103)是COBOL程序执行输出（如果更正成功）</p>
</li>
</ul>
</li>
<li><p>使用DATA SET部分提交作业JCL(CBL0003J)。</p>
</li>
<li><p>使用JOBS部分查看CBL0003J ABENDU4038输出：</p>
<ul>
<li><p>从COBOL程序执行输出中查看IGZ00355异常消息，位于RUN:SYSOUT(104)中。</p>
</li>
<li><p>IGZ00355消息显示，程序无法打开或关闭ACCTREC文件名，如图11所示，引导您找到错误的根本原因。</p>
<p><img src="/2023/10/01/42687/image137.png" alt="Figure 11. RUN:SYSOUT(104) message"></p>
</li>
</ul>
</li>
<li><p>通过编辑JCL(CBL0003J)来修复此错误：</p>
<ul>
<li><p>确定所需的DDNAME，但缺少或拼写错误。</p>
</li>
<li><p>在代码中进行更正，并保存。</p>
</li>
</ul>
</li>
<li><p>使用DATA SET部分重新提交作业JCL(CBL0003J)。</p>
</li>
<li><p>使用JOBS部分查看CBL0003J输出，您的输出应如图12所示。</p>
<ul>
<li>RUN:PRTLINE - COBOL程序执行输出（如果更正成功）</li>
</ul>
</li>
</ol>
<p>   <img src="/2023/10/01/42687/image138.png" alt="Figure 12. RUN:PRTLINE(103) for JCL(CBL0003J)"></p>
<p><strong>实验提示</strong></p>
<ol start="13">
<li>错误位于第11行，请相应地调整’ACCTREX’。请参见图13。</li>
</ol>
<p>   <img src="/2023/10/01/42687/image140.png" alt="Figure 13. Error in id.JCL(CBL0003J).jcl"></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/program/">program</a>
                    
                  </div>
                
              </div>
              
                
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/10/01/64225.html">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">COBOL考古（九）</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/10/01/4826.html">
                        <span class="hidden-mobile">COBOL考古（七）</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


            

                
                  <a id="scroll-top-button" href="#" role="button">
                    <i class="iconfont icon-arrowup" aria-hidden="true"></i>
                  </a>
                  

                    

                          
      </main>

      <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://whale3070.github.io/" target="_blank" rel="nofollow noopener"><span>Whale3070</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->




  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>





  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<link href="/pagefind/pagefind-ui.css" rel="stylesheet">
  <script src="/pagefind/pagefind-ui.js"></script>
  <style>
    /* 搜索框配色适配 */
    #search { margin-top: 2rem; }
    [data-user-color-scheme='dark'] .pagefind-ui {
      --pagefind-ui-primary: #eeeeee;
      --pagefind-ui-text: #eeeeee;
      --pagefind-ui-background: #151515;
      --pagefind-ui-border: #333;
    }
  </style>
    </body>

  </html>