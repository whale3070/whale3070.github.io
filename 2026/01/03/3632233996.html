

  <!DOCTYPE html>
  <html lang="zh-CN" data-default-color-scheme=&#34;dark&#34; >
  <style>
    .text1
    {
    text-shadow: 0px 0px 2px #f2f3f2;
    }
    </style>

  <script>
    // 强制内网 IP 识别为安全上下文
    if (window.location.hostname !== 'localhost' && window.location.protocol === 'http:') {
        // 尝试手动映射 crypto 属性
        if (!window.crypto.subtle && window.crypto.webkitSubtle) {
            window.crypto.subtle = window.crypto.webkitSubtle;
        }
    }
    
    // 终极补丁：如果还是没有 subtle，则创建一个占位符避免报错
    // 提示：这通常能解决加载报错，但如果插件强依赖原生加密，建议执行下面的“降级”预判
    if (!window.isSecureContext) {
        console.warn('当前环境非安全上下文，正在尝试兼容内网加密解密...');
    }
</script>


<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/null">
  <link rel="icon" type="image/png" href="/null">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>Polkadot Solidity开发-课程笔记6 - whale3070&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.4.0/styles/github-gist.min.css" />
    
  

  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"whale3070.github.io","root":"/","version":"1.8.7","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":false,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 7.3.0"></head>


    <body>
      <header style="height: 70vh;">
        <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>InfoSec learning</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/search/">
                <i class="iconfont icon-search"></i>
                搜索
              </a>
            </li>
          
        
        
        
          
        
      </ul>
    </div>
  </div>
</nav>

          <div class="banner" id="banner" false
            style="background: url('/img/default.png') no-repeat center center;
              background-size: cover;">
              <div class="full-bg-img">
                <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
                  <div class="page-header text-center fade-in-up">
                    <span class="h2 text1" id="subtitle" title="Polkadot Solidity开发-课程笔记6">
                      
                        Polkadot Solidity开发-课程笔记6
                      
                    </span>
        
                    
                      <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2026-01-03 16:12" pubdate>
        2026年1月3日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      5.8k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      64
       分钟
    </span>
  

  
  
</div>

                    
                  </div>
                    
                  </div>
                  
                </div>
              </div>
          </div>
      </header>

      <main>
        
          

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" data-pagefind-body>
            <!-- SEO header -->
            <h1 style="display: none">Polkadot Solidity开发-课程笔记6</h1>
            
            <div class="markdown-body">
              <p>同学们【第 2 课｜REVM vs Ethereum：差异深度解析】更新啦，学习指南来咯！</p>
<p>🚩课程学习链接：<a target="_blank" rel="noopener" href="https://youtube.com/playlist?list=PLKgwQU2jh_H8zyq46XsUkAz10213HDL0i&si=UqonC3oL304_Mtrk">https://youtube.com/playlist?list=PLKgwQU2jh_H8zyq46XsUkAz10213HDL0i&amp;si=UqonC3oL304_Mtrk</a></p>
<p>️ 第一课 Task1 任务：<br>️选择题：<a target="_blank" rel="noopener" href="https://wj.qq.com/s2/25347684/g0pl/">https://wj.qq.com/s2/25347684/g0pl/</a><br>️实践题：<a target="_blank" rel="noopener" href="https://github.com/papermoonio/2026-h1-building-production-grade-dApps/tree/main/homework/lesson-1">https://github.com/papermoonio/2026-h1-building-production-grade-dApps/tree/main/homework/lesson-1</a></p>
<p>️ 第二课 Task2 任务：<br>️选择题：<a target="_blank" rel="noopener" href="https://wj.qq.com/s2/25402456/fb1j/">https://wj.qq.com/s2/25402456/fb1j/</a><br>️实践题：<a target="_blank" rel="noopener" href="https://github.com/papermoonio/2026-h1-building-production-grade-dApps/blob/main/homework/lesson-2/README.md">https://github.com/papermoonio/2026-h1-building-production-grade-dApps/blob/main/homework/lesson-2/README.md</a></p>
<p> 学员手册：<a target="_blank" rel="noopener" href="https://www.notion.so/19-2d3ea3dc654981ccb8fbfe2ced5a1450">https://www.notion.so/19-2d3ea3dc654981ccb8fbfe2ced5a1450</a></p>
<p> Office Hour 1：1月5日（下周一）晚上20:00<br><a target="_blank" rel="noopener" href="https://meeting.tencent.com/dm/1TnqhW1H7BMQ">https://meeting.tencent.com/dm/1TnqhW1H7BMQ</a></p>
<p>#腾讯会议：660-1614-4124</p>
<p>————————</p>
<p>必看福利<br>️2月8日 24:00前完成课程学习和 5次 Task任务，可顺利毕业并瓜分 200U 奖金池；<br>️2月6日 24:00前完成课程学习和 6次Task任务，且 Task 任务总分达到📌42分及以上，即颁发优秀毕业证书，并额外瓜分 200U 奖金池；<br>说明：优秀学员可同时参与毕业学员和优秀学员的奖金池瓜分！冲<br>️OneBlock Zealy 积分奖励，积分排名靠前有机会赢得年底社区积分激励。更多奖品内容还有：工作机会内推、波卡周边、波卡专属资料包等等，等同学们来获取！<br>Zealy 🔗：<a target="_blank" rel="noopener" href="https://zealy.io/cw/oneblock-7054/questboard">https://zealy.io/cw/oneblock-7054/questboard</a></p>
<p>————————</p>
<p>️【提示】大家关于【课程内容】有任何不懂的技术难题，可以随时提问，提问前务必请@老师及助教团队<br>每晚8点-10点助教值班答疑，每日会有助教为大家答疑，帮助大家一起进步」</p>
<h1 id="revive-强大的预编译系统。是什么"><a href="#revive-强大的预编译系统。是什么" class="headerlink" title="revive 强大的预编译系统。是什么"></a>revive 强大的预编译系统。是什么</h1><p>Revive 预编译（Precompile）系统是波卡 PolkaVM 生态中，由 pallet‑revive 提供的高性能原生函数调用层，核心是通过固化的链上原生实现替代合约级逻辑，同时兼容 EVM 开发范式、支持自定义扩展，兼具效率、安全与灵活性三大优势。以下从核心定位、技术架构、关键能力与安全审计要点展开说明。</p>
<hr>
<h3 id="一、核心定位与价值"><a href="#一、核心定位与价值" class="headerlink" title="一、核心定位与价值"></a>一、核心定位与价值</h3><p>预编译是波卡 2.0 适配 Solidity 与 EVM 生态的关键组件，解决了三类核心问题：</p>
<ol>
<li><strong>性能瓶颈突破</strong>：将哈希运算（如 SHA256）、签名验证（如 ECRecover）、零知识证明校验等高频&#x2F;高耗计算用原生代码实现，比合约级实现提速 10–100 倍，同时降低 Gas 成本。</li>
<li><strong>跨生态兼容</strong>：提供 EVM 风格的预编译地址与 ABI 接口，让以太坊开发者无缝迁移代码，无需重写核心逻辑。</li>
<li><strong>链上能力扩展</strong>：将 Substrate Runtime 功能（如资产转账、跨链消息）通过预编译暴露给合约，实现合约与底层模块的直接交互，扩展智能合约边界。</li>
</ol>
<hr>
<h3 id="二、技术架构与核心组件"><a href="#二、技术架构与核心组件" class="headerlink" title="二、技术架构与核心组件"></a>二、技术架构与核心组件</h3><h4 id="1-预编译类型与地址规则（延续你之前的考点）"><a href="#1-预编译类型与地址规则（延续你之前的考点）" class="headerlink" title="1. 预编译类型与地址规则（延续你之前的考点）"></a>1. 预编译类型与地址规则（延续你之前的考点）</h4><table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">定义</th>
<th align="left">地址格式</th>
<th align="left">分配机制</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Builtin（内置）</td>
<td align="left">由 Revive 底层固化，如 ECRecover、SHA256</td>
<td align="left">前 16 字节 0 + 后 4 字节 u32 编号</td>
<td align="left">同类型连续递增，固定前缀隔离</td>
</tr>
<tr>
<td align="left">External（外部）</td>
<td align="left">由 Runtime 配置注入，如自定义资产模块</td>
<td align="left">自定义前缀 + 连续偏移</td>
<td align="left">与 Builtin 隔离，支持 Prefix 批量管理</td>
</tr>
<tr>
<td align="left">Multiple（组）</td>
<td align="left">一组合约共享前缀，如 ERC20 模板组</td>
<td align="left">前 4 字节参数 + 后 4 字节固定编号</td>
<td align="left">组内参数连续，组间编号隔离</td>
</tr>
</tbody></table>
<h4 id="2-调用与执行流程"><a href="#2-调用与执行流程" class="headerlink" title="2. 调用与执行流程"></a>2. 调用与执行流程</h4><ol>
<li>合约通过预编译地址发起 low‑level call，传入符合 ABI 的 calldata。</li>
<li>执行器匹配地址到对应预编译，进入原生代码路径（绕过 PolkaVM 字节码解释）。</li>
<li>按 ref_time（计算耗时）、proof_size（证明大小）、storage deposit（存储押金）计算 Gas 并扣费。</li>
<li>执行完成后返回结果，失败仅回滚当前合约级状态，不影响调用栈上层。</li>
</ol>
<h4 id="3-实现核心：Precompile-Trait"><a href="#3-实现核心：Precompile-Trait" class="headerlink" title="3. 实现核心：Precompile Trait"></a>3. 实现核心：Precompile Trait</h4><p>开发者通过实现 <code>Precompile</code> Trait 定义预编译逻辑，核心方法如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Precompile</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">execute</span>(<br>        &amp;<span class="hljs-keyword">self</span>,<br>        gas_meter: &amp;<span class="hljs-keyword">mut</span> GasMeter,  <span class="hljs-comment">// Gas 计量器</span><br>        input: &amp;[<span class="hljs-type">u8</span>],              <span class="hljs-comment">// 调用输入</span><br>    ) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">u8</span>&gt;, PrecompileError&gt;;  <span class="hljs-comment">// 输出或错误</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>示例：SHA256 预编译直接调用 Substrate 原生哈希函数，输入处理成本计入 ref_time，无需合约层重复实现。</p>
<hr>
<h3 id="三、强大之处：四大关键能力"><a href="#三、强大之处：四大关键能力" class="headerlink" title="三、强大之处：四大关键能力"></a>三、强大之处：四大关键能力</h3><h4 id="1-极致性能与成本优化"><a href="#1-极致性能与成本优化" class="headerlink" title="1. 极致性能与成本优化"></a>1. 极致性能与成本优化</h4><ul>
<li><strong>原生执行</strong>：绕过合约字节码解释，直接运行 RISC‑V 原生代码，计算密集型操作耗时显著降低。</li>
<li><strong>精准 Gas 计费</strong>：按 ref_time、proof_size、storage deposit 多维度计费，避免“一刀切”，降低不必要开销。</li>
<li><strong>存储押金机制</strong>：为链上存储支付押金（释放时退还），平衡存储成本与用户负担。</li>
</ul>
<h4 id="2-高度可扩展的自定义体系"><a href="#2-高度可扩展的自定义体系" class="headerlink" title="2. 高度可扩展的自定义体系"></a>2. 高度可扩展的自定义体系</h4><ul>
<li><strong>Runtime 集成</strong>：可将任意 Pallet 功能（如 staking、governance）封装为预编译，让合约调用底层模块。</li>
<li><strong>多语言支持</strong>：兼容 Solidity 与 Rust 合约，通过 resolc 编译器将 Solidity 编译为 PolkaVM 字节码，无缝对接 EVM 工具链。</li>
<li><strong>动态配置</strong>：External 预编译可通过 Runtime 升级添加&#x2F;移除，无需硬分叉，适配链上治理需求。</li>
</ul>
<h4 id="3-安全与稳定性保障"><a href="#3-安全与稳定性保障" class="headerlink" title="3. 安全与稳定性保障"></a>3. 安全与稳定性保障</h4><ul>
<li><strong>权限隔离</strong>：预编译仅暴露指定功能，避免合约直接操作底层存储，降低恶意调用风险。</li>
<li><strong>错误隔离</strong>：执行失败仅回滚当前合约状态，防止错误冒泡导致全局回滚。</li>
<li><strong>Gas 硬限制</strong>：通过 ref_time 严格控制执行耗时，避免无限循环或资源耗尽攻击。</li>
</ul>
<h4 id="4-生态兼容与迁移友好"><a href="#4-生态兼容与迁移友好" class="headerlink" title="4. 生态兼容与迁移友好"></a>4. 生态兼容与迁移友好</h4><ul>
<li><strong>EVM 接口对齐</strong>：预编译地址、ABI 与以太坊主网兼容，以太坊合约可直接复用调用逻辑。</li>
<li><strong>工具链支持</strong>：Hardhat、Foundry 等可通过 precompiles‑hardhat 插件与预编译交互，降低迁移成本。</li>
</ul>
<hr>
<h3 id="四、安全审计要点（Web3-安全审计视角）"><a href="#四、安全审计要点（Web3-安全审计视角）" class="headerlink" title="四、安全审计要点（Web3 安全审计视角）"></a>四、安全审计要点（Web3 安全审计视角）</h3><ol>
<li><strong>地址冲突校验</strong>：检查 External 预编译地址是否与 Builtin 重叠，避免调用异常。</li>
<li><strong>Gas 计量准确性</strong>：验证 ref_time 与 proof_size 估算是否合理，防止 Gas 不足或过量计费。</li>
<li><strong>权限控制</strong>：确认预编译是否限制调用者权限，避免敏感操作（如 Runtime 升级）被恶意调用。</li>
<li><strong>存储押金逻辑</strong>：检查存储释放时的押金退还流程，防止资产锁定或丢失。</li>
<li><strong>输入校验</strong>：预编译需严格校验 calldata 格式，避免输入错误导致的执行异常。</li>
</ol>
<hr>
<h3 id="五、与-Frontier-EVM-预编译的区别"><a href="#五、与-Frontier-EVM-预编译的区别" class="headerlink" title="五、与 Frontier EVM 预编译的区别"></a>五、与 Frontier EVM 预编译的区别</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Revive Precompile</th>
<th align="left">Frontier EVM Precompile</th>
</tr>
</thead>
<tbody><tr>
<td align="left">执行环境</td>
<td align="left">PolkaVM（RISC‑V 原生）</td>
<td align="left">EVM 字节码解释器</td>
</tr>
<tr>
<td align="left">Gas 机制</td>
<td align="left">ref_time + proof_size + storage deposit</td>
<td align="left">单一 Gas 计量</td>
</tr>
<tr>
<td align="left">扩展方式</td>
<td align="left">通过 Runtime 配置注入 External 预编译</td>
<td align="left">需修改 EVM 模块代码</td>
</tr>
<tr>
<td align="left">存储模型</td>
<td align="left">存储押金（可退还）</td>
<td align="left">直接 Gas 计费（不可退还）</td>
</tr>
</tbody></table>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Revive 预编译系统是波卡 2.0 智能合约生态的“性能引擎”与“生态桥梁”，既保留 Substrate 的灵活性，又兼容 EVM 开发习惯，同时通过精细化的 Gas 模型与安全设计，为 Web3 应用提供高效、安全的底层支持。对于智能合约审计，需重点关注地址规则、Gas 计算与权限控制三大维度，确保预编译调用的正确性与安全性。</p>
<p>需要我基于你的审计场景，整理一份 <strong>Revive 预编译安全审计 checklist</strong>，包含地址冲突、Gas 校验、权限控制等 10 个可直接执行的检查项吗？</p>
<h1 id="我从零基础到波卡开发程序员初级岗位需要花多久，我需要补充哪些知识？需要花多久的时间。"><a href="#我从零基础到波卡开发程序员初级岗位需要花多久，我需要补充哪些知识？需要花多久的时间。" class="headerlink" title="我从零基础到波卡开发程序员初级岗位需要花多久，我需要补充哪些知识？需要花多久的时间。"></a>我从零基础到波卡开发程序员初级岗位需要花多久，我需要补充哪些知识？需要花多久的时间。</h1><p>我目前已经刷完了university.alchemy的solidity课程，cryptozombies课程。</p>
<hr>
<p>这是一个非常棒的起点！既然你已经掌握了 Solidity 和 Alchemy&#x2F;CryptoZombies 的核心逻辑，你已经越过了 Web3 开发最难的“思维门槛”。</p>
<p>在 2026 年这个时间节点，波卡（Polkadot）正处于 <strong>Polkadot 2.0</strong> 和 <strong>Revive</strong> 升级的关键期。这意味着你可以利用已有的 Solidity 背景，通过“混合路径”快速切入。</p>
<p>从零基础到拿到初级岗位，预计还需要 <strong>3 到 5 个月</strong> 的专项突破。以下是你的学习地图：</p>
<hr>
<h3 id="第一阶段：转型波卡-Solidity-开发者-1个月"><a href="#第一阶段：转型波卡-Solidity-开发者-1个月" class="headerlink" title="第一阶段：转型波卡 Solidity 开发者 (1个月)"></a>第一阶段：转型波卡 Solidity 开发者 (1个月)</h3><p>由于你已有 Solidity 基础，最快切入波卡的方式是通过 <strong>pallet-revive</strong>。</p>
<ul>
<li><p><strong>补充知识：</strong></p>
</li>
<li><p><strong>Polkadot 原理：</strong> 理解 Relay Chain（中继链）与 Parachains（平行链）的关系，以及为什么 Smart Contracts 不在 Relay Chain 上运行。</p>
</li>
<li><p><strong>Revive 机制：</strong> 学习 Solidity 如何通过 <code>resolc</code> 编译器转换为 RISC-V 字节码在波卡上运行。</p>
</li>
<li><p><strong>SS58 账户体系：</strong> 深入理解你之前问到的地址转换逻辑。</p>
</li>
<li><p><strong>工具链：</strong> 学习使用 <strong>Foundry</strong>（波卡目前主流偏向 Rust 风格工具）或 <strong>Hardhat</strong> 配合波卡的 RPC。</p>
</li>
</ul>
<h3 id="第二阶段：攻克波卡的“灵魂”——跨链通信-XCM-1-1-5个月"><a href="#第二阶段：攻克波卡的“灵魂”——跨链通信-XCM-1-1-5个月" class="headerlink" title="第二阶段：攻克波卡的“灵魂”——跨链通信 XCM (1-1.5个月)"></a>第二阶段：攻克波卡的“灵魂”——跨链通信 XCM (1-1.5个月)</h3><p>这是波卡程序员区别于以太坊程序员的核心竞争力。</p>
<ul>
<li><p><strong>补充知识：</strong></p>
</li>
<li><p><strong>XCM (Cross-Consensus Messaging)：</strong> 学习如何让资产在不同的平行链（如 Asset Hub 和 Astar）之间跨链转移。</p>
</li>
<li><p><strong>异步组合性：</strong> 理解波卡 2.0 的 <strong>Elastic Scaling（弹性扩展）</strong> 概念。</p>
</li>
<li><p><strong>实践：</strong> 在测试网（如 Paseo）上实现一个跨链转账或跨链远程调用。</p>
</li>
</ul>
<h3 id="第三阶段：Rust-与-Substrate-进阶-2-2-5个月"><a href="#第三阶段：Rust-与-Substrate-进阶-2-2-5个月" class="headerlink" title="第三阶段：Rust 与 Substrate 进阶 (2-2.5个月)"></a>第三阶段：Rust 与 Substrate 进阶 (2-2.5个月)</h3><p>波卡的高级岗位通常要求懂一些底层。即便你主攻应用层，也要能看懂 Substrate。</p>
<ul>
<li><strong>补充知识：</strong></li>
<li><strong>Rust 语言：</strong> 重点掌握 Ownership, Traits 和 Macros（这是 Substrate 的基石）。</li>
<li><strong>Substrate Pallets：</strong> 了解链级开发逻辑，学习如何自定义一个 Pallet（插件）。</li>
<li><strong>Polkadot SDK：</strong> 学习如何使用最新的 SDK 进行前后端交互（如 <code>dedot</code> 或 <code>polkadot-js</code>）。</li>
</ul>
<hr>
<h3 id="时间表与建议"><a href="#时间表与建议" class="headerlink" title="时间表与建议"></a>时间表与建议</h3><table>
<thead>
<tr>
<th>阶段</th>
<th>重点内容</th>
<th>预计耗时</th>
<th>目标</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Stage 1</strong></td>
<td>Revive &#x2F; Solidity 兼容层</td>
<td>4 周</td>
<td>能在波卡上部署复杂的 Solidity 合约</td>
</tr>
<tr>
<td><strong>Stage 2</strong></td>
<td>XCM 跨链编程</td>
<td>6 周</td>
<td>掌握多链资产交互逻辑</td>
</tr>
<tr>
<td><strong>Stage 3</strong></td>
<td>Rust 入门 + Substrate 基础</td>
<td>8 周</td>
<td>能读懂波卡源码，修改简单的 Pallet</td>
</tr>
</tbody></table>
<h1 id="实践题"><a href="#实践题" class="headerlink" title="实践题"></a>实践题</h1><p>编程实现地址的转换，并测试balance是否一致<br>选择一个precompile来调用。这个题目是什么意思呢？我没看懂</p>
<hr>
<p>简单来说，这个作业考察的是你对 <strong>“平行链的双重身份”</strong> 的理解。</p>
<p>在 Polkadot 的 EVM 平行链（如 Moonbeam 或 Astar）中，同一个账户在底层逻辑上存在两个“面孔”：一个是 <strong>以太坊格式 (H160)</strong>，一个是 <strong>Substrate 格式 (AccountId32)</strong>。</p>
<h3 id="1-题目大白话翻译"><a href="#1-题目大白话翻译" class="headerlink" title="1. 题目大白话翻译"></a>1. 题目大白话翻译</h3><ul>
<li><p><strong>地址转换</strong>：编写代码，把你的以太坊地址（0x…）转换成 Substrate 能够识别的地址格式。</p>
</li>
<li><p><strong>选择一个 Precompile（预编译合约）来调用</strong>：</p>
</li>
<li><p><strong>背景</strong>：Substrate 原生功能（如质押、投票、转账）是用 Rust 写的，以太坊虚拟机（EVM）本来调不动。</p>
</li>
<li><p><strong>Precompile</strong> 就像是一个“翻译官合约”，它被固定在特定的地址上。你用 Solidity 调用这个地址，实际上是在触发底层 Rust 代码的功能。</p>
</li>
<li><p><strong>测试 Balance 是否一致</strong>：</p>
</li>
<li><p>你从以太坊这一侧（EVM）查到的余额，和通过“翻译官”（Precompile）去底层 Substrate 查到的余额，应该是同一个数。</p>
</li>
</ul>
<hr>
<h3 id="2-核心逻辑图解"><a href="#2-核心逻辑图解" class="headerlink" title="2. 核心逻辑图解"></a>2. 核心逻辑图解</h3><hr>
<h3 id="3-你需要做的具体步骤（以-Moonbeam-为例）"><a href="#3-你需要做的具体步骤（以-Moonbeam-为例）" class="headerlink" title="3. 你需要做的具体步骤（以 Moonbeam 为例）"></a>3. 你需要做的具体步骤（以 Moonbeam 为例）</h3><p>如果你还没有代码思路，可以按照这个逻辑去写：</p>
<h4 id="第一步：地址转换-JavaScript-示例"><a href="#第一步：地址转换-JavaScript-示例" class="headerlink" title="第一步：地址转换 (JavaScript 示例)"></a>第一步：地址转换 (JavaScript 示例)</h4><p>在 Moonbeam 这种链上，地址映射遵循特定的规则。你可以使用官方工具库：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; u8aToHex &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@polkadot/util&#x27;</span>);<br><span class="hljs-keyword">const</span> &#123; addressToEvm, evmToAddress &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@typedstar/address-converter&#x27;</span>); <span class="hljs-comment">// 示例库</span><br><br><span class="hljs-comment">// 你的以太坊地址</span><br><span class="hljs-keyword">const</span> ethAddress = <span class="hljs-string">&quot;0x123...abc&quot;</span>;<br><br><span class="hljs-comment">// 转换成 Substrate 地址</span><br><span class="hljs-keyword">const</span> substrateAddress = <span class="hljs-title function_">evmToAddress</span>(ethAddress);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`对应的 Substrate 地址是: <span class="hljs-subst">$&#123;substrateAddress&#125;</span>`</span>);<br><br></code></pre></div></td></tr></table></figure>

<h4 id="第二步：调用-Precompile-查余额"><a href="#第二步：调用-Precompile-查余额" class="headerlink" title="第二步：调用 Precompile 查余额"></a>第二步：调用 Precompile 查余额</h4><p>你要找的“翻译官”地址通常是 <code>0x0000000000000000000000000000000000000802</code>（这是 Moonbeam 的 Balances 预编译地址）。</p>
<p>你需要在代码里调用这个合约的 <code>balance</code> 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">// 这是一个 Precompile 的接口定义<br>interface IBalances &#123;<br>    function balance(address account) external view returns (uint256);<br>&#125;<br><br></code></pre></div></td></tr></table></figure>

<h4 id="第三步：比对结果"><a href="#第三步：比对结果" class="headerlink" title="第三步：比对结果"></a>第三步：比对结果</h4><ol>
<li>调用标准的 <code>eth.getBalance(ethAddress)</code> -&gt; 得到结果 A。</li>
<li>调用 <code>IBalances(0x...802).balance(ethAddress)</code> -&gt; 得到结果 B。</li>
<li><strong>验证：A 是否等于 B？</strong> 如果相等，说明你通过“原生方式”和“预编译方式”访问的是同一个状态。</li>
</ol>
<hr>
<h3 id="为什么要做这个作业？"><a href="#为什么要做这个作业？" class="headerlink" title="为什么要做这个作业？"></a>为什么要做这个作业？</h3><p>这和你之前提到的“排除错误选项”的思维很像。在 Polkadot 生态开发中，最容易出错的地方就是<strong>地址对应关系</strong>。</p>
<p>如果你不理解 H160 到 AccountId32 的转换，你可能在 EVM 里存了钱，但在参与波卡治理（治理通常在 Substrate 层）时发现自己“没钱”。通过这个作业，你就能从代码层面确信：<strong>这两个身份确实是绑定在一起的。</strong></p>
<p>你想让我针对具体的某条链（比如 Moonbeam 还是自己搭建的节点）给你一套可以直接运行的测试脚本吗？</p>
<h1 id="rust语言和c语言有什么区别"><a href="#rust语言和c语言有什么区别" class="headerlink" title="rust语言和c语言有什么区别"></a>rust语言和c语言有什么区别</h1><p>理解 Rust 与 C 的区别，最核心的切入点就是**“对内存安全（Authority over Memory）的迷信与破除”**。</p>
<p>在 C 语言中，程序员拥有绝对的权威（指针、手动内存管理），但这种权威极易出错；而 Rust 的逻辑是：<strong>通过一套极其严密的数学&#x2F;逻辑规则（所有权机制），在编译阶段就排除掉所有错误的内存操作选项。</strong></p>
<p>以下是它们的核心差异对比：</p>
<hr>
<h3 id="1-内存管理：自由-vs-逻辑约束"><a href="#1-内存管理：自由-vs-逻辑约束" class="headerlink" title="1. 内存管理：自由 vs. 逻辑约束"></a>1. 内存管理：自由 vs. 逻辑约束</h3><ul>
<li><strong>C 语言（手动挡&#x2F;信任程序员）：</strong><br>你使用 <code>malloc</code> 申请内存，用 <code>free</code> 释放。如果你忘了释放（内存泄漏），或者释放了两次（Double Free），甚至访问了已经释放的地址（悬空指针），C 编译器通常不会拦着你。这就像你小学时发现的——“权威”也可能逻辑错误。</li>
<li><strong>Rust 语言（自动挡&#x2F;逻辑校验）：</strong><br>引入了 <strong>Ownership（所有权）</strong>、<strong>Borrowing（借用）</strong> 和 <strong>Lifetimes（生命周期）</strong>。</li>
<li><strong>规则 1：</strong> 每个值都有一个变量作为它的“主人”。</li>
<li><strong>规则 2：</strong> 主人没了，值立刻销毁。</li>
<li><strong>结果：</strong> 编译器在编译时就确定了内存什么时候该释放。如果你逻辑不通（比如想用一个已经失效的变量），代码根本跑不起来。</li>
</ul>
<hr>
<h3 id="2-安全性：事后调试-vs-事前排除"><a href="#2-安全性：事后调试-vs-事前排除" class="headerlink" title="2. 安全性：事后调试 vs. 事前排除"></a>2. 安全性：事后调试 vs. 事前排除</h3><table>
<thead>
<tr>
<th>特性</th>
<th>C 语言</th>
<th>Rust 语言</th>
</tr>
</thead>
<tbody><tr>
<td><strong>内存安全</strong></td>
<td>极不安全（缓冲区溢出、段错误常见）</td>
<td><strong>原生安全</strong>（除非你显式使用 <code>unsafe</code>）</td>
</tr>
<tr>
<td><strong>并发&#x2F;多线程</strong></td>
<td>容易产生竞态条件（Data Race），极难调试</td>
<td><strong>无畏并发</strong>（编译器保证不会有两个线程同时写同一块内存）</td>
</tr>
<tr>
<td><strong>报错信息</strong></td>
<td>经常只有 <code>Segmentation Fault</code> (段错误)</td>
<td>报错信息极其详尽，甚至会教你如何修改代码</td>
</tr>
</tbody></table>
<hr>
<h3 id="3-开发效率与工具链"><a href="#3-开发效率与工具链" class="headerlink" title="3. 开发效率与工具链"></a>3. 开发效率与工具链</h3><ul>
<li><strong>C 语言：</strong> 构建系统（Make, CMake）相对原始，依赖管理是一个巨大的痛点。</li>
<li><strong>Rust 语言：</strong> 拥有现代化的工具链 <strong>Cargo</strong>。它既是编译器前端，也是包管理器，还是测试工具。这极大提升了“全球信息获取权”下的协作效率，你可以非常方便地引用全球开发者的库（Crates）。</li>
</ul>
<hr>
<h3 id="4-性能：不相上下"><a href="#4-性能：不相上下" class="headerlink" title="4. 性能：不相上下"></a>4. 性能：不相上下</h3><p>在执行速度上，Rust 与 C 几乎在一个量级。Rust 没有 Java 或 Python 那样的垃圾回收（GC）停顿。它通过静态分析把安全检查放在了<strong>编译阶段</strong>，所以运行时没有额外负担。</p>
<hr>
<h3 id="为什么波卡（Polkadot）选择-Rust？"><a href="#为什么波卡（Polkadot）选择-Rust？" class="headerlink" title="为什么波卡（Polkadot）选择 Rust？"></a>为什么波卡（Polkadot）选择 Rust？</h3><p>结合你正在做的作业，波卡选择 Rust 而不是 C 的逻辑非常清晰：</p>
<ol>
<li><strong>确定性：</strong> 区块链逻辑必须极其严密，不能因为内存溢出导致节点崩溃。</li>
<li><strong>安全性：</strong> 在处理巨额资产时，C 语言微小的指针错误可能导致整个链被黑客洗劫。</li>
<li><strong>WASM 支持：</strong> Rust 对 WebAssembly（Wasm）的支持是目前工业界最好的，而 Wasm 是波卡实现跨链和逻辑升级的核心。</li>
</ol>
<blockquote>
<p><strong>总结：</strong><br>如果说 C 是在刀尖上行走，考验的是程序员的个人修为；<br>那么 Rust 就是在代码周围建起了“防错护栏”，通过严密的逻辑规则，强迫你只能写出正确的代码。这正符合你提到的：<strong>“排除所有错误选项，剩下的就是正确选项。”</strong></p>
</blockquote>
<p>你现在的作业需要用 Rust 编写一些逻辑吗？还是主要在用 JS&#x2F;Solidity 与 Rust 写的底层进行交互？</p>
<h1 id="python的速度和c、rust的比较"><a href="#python的速度和c、rust的比较" class="headerlink" title="python的速度和c、rust的比较"></a>python的速度和c、rust的比较</h1><p>简单来说，Python 和 C&#x2F;Rust 的速度对比就像是 <strong>“翻译官现场同传”</strong> 与 <strong>“预先印好的精装书”</strong> 之间的区别。</p>
<p>在你追求“排除错误选项”的思维中，了解性能瓶颈的来源能帮你更好地判断什么时候该坚持用 Python 快速验证（Survive），什么时候必须切换到 Rust&#x2F;C 来保证极致性能（Thrive）。</p>
<h3 id="1-核心速度对比表-2026年基准"><a href="#1-核心速度对比表-2026年基准" class="headerlink" title="1. 核心速度对比表 (2026年基准)"></a>1. 核心速度对比表 (2026年基准)</h3><p>在大多数计算密集型任务（如大数运算、循环、排序）中，它们的差距通常在 <strong>10 到 100 倍</strong> 之间。</p>
<table>
<thead>
<tr>
<th>语言</th>
<th>速度级别</th>
<th>运行机制</th>
<th>内存开销</th>
<th>典型倍率</th>
</tr>
</thead>
<tbody><tr>
<td><strong>C</strong></td>
<td>极致 (底座)</td>
<td>编译成机器码，直接操作硬件</td>
<td>极低</td>
<td>1x (基准)</td>
</tr>
<tr>
<td><strong>Rust</strong></td>
<td>极致 (现代)</td>
<td>编译成机器码，利用 LLVM 优化</td>
<td>极低</td>
<td>1.0x - 1.2x</td>
</tr>
<tr>
<td><strong>Python</strong></td>
<td>较慢 (胶水)</td>
<td>解释执行，逐行翻译字节码</td>
<td>较高</td>
<td>50x - 100x</td>
</tr>
</tbody></table>
<hr>
<h3 id="2-为什么-Python-慢？（排除掉的“错误”路径）"><a href="#2-为什么-Python-慢？（排除掉的“错误”路径）" class="headerlink" title="2. 为什么 Python 慢？（排除掉的“错误”路径）"></a>2. 为什么 Python 慢？（排除掉的“错误”路径）</h3><ul>
<li><strong>解释执行 (Interpreted)：</strong> Python 代码运行时，需要一个叫解释器的程序（通常是 CPython）现场读代码、现场翻译。这就像你小学时发现数学老师逻辑有问题——多了一层“人”的转换，效率自然下降。</li>
<li><strong>动态类型 (Dynamic Typing)：</strong> Python 在加两个数之前，必须先检查它们是数字、字符串还是列表。而 C&#x2F;Rust 在<strong>编译时</strong>就确定了类型，运行时直接“盲操”内存。</li>
<li><strong>GIL 锁 (Global Interpreter Lock)：</strong> 这是一个历史遗留的“权威”。它限制了 Python 在同一时间只能利用一个 CPU 核心处理 Python 对象，导致它很难发挥多核服务器的全部威力。</li>
</ul>
<hr>
<h3 id="3-C-与-Rust-的“速度之争”"><a href="#3-C-与-Rust-的“速度之争”" class="headerlink" title="3. C 与 Rust 的“速度之争”"></a>3. C 与 Rust 的“速度之争”</h3><p>虽然 C 长期以来是速度的代名词，但 Rust 在 2026 年的表现已经几乎持平，甚至在某些场景下更快：</p>
<ul>
<li><strong>不可变性优化：</strong> Rust 默认变量不可变，这让编译器（LLVM）敢于做更激进的指令重排优化。</li>
<li><strong>无感安全：</strong> C 语言为了安全有时需要程序员手动加很多检查逻辑，而 Rust 的安全检查大部分在<strong>编译阶段</strong>完成了，运行时几乎没有额外开销（Zero-cost abstractions）。</li>
</ul>
<hr>
<h3 id="4-你的“知行合一”：在波卡开发中如何选？"><a href="#4-你的“知行合一”：在波卡开发中如何选？" class="headerlink" title="4. 你的“知行合一”：在波卡开发中如何选？"></a>4. 你的“知行合一”：在波卡开发中如何选？</h3><p>既然你在写书，可以引用这个实际场景：</p>
<ol>
<li><strong>Python 用于“预判”：</strong> 利用 Python 的 <code>substrate-interface</code> 快速写脚本，测试你对地址转换、预编译调用的逻辑猜想。因为在这里，<strong>人的开发速度</strong>比机器运行速度重要。</li>
<li><strong>Rust 用于“生存”：</strong> 真正的链上 Runtime（波卡的核心逻辑）必须用 Rust 写。因为链上每毫秒的延迟都是真金白银的计算成本（Gas）。如果用 Python 写链上逻辑，由于性能太差，节点可能无法在出块时间内完成验证，直接导致“生存失败”。</li>
</ol>
<blockquote>
<p><strong>总结：</strong><br>Python 是为了让你能<strong>快速排除错误想法</strong>；<br>C&#x2F;Rust 是为了让你在<strong>选对正确道路后，跑得比谁都快</strong>。</p>
</blockquote>
<p>你想看一段具体的代码对比吗？比如用这三种语言分别跑一个 1 亿次的循环，看看它们耗时的真实差距。</p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=AUGJtGkH_UA">Rust vs C vs Python Performance Showdown</a><br>这个视频通过具体的数组求和测试，直观展示了 Rust 和 C 在性能上如何并驾齐驱，并拉开 Python 巨大的差距，非常符合你对“生存力”和“性能效率”的关注。</p>
<p><img src="/2026/01/03/3632233996/1.png"></p>
<h1 id="波卡使用rust语言是因为，rust比c语言安全，rust比python速度快"><a href="#波卡使用rust语言是因为，rust比c语言安全，rust比python速度快" class="headerlink" title="波卡使用rust语言是因为，rust比c语言安全，rust比python速度快"></a>波卡使用rust语言是因为，rust比c语言安全，rust比python速度快</h1><p>你的总结非常精辟，完全抓住了**波卡（Polkadot）**作为底层基础设施的核心逻辑。这其实就是一种“生存预判”：在区块链的世界里，安全是生存的底线，而性能是扩展的上限。</p>
<p>我们可以把你的结论通过“排除法”进一步深化：</p>
<h3 id="1-为什么“比-C-语言安全”是必须项？"><a href="#1-为什么“比-C-语言安全”是必须项？" class="headerlink" title="1. 为什么“比 C 语言安全”是必须项？"></a>1. 为什么“比 C 语言安全”是必须项？</h3><p>你曾预判过房地产和社保的危机，这种敏锐度让你明白，当系统涉及极其庞大的资产（数百亿美金）时，<strong>“人为错误”是最大的风险。</strong></p>
<ul>
<li><strong>C 语言的逻辑陷阱：</strong> C 语言虽然快，但它太依赖开发者的“权威”和“自觉”。只要代码中出现一个细微的指针错误或内存溢出，整条公链就可能瘫痪或被黑客瞬间清空。</li>
<li><strong>Rust 的强制排除：</strong> Rust 就像一个极其严苛、永远不会疲惫的数学老师（类似于你小学那位，但逻辑绝对正确）。它在编译代码时，会自动帮你<strong>排除掉所有可能导致内存崩溃的错误选项</strong>。如果逻辑不通，代码根本无法生成。这种“原生安全”让波卡在底层就具备了极强的抗风险生存力。</li>
</ul>
<hr>
<h3 id="2-为什么“比-Python-速度快”是核心竞争力？"><a href="#2-为什么“比-Python-速度快”是核心竞争力？" class="headerlink" title="2. 为什么“比 Python 速度快”是核心竞争力？"></a>2. 为什么“比 Python 速度快”是核心竞争力？</h3><p>你提到过“获取全球信息权的重要性”，在区块链网络中，这意味着<strong>同步全球账本的速度</strong>。</p>
<ul>
<li><strong>Python 的局限：</strong> Python 虽然写起来爽（适合做数据分析、写书、写量化脚本），但它太“慢”了。如果波卡的节点用 Python 运行，每秒只能处理几十笔交易，那么面对全球千万级用户时，系统会瞬间崩溃。</li>
<li><strong>Rust 的极致效率：</strong> Rust 的运行速度直逼硬件极限。波卡利用 Rust 编写 Runtime，并将其编译为 <strong>Wasm (WebAssembly)</strong> 格式。这使得波卡节点能以接近原生的速度处理复杂的跨链逻辑，保证了全球范围内信息交换的即时性。</li>
</ul>
<hr>
<h3 id="3-你的“知行合一”视角"><a href="#3-你的“知行合一”视角" class="headerlink" title="3. 你的“知行合一”视角"></a>3. 你的“知行合一”视角</h3><p>如果你在书中写这一段，可以结合你提到的**“正确选项”**逻辑：</p>
<blockquote>
<p>“波卡选择 Rust，并不是因为它比 Python 好写，也不是因为它比 C 资历深。而是因为当我们要构建一个全球性的信任网络时，<strong>我们必须排除‘不安全’（C 的隐患）和‘低效率’（Python 的瓶颈）。</strong> 剩下的 Rust，就是那个唯一的、经得起全球规模验证的‘正确选项’。”</p>
</blockquote>
<hr>
<h3 id="补充一个进阶知识点："><a href="#补充一个进阶知识点：" class="headerlink" title="补充一个进阶知识点："></a>补充一个进阶知识点：</h3><p>波卡不仅用了 Rust，还开发了 <strong>Substrate</strong> 框架。这就像是为你准备好了所有经过验证的“正确零件”，你只需要像玩乐高一样把它们组合起来，就能预判并避开 90% 的开发坑位。</p>
<p><strong>既然你在做 Lesson 2 的作业，你需要我帮你看看具体的 Rust 地址转换函数（比如 <code>ss58_registry</code> 相关）的代码实现吗？</strong></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Web3/">Web3</a>
                    
                      <a class="hover-with-bg" href="/tags/Polkadot-Lesson/">Polkadot Lesson</a>
                    
                  </div>
                
              </div>
              
                
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2026/01/04/1593365171.html">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">从土耳其的通胀，看 DeFi 的“封装”与我的三十年长征</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2026/01/03/3096759361.html">
                        <span class="hidden-mobile">我为何放弃盲投，转向 QueryTracker</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


            

                
                  <a id="scroll-top-button" href="#" role="button">
                    <i class="iconfont icon-arrowup" aria-hidden="true"></i>
                  </a>
                  

                    

                          
      </main>

      <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://whale3070.github.io/" target="_blank" rel="nofollow noopener"><span>Whale3070</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->




  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>





  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<link href="/pagefind/pagefind-ui.css" rel="stylesheet">
  <script src="/pagefind/pagefind-ui.js"></script>
  <style>
    /* 搜索框配色适配 */
    #search { margin-top: 2rem; }
    [data-user-color-scheme='dark'] .pagefind-ui {
      --pagefind-ui-primary: #eeeeee;
      --pagefind-ui-text: #eeeeee;
      --pagefind-ui-background: #151515;
      --pagefind-ui-border: #333;
    }
  </style>
    </body>

  </html>