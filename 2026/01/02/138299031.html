

  <!DOCTYPE html>
  <html lang="zh-CN" data-default-color-scheme=&#34;dark&#34; >
  <style>
    .text1
    {
    text-shadow: 0px 0px 2px #f2f3f2;
    }
    </style>

  <script>
    // 强制内网 IP 识别为安全上下文
    if (window.location.hostname !== 'localhost' && window.location.protocol === 'http:') {
        // 尝试手动映射 crypto 属性
        if (!window.crypto.subtle && window.crypto.webkitSubtle) {
            window.crypto.subtle = window.crypto.webkitSubtle;
        }
    }
    
    // 终极补丁：如果还是没有 subtle，则创建一个占位符避免报错
    // 提示：这通常能解决加载报错，但如果插件强依赖原生加密，建议执行下面的“降级”预判
    if (!window.isSecureContext) {
        console.warn('当前环境非安全上下文，正在尝试兼容内网加密解密...');
    }
</script>


<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/null">
  <link rel="icon" type="image/png" href="/null">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>Polkadot Solidity开发-课程笔记4 - whale3070&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.4.0/styles/github-gist.min.css" />
    
  

  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"whale3070.github.io","root":"/","version":"1.8.7","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":false,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 7.3.0"></head>


    <body>
      <header style="height: 70vh;">
        <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>InfoSec learning</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/search/">
                <i class="iconfont icon-search"></i>
                搜索
              </a>
            </li>
          
        
        
        
          
        
      </ul>
    </div>
  </div>
</nav>

          <div class="banner" id="banner" false
            style="background: url('/img/default.png') no-repeat center center;
              background-size: cover;">
              <div class="full-bg-img">
                <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
                  <div class="page-header text-center fade-in-up">
                    <span class="h2 text1" id="subtitle" title="Polkadot Solidity开发-课程笔记4">
                      
                        Polkadot Solidity开发-课程笔记4
                      
                    </span>
        
                    
                      <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2026-01-02 02:25" pubdate>
        2026年1月2日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      5.8k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      70
       分钟
    </span>
  

  
  
</div>

                    
                  </div>
                    
                  </div>
                  
                </div>
              </div>
          </div>
      </header>

      <main>
        
          

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" data-pagefind-body>
            <!-- SEO header -->
            <h1 style="display: none">Polkadot Solidity开发-课程笔记4</h1>
            
            <div class="markdown-body">
              <h1 id="问题E"><a href="#问题E" class="headerlink" title="问题E"></a>问题E</h1><p>WebAssembly 是二进制文件，java也需要编译。那么这两个二进制文件又有什么不同</p>
<p>你想知道 WebAssembly（Wasm）二进制文件与 Java 编译生成的二进制文件的核心差异，二者虽同为二进制格式，但在<strong>本质类型、执行模型、跨平台逻辑</strong>等方面存在根本性区别，我们从关键维度详细拆解：</p>
<h3 id="一、先明确两者的「二进制文件」具体所指"><a href="#一、先明确两者的「二进制文件」具体所指" class="headerlink" title="一、先明确两者的「二进制文件」具体所指"></a>一、先明确两者的「二进制文件」具体所指</h3><p>首先要厘清两个核心概念，避免混淆：</p>
<ol>
<li><strong>Java 对应的二进制文件</strong>：Java 源代码（.java）编译后生成的是 <strong>Java 字节码文件（.class 格式，本质是二进制文件）</strong>；若打包为可分发格式，通常是 JAR 包（本质是 .class 文件的压缩归档，核心仍是 .class 字节码）。</li>
<li><strong>WebAssembly 对应的二进制文件</strong>：通常指 .wasm 格式文件，是 Wasm 标准定义的二进制字节码格式（也有对应的文本格式 .wat，可转换为 .wasm）。</li>
</ol>
<h3 id="二、核心本质与设计目标差异（最根本区别）"><a href="#二、核心本质与设计目标差异（最根本区别）" class="headerlink" title="二、核心本质与设计目标差异（最根本区别）"></a>二、核心本质与设计目标差异（最根本区别）</h3><ol>
<li><p><strong>Java 字节码（.class）</strong><br>它是<strong>专门为 Java 虚拟机（JVM）设计的专属字节码</strong>，核心设计目标是「支撑 Java 语言的跨平台运行+面向对象特性落地」，仅与 JVM 生态强绑定。它高度贴合 Java 语言的特性（如面向对象、垃圾回收、异常处理等），无法脱离 JVM 生态的设计逻辑独立使用。</p>
</li>
<li><p><strong>Wasm 二进制文件（.wasm）</strong><br>它是<strong>通用型、无语言绑定的抽象虚拟机字节码</strong>，核心设计目标是「高性能跨平台执行+多语言兼容+安全沙箱」，并非为某一种语言量身定制。它的设计更偏向底层，接近硬件指令集但又脱离具体硬件架构，可作为 C&#x2F;C++、Rust、Java、Go 等多种语言的编译目标。</p>
</li>
</ol>
<h3 id="三、执行方式与依赖环境的差异"><a href="#三、执行方式与依赖环境的差异" class="headerlink" title="三、执行方式与依赖环境的差异"></a>三、执行方式与依赖环境的差异</h3><ol>
<li><p><strong>Java 字节码（.class）的执行方式</strong><br>依赖 <strong>Java 虚拟机（JVM）</strong> 作为唯一执行载体，执行流程分为两种（主流为混合模式）：</p>
<ul>
<li>解释执行：JVM 中的解释器（如 HotSpot 解释器）逐行解析 .class 字节码，转换为当前 CPU 可识别的原生机器码后执行；</li>
<li>即时编译（JIT）：JVM 中的 JIT 编译器（如 HotSpot 的 C1&#x2F;C2 编译器）会将频繁执行的「热点代码」（如循环、高频调用方法）一次性编译为原生机器码，缓存后重复执行，兼顾启动速度和运行性能；<br>补充：Java 还有 AOT 编译（如 GraalVM Native Image），可直接将 .class&#x2F;JAR 编译为原生 bin 文件，但这是额外编译流程，非 .class 字节码的原生执行方式。</li>
</ul>
</li>
<li><p><strong>Wasm 二进制文件（.wasm）的执行方式</strong><br>依赖 <strong>Wasm 运行时环境</strong>（非专属虚拟机，种类更多样），执行流程同样有两种：</p>
<ul>
<li>解释执行：Wasm 运行时（如浏览器内置运行时、wasmtime、wasmer）逐行解析 .wasm 字节码，转换为原生机器码执行；</li>
<li>即时编译（JIT）：主流 Wasm 运行时（如 Chrome&#x2F;V8 内置运行时、Wasmer）优先采用 JIT 编译，将 .wasm 字节码一次性编译为当前架构的原生机器码后执行，性能接近原生程序；<br>补充：Wasm 也支持 AOT 编译（如 wasmtime compile 命令），提前将 .wasm 编译为原生 bin 文件，进一步提升启动速度。<br>关键差异：Wasm 运行时更轻量、更通用，不绑定特定语言；JVM 是重量级专属虚拟机，深度耦合 Java 生态。</li>
</ul>
</li>
</ol>
<h3 id="四、跨平台特性的实现逻辑差异"><a href="#四、跨平台特性的实现逻辑差异" class="headerlink" title="四、跨平台特性的实现逻辑差异"></a>四、跨平台特性的实现逻辑差异</h3><p>两者均具备跨平台能力，但实现逻辑和灵活度不同：</p>
<ol>
<li><p><strong>Java 字节码：「一次编写，到处编译」→「一次编译，到处运行」</strong></p>
<ul>
<li>第一步：Java 源代码编译为 .class 字节码（与硬件&#x2F;系统无关），这一步是「一次编译」；</li>
<li>第二步：不同平台（Windows&#x2F;Linux&#x2F;macOS）需安装<strong>对应架构的 JVM 版本</strong>（如 x86_64 Windows JVM、aarch64 Linux JVM），由 JVM 处理与本地系统的适配，实现「到处运行」；</li>
<li>局限性：跨平台的前提是目标平台有对应的 JVM 实现，且 JVM 版本需兼容字节码版本，无法在无 JVM 环境（如轻量级嵌入式设备）中运行。</li>
</ul>
</li>
<li><p><strong>Wasm 二进制文件：「一次编译，到处运行」（更彻底的跨平台）</strong></p>
<ul>
<li>第一步：任意支持 Wasm 的语言（C&#x2F;C++&#x2F;Rust&#x2F;Java 等）编译为 .wasm 二进制文件（与硬件&#x2F;系统完全无关，遵循 Wasm 统一标准）；</li>
<li>第二步：只要目标环境有<strong>兼容 Wasm 标准的运行时</strong>（无需针对语言定制），同一个 .wasm 文件即可无缝运行；</li>
<li>优势：Wasm 运行时更轻量化、适配范围更广（浏览器、服务器、嵌入式设备、云原生环境等均有支持），无需为不同平台定制 Wasm 文件，跨平台灵活性远超 Java 字节码。</li>
</ul>
</li>
</ol>
<h3 id="五、其他关键差异补充"><a href="#五、其他关键差异补充" class="headerlink" title="五、其他关键差异补充"></a>五、其他关键差异补充</h3><table>
<thead>
<tr>
<th>对比维度</th>
<th>Java 字节码（.class&#x2F;JAR）</th>
<th>Wasm 二进制文件（.wasm）</th>
</tr>
</thead>
<tbody><tr>
<td>语言绑定性</td>
<td>强绑定 Java 生态（仅适配 Java&#x2F;Kotlin 等 JVM 语言）</td>
<td>无语言绑定（支持 C&#x2F;C++&#x2F;Rust&#x2F;Java&#x2F;Go 等多语言）</td>
</tr>
<tr>
<td>运行时重量</td>
<td>重量级（JVM 包含类加载、垃圾回收、线程管理等复杂模块）</td>
<td>轻量级（Wasm 运行时核心功能精简，资源占用低）</td>
</tr>
<tr>
<td>安全模型</td>
<td>基于 JVM 沙箱（依赖类加载器、安全管理器等）</td>
<td>基于 Wasm 原生沙箱（内存隔离、指令安全校验，更底层更严格）</td>
</tr>
<tr>
<td>性能表现</td>
<td>JIT 编译后性能较好，但 JVM 启动开销大</td>
<td>JIT&#x2F;AOT 编译后性能接近原生机器码，启动开销小</td>
</tr>
<tr>
<td>系统交互能力</td>
<td>需通过 JNI&#x2F;JNA 间接调用本地系统接口（复杂）</td>
<td>可通过 WASI（Wasm 系统接口）或宿主API直接交互（简洁通用）</td>
</tr>
<tr>
<td>主要用途</td>
<td>后端服务、桌面应用、Android 应用（早期）等</td>
<td>浏览器前端、跨平台应用、云原生、嵌入式、插件系统等</td>
</tr>
</tbody></table>
<h3 id="六、补充说明：Java-也可编译为-Wasm-文件"><a href="#六、补充说明：Java-也可编译为-Wasm-文件" class="headerlink" title="六、补充说明：Java 也可编译为 Wasm 文件"></a>六、补充说明：Java 也可编译为 Wasm 文件</h3><p>需要注意的是，Java 代码不仅能编译为 .class 字节码，也可通过特定工具链（如 Teavm、GraalVM）编译为 Wasm 二进制文件，这进一步说明：</p>
<ul>
<li>差异的核心不是「编程语言（Java）」，而是「编译目标格式（.class vs .wasm）」和「执行生态（JVM vs Wasm 运行时）」；</li>
<li>这种转换本质是将 Java 代码的逻辑映射到 Wasm 字节码中，脱离了 JVM 依赖，获得了更广泛的跨平台能力。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>本质差异：Java .class 是 JVM 专属字节码（绑定 Java 生态），Wasm .wasm 是通用型跨语言字节码（无语言绑定）；</li>
<li>执行差异：Java 依赖重量级 JVM 执行，Wasm 依赖轻量级通用运行时执行；</li>
<li>跨平台差异：Java 跨平台依赖对应平台的 JVM，Wasm 跨平台依赖通用 Wasm 运行时（更彻底、更灵活）；</li>
<li>其他差异：Java 字节码语言绑定强、启动开销大；Wasm 字节码多语言兼容、性能接近原生、资源占用低。</li>
</ol>
<h1 id="问题F"><a href="#问题F" class="headerlink" title="问题F"></a>问题F</h1><p>它的设计更偏向底层，接近硬件指令集但又脱离具体硬件架构，可作为 C&#x2F;C++、Rust、Java、Go 等多种语言的编译目标。你的意思是C&#x2F;C++、Rust、Java、Go 可以编译为WebAssembly的意思吗</p>
<hr>
<p>是的，我的意思正是：<strong>C&#x2F;C++、Rust、Java、Go 等主流编程语言，都可以通过对应的工具链&#x2F;编译器，将自身源代码编译为 WebAssembly（.wasm 格式）的二进制字节码</strong>。</p>
<p>下面针对这几种语言，补充具体的编译可行性和核心工具链，让你更清晰地理解这种跨语言编译能力：</p>
<h3 id="1-Rust：对-Wasm-支持最原生、最完善"><a href="#1-Rust：对-Wasm-支持最原生、最完善" class="headerlink" title="1.  Rust：对 Wasm 支持最原生、最完善"></a>1.  Rust：对 Wasm 支持最原生、最完善</h3><p>Rust 生态对 WebAssembly 的支持是一等公民级别，无需额外第三方工具链，通过官方 <code>rustup</code> 即可实现编译：</p>
<ul>
<li>先添加 Wasm 编译目标（你之前提到的命令）：<code>rustup target add wasm32-unknown-unknown</code></li>
<li>编译命令：<code>cargo build --target wasm32-unknown-unknown --release</code></li>
<li>编译后会在 <code>target/wasm32-unknown-unknown/release/</code> 目录下生成 .wasm 文件，支持直接在 Wasm 运行时中执行。</li>
</ul>
<h3 id="2-C-C-：通过成熟工具链实现编译"><a href="#2-C-C-：通过成熟工具链实现编译" class="headerlink" title="2.  C&#x2F;C++：通过成熟工具链实现编译"></a>2.  C&#x2F;C++：通过成熟工具链实现编译</h3><p>C&#x2F;C++ 编译为 Wasm 的核心工具是 <strong>Emscripten</strong>（基于 LLVM 构建的专用工具链），这是目前 C&#x2F;C++ 转 Wasm 的事实标准：</p>
<ul>
<li>核心命令示例：<ol>
<li>编译为独立 .wasm 文件：<code>emcc hello.c -o hello.wasm</code></li>
<li>编译为可在浏览器中直接运行的（包含 HTML 载体）：<code>emcc hello.c -o hello.html</code></li>
</ol>
</li>
<li>支持绝大多数 C&#x2F;C++ 标准库和自定义代码，广泛用于将传统 C&#x2F;C++ 项目（如图像处理、游戏引擎）迁移到浏览器或跨平台环境。</li>
</ul>
<h3 id="3-Go：官方原生支持-Wasm-编译"><a href="#3-Go：官方原生支持-Wasm-编译" class="headerlink" title="3.  Go：官方原生支持 Wasm 编译"></a>3.  Go：官方原生支持 Wasm 编译</h3><p>Go 语言从 1.11 版本开始，官方原生支持将 Go 代码编译为 Wasm 格式，无需额外安装第三方工具：</p>
<ul>
<li>编译命令（指定 Wasm 目标架构）：<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># Linux/macOS 环境</span><br>GOOS=js GOARCH=wasm go build -o hello.wasm hello.go<br><br><span class="hljs-comment"># Windows 环境（cmd 终端）</span><br><span class="hljs-built_in">set</span> GOOS=js&amp;&amp;<span class="hljs-built_in">set</span> GOARCH=wasm&amp;&amp;go build -o hello.wasm hello.go<br></code></pre></div></td></tr></table></figure></li>
<li>编译后的 .wasm 文件可在浏览器或 Go 提供的 Wasm 运行时中执行，适合将 Go 后端服务逻辑迁移到前端或轻量级跨平台场景。</li>
</ul>
<h3 id="4-Java：通过中转工具链实现编译"><a href="#4-Java：通过中转工具链实现编译" class="headerlink" title="4.  Java：通过中转工具链实现编译"></a>4.  Java：通过中转工具链实现编译</h3><p>Java 无法直接通过 JDK 编译为 Wasm，但可通过 <strong>第三方工具链</strong> 实现转换，核心方案有两种：</p>
<ul>
<li>方案 1：TeaVM（轻量级 Java 到 Wasm&#x2F;JS 编译器），无需依赖 JVM，直接将 Java 字节码转换为 Wasm 字节码，命令简单、体积小巧；</li>
<li>方案 2：GraalVM（Oracle 推出的高性能多语言虚拟机），支持将 Java 代码先转换为 Graal 中间码，再编译为 Wasm 格式，适合复杂 Java 项目的迁移；</li>
<li>补充：这种编译本质是脱离了 JVM 生态，将 Java 代码逻辑映射到 Wasm 字节码中，获得 Wasm 的跨平台特性。</li>
</ul>
<h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><p>除了上述几种语言，Python、C#、Swift 等主流编程语言也都有对应的工具链支持编译为 Wasm 格式。这正是 Wasm 「通用型、无语言绑定」设计的核心体现——它不局限于某一种编程语言，而是作为一个统一的「跨语言执行载体」，让不同语言编写的代码，都能通过编译转换，在任意支持 Wasm 标准的运行时中无缝执行。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol>
<li>你的理解完全正确：C&#x2F;C++、Rust、Java、Go 均可编译为 WebAssembly 二进制文件；</li>
<li>支持程度有差异：Rust（原生最优）&gt; C&#x2F;C++（工具链成熟）&gt; Go（官方原生支持）&gt; Java（第三方工具链中转）；</li>
<li>核心共性：无论哪种语言，编译后的 .wasm 文件均遵循 Wasm 统一标准，具备跨平台、沙箱安全、接近原生性能的特性。</li>
</ol>
<h1 id="问题G-这个ts文件是什么意思"><a href="#问题G-这个ts文件是什么意思" class="headerlink" title="问题G: 这个ts文件是什么意思"></a>问题G: 这个ts文件是什么意思</h1><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; ethers &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;ethers&quot;</span>;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// faucet https://faucet.polkadot.io/ Paseo AssetHub</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">URL</span> = <span class="hljs-string">&quot;https://services.polkadothub-rpc.com/testnet&quot;</span>;<br>    <span class="hljs-keyword">const</span> provider = <span class="hljs-keyword">new</span> ethers.<span class="hljs-title class_">JsonRpcProvider</span>(<span class="hljs-variable constant_">URL</span>);<br>    <span class="hljs-keyword">const</span> address = <span class="hljs-string">&quot;0x&quot;</span>; <span class="hljs-comment">// put your address here</span><br>    <span class="hljs-keyword">const</span> balance = <span class="hljs-keyword">await</span> provider.<span class="hljs-title function_">getBalance</span>(address);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Balance of <span class="hljs-subst">$&#123;address&#125;</span>: <span class="hljs-subst">$&#123;ethers.formatEther(balance)&#125;</span> ETH`</span>);<br>&#125;<br><br><span class="hljs-title function_">main</span>();<br></code></pre></div></td></tr></table></figure>

<p>这个 <code>.ts</code> 文件是一个非常简洁的 <strong>链上查询脚本</strong>。它的核心目的是：<strong>通过以太坊兼容的方式（EVM 逻辑），去查询波卡测试网（Paseo AssetHub）上的账户余额。</strong></p>
<p>有趣的是，这段代码并没有使用波卡原生的 <code>Polkadot.js</code> 库，而是用了以太坊开发者最熟悉的 <code>ethers.js</code>。这反映了波卡生态目前的一个重要趋势：<strong>完全兼容以太坊的开发体验。</strong></p>
<hr>
<h3 id="逐行逻辑拆解（你可以直接写进复盘笔记）"><a href="#逐行逻辑拆解（你可以直接写进复盘笔记）" class="headerlink" title="逐行逻辑拆解（你可以直接写进复盘笔记）"></a>逐行逻辑拆解（你可以直接写进复盘笔记）</h3><ol>
<li><strong><code>import &#123; ethers &#125; from &quot;ethers&quot;;</code></strong></li>
</ol>
<ul>
<li><strong>含义</strong>：导入以太坊开发中最常用的工具库。</li>
<li><strong>底层逻辑</strong>：虽然这是波卡网络，但因为它支持以太坊虚拟机（EVM），所以我们可以用以太坊的工具来和它对话。</li>
</ul>
<ol start="2">
<li><strong><code>const URL = &quot;https://services.polkadothub-rpc.com/testnet&quot;;</code></strong></li>
</ol>
<ul>
<li><strong>含义</strong>：设置 RPC 节点地址。</li>
<li><strong>预判点</strong>：这就像是一个“翻译官”的电话号码。你的程序通过这个地址，把请求发给波卡的测试网（Paseo AssetHub）。</li>
</ul>
<ol start="3">
<li><strong><code>const provider = new ethers.JsonRpcProvider(URL);</code></strong></li>
</ol>
<ul>
<li><strong>含义</strong>：创建一个“连接器”。</li>
<li><strong>作用</strong>：建立起你的本地代码与远程区块链之间的通信链路。</li>
</ul>
<ol start="4">
<li><strong><code>const balance = await provider.getBalance(address);</code></strong></li>
</ol>
<ul>
<li><strong>含义</strong>：向链上查询指定地址的余额。</li>
<li><strong>注意</strong>：这里的 <code>await</code> 体现了异步操作。因为查询链上数据需要跨越网络，必须等待反馈。</li>
</ul>
<ol start="5">
<li><strong><code>console.log(... ethers.formatEther(balance) ...);</code></strong></li>
</ol>
<ul>
<li><strong>含义</strong>：单位转换并打印。</li>
<li><strong>底层细节</strong>：区块链底层存储余额通常是用很长的一串整数（单位是 Wei）。<code>formatEther</code> 的作用是将其除以 ，转换成人类可读的数字格式（虽然输出写的是 ETH，但实际上在 Paseo 网里是对应的测试币）。</li>
</ul>
<hr>
<h3 id="为什么这个脚本在钱包中“运行”不起来？"><a href="#为什么这个脚本在钱包中“运行”不起来？" class="headerlink" title="为什么这个脚本在钱包中“运行”不起来？"></a>为什么这个脚本在钱包中“运行”不起来？</h3><p>你之前问“如何在钱包中运行”，看到这段代码就更清晰了：</p>
<ul>
<li><strong>这是一个独立的后端&#x2F;脚本逻辑</strong>：它只需要一个 <code>address</code>（字符串）。它不需要钱包插件提供私钥，因为它只是在<strong>查询（Read）<strong>公开的账本信息，而不是在</strong>发起交易（Write）</strong>。</li>
<li><strong>运行环境</strong>：它应该在你的终端（Terminal）里运行。</li>
</ul>
<hr>
<h3 id="你的深度复盘可以切入的两个点："><a href="#你的深度复盘可以切入的两个点：" class="headerlink" title="你的深度复盘可以切入的两个点："></a>你的深度复盘可以切入的两个点：</h3><h4 id="1-异构链的兼容性逻辑"><a href="#1-异构链的兼容性逻辑" class="headerlink" title="1. 异构链的兼容性逻辑"></a>1. 异构链的兼容性逻辑</h4><p>你可以思考并记录：<strong>为什么波卡的余额可以用以太坊的库（ethers）来查？</strong><br>因为 Paseo AssetHub 开启了以太坊兼容层。这意味着波卡在底层是 Substrate 架构，但它向外暴露了一套符合以太坊标准的 JSON-RPC 接口。</p>
<h4 id="2-“预判”领水是否成功"><a href="#2-“预判”领水是否成功" class="headerlink" title="2. “预判”领水是否成功"></a>2. “预判”领水是否成功</h4><p>代码注释里提到了 <code>faucet.polkadot.io</code>。</p>
<ul>
<li>如果你运行这个脚本输出是 <code>0.0</code>，说明领水还没到账或地址填错。</li>
<li>如果你领水成功，脚本会输出大于 0 的数字。</li>
</ul>
<hr>
<h3 id="接下来怎么操作？"><a href="#接下来怎么操作？" class="headerlink" title="接下来怎么操作？"></a>接下来怎么操作？</h3><ol>
<li><strong>填入地址</strong>：把你钱包里的以太坊格式地址（<code>0x</code> 开头的）填入 <code>const address = &quot;0x...&quot;;</code>。</li>
<li><strong>安装 ethers</strong>：在终端运行 <code>npm install ethers</code>。</li>
<li><strong>执行</strong>：运行 <code>npx ts-node 你的文件名.ts</code>。</li>
</ol>
<p><strong>如果你运行报错，大概率是因为网络连接问题（毕竟是海外 RPC）。你想让我帮你写一个“增强版”，增加自动重试和错误捕获逻辑，让你的复盘笔记更专业吗？</strong></p>
<h1 id="问题H"><a href="#问题H" class="headerlink" title="问题H"></a>问题H</h1><p>PAS testnet是什么，为什么我输入subwallet的波卡钱包dot地址以后，报错了：└─# npx ts-node src&#x2F;index.ts<br>Balance of 0x3d4b60F1B863D48fF401e524F1bdeF8A16c9d71d: 0.0 ETH<br>                                                                                                                                                                   <br>┌──(root㉿kali)-[&#x2F;home&#x2F;…&#x2F;Desktop&#x2F;2026-h1-building-production-grade-dApps&#x2F;course&#x2F;lesson-1]<br>└─# mousepad src&#x2F;index.ts   <br>                                                                                                                                                                   <br>┌──(root㉿kali)-[&#x2F;home&#x2F;…&#x2F;Desktop&#x2F;2026-h1-building-production-grade-dApps&#x2F;course&#x2F;lesson-1]<br>└─# npx ts-node src&#x2F;index.ts<br>&#x2F;home&#x2F;kali&#x2F;Desktop&#x2F;2026-h1-building-production-grade-dApps&#x2F;course&#x2F;lesson-1&#x2F;node_modules&#x2F;ethers&#x2F;src.ts&#x2F;utils&#x2F;errors.ts:698<br>            error &#x3D; new Error(message);<br>                    ^<br>Error: network does not support ENS (operation&#x3D;”getEnsAddress”, info&#x3D;{ “network”: { “chainId”: “420420417”, “name”: “unknown” } }, code&#x3D;UNSUPPORTED_OPERATION, version&#x3D;6.16.0)<br>    at makeError (&#x2F;home&#x2F;kali&#x2F;Desktop&#x2F;2026-h1-building-production-grade-dApps&#x2F;course&#x2F;lesson-1&#x2F;node_modules&#x2F;ethers&#x2F;src.ts&#x2F;utils&#x2F;errors.ts:698:21)<br>    at assert (&#x2F;home&#x2F;kali&#x2F;Desktop&#x2F;2026-h1-building-production-grade-dApps&#x2F;course&#x2F;lesson-1&#x2F;node_modules&#x2F;ethers&#x2F;src.ts&#x2F;utils&#x2F;errors.ts:719:25)<br>    at Function.getEnsAddress (&#x2F;home&#x2F;kali&#x2F;Desktop&#x2F;2026-h1-building-production-grade-dApps&#x2F;course&#x2F;lesson-1&#x2F;node_modules&#x2F;ethers&#x2F;src.ts&#x2F;providers&#x2F;ens-resolver.ts:545:15)<br>    at processTicksAndRejections (node:internal&#x2F;process&#x2F;task_queues:105:5)<br>    at async Function.#getResolver (&#x2F;home&#x2F;kali&#x2F;Desktop&#x2F;2026-h1-building-production-grade-dApps&#x2F;course&#x2F;lesson-1&#x2F;node_modules&#x2F;ethers&#x2F;src.ts&#x2F;providers&#x2F;ens-resolver.ts:552:25)<br>    at async Function.fromName (&#x2F;home&#x2F;kali&#x2F;Desktop&#x2F;2026-h1-building-production-grade-dApps&#x2F;course&#x2F;lesson-1&#x2F;node_modules&#x2F;ethers&#x2F;src.ts&#x2F;providers&#x2F;ens-resolver.ts:590:26)<br>    at async JsonRpcProvider.getResolver (&#x2F;home&#x2F;kali&#x2F;Desktop&#x2F;2026-h1-building-production-grade-dApps&#x2F;course&#x2F;lesson-1&#x2F;node_modules&#x2F;ethers&#x2F;src.ts&#x2F;providers&#x2F;abstract-provider.ts:1193:16)<br>    at async JsonRpcProvider.resolveName (&#x2F;home&#x2F;kali&#x2F;Desktop&#x2F;2026-h1-building-production-grade-dApps&#x2F;course&#x2F;lesson-1&#x2F;node_modules&#x2F;ethers&#x2F;src.ts&#x2F;providers&#x2F;abstract-provider.ts:1203:26)<br>    at async checkAddress (&#x2F;home&#x2F;kali&#x2F;Desktop&#x2F;2026-h1-building-production-grade-dApps&#x2F;course&#x2F;lesson-1&#x2F;node_modules&#x2F;ethers&#x2F;src.ts&#x2F;address&#x2F;checks.ts:60:20)<br>    at async Promise.all (index 0) {<br>  code: ‘UNSUPPORTED_OPERATION’,<br>  operation: ‘getEnsAddress’,<br>  info: { network: Network {} },<br>  shortMessage: ‘network does not support ENS’</p>
<h2 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h2><p>从你的终端报错信息来看，你遇到了一个在 Web3 开发中非常典型的<strong>地址格式不匹配</strong>和<strong>网络协议冲突</strong>的问题。</p>
<p>简单来说：<strong>你正试图用以太坊（EVM）的工具去处理波卡（Substrate）的逻辑，但两者并不通用。</strong></p>
<hr>
<h3 id="1-什么是-PAS-Testnet？"><a href="#1-什么是-PAS-Testnet？" class="headerlink" title="1. 什么是 PAS Testnet？"></a>1. 什么是 PAS Testnet？</h3><p><strong>Paseo (PAS)</strong> 是波卡生态中目前最主要的<strong>社区驱动测试网</strong>。</p>
<ul>
<li><strong>地位</strong>：它取代了之前的 Westend，成为开发者部署平行链、测试智能合约的标准环境。</li>
<li><strong>代币</strong>：代币符号是 <strong>PAS</strong>。它没有真实价值，仅用于支付测试环境下的 Gas 费。</li>
<li><strong>特性</strong>：它是基于 <strong>Substrate</strong> 框架的，这意味着它默认使用的地址格式是 <strong>SS58</strong>（通常以 5 开头），而不是以太坊的 <code>0x</code> 格式。</li>
</ul>
<hr>
<h3 id="2-为什么你的报错提示-“network-does-not-support-ENS”？"><a href="#2-为什么你的报错提示-“network-does-not-support-ENS”？" class="headerlink" title="2. 为什么你的报错提示 “network does not support ENS”？"></a>2. 为什么你的报错提示 “network does not support ENS”？</h3><p>根据你运行的 <code>ts-node src/index.ts</code> 和报错堆栈：</p>
<ul>
<li><strong>底层冲突</strong>：你正在使用 <code>ethers.js</code> (version 6.16.0)。这是一个专为<strong>以太坊&#x2F;EVM</strong>设计的库。</li>
<li><strong>触发原因</strong>：你在代码中传入了一个字符串作为地址。<code>ethers</code> 尝试去解析这个字符串。如果它发现这个字符串不符合以太坊 <code>0x</code> 地址规范，它会<strong>误以为你输入的是一个 ENS 域名</strong>（比如 <code>whale3070.eth</code>），于是去调用 <code>getEnsAddress</code>。</li>
<li><strong>报错核心</strong>：因为 Paseo 测试网（Chain ID: 420420417）并不支持以太坊的 ENS 域名服务，所以程序崩溃并抛出 <code>UNSUPPORTED_OPERATION</code>。</li>
</ul>
<hr>
<h3 id="3-如何解决？"><a href="#3-如何解决？" class="headerlink" title="3. 如何解决？"></a>3. 如何解决？</h3><h4 id="方案-A：如果你在做波卡（Substrate）原生开发"><a href="#方案-A：如果你在做波卡（Substrate）原生开发" class="headerlink" title="方案 A：如果你在做波卡（Substrate）原生开发"></a>方案 A：如果你在做波卡（Substrate）原生开发</h4><p>如果你是在 <code>lesson-1</code> 学习如何与波卡平行链交互，你应该使用 <strong><code>@polkadot/api</code></strong> 而不是 <code>ethers.js</code>。</p>
<ul>
<li><strong>地址</strong>：使用 SubWallet 中以 <strong>5</strong> 开头的地址。</li>
<li><strong>库</strong>：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ApiPromise</span>, <span class="hljs-title class_">WsProvider</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@polkadot/api&#x27;</span>;<br><span class="hljs-comment">// ... 连接到 Paseo 节点的代码</span><br><br></code></pre></div></td></tr></table></figure>



<h4 id="方案-B：如果你在做-Frontier-EVM-开发（在波卡上跑以太坊合约）"><a href="#方案-B：如果你在做-Frontier-EVM-开发（在波卡上跑以太坊合约）" class="headerlink" title="方案 B：如果你在做 Frontier&#x2F;EVM 开发（在波卡上跑以太坊合约）"></a>方案 B：如果你在做 Frontier&#x2F;EVM 开发（在波卡上跑以太坊合约）</h4><p>你提到的 <code>parachain=1111</code> 可能是 <strong>Pop Network</strong> 或类似的 EVM 兼容链。</p>
<ul>
<li><strong>错误点</strong>：你在 SubWallet 里复制的是 <strong>Polkadot 格式</strong>地址，但代码需要 <strong>EVM 格式</strong>地址。</li>
<li><strong>解决办法</strong>：</li>
</ul>
<ol>
<li>打开 SubWallet。</li>
<li>找到你的 <strong>EVM 账户</strong>（地址以 <strong><code>0x</code></strong> 开头的那一个）。</li>
<li>在领水页面填入这个 <code>0x</code> 地址。</li>
<li>在代码 <code>src/index.ts</code> 中，确保传入的地址变量是这个 <code>0x</code> 字符串。</li>
</ol>
<hr>
<h3 id="4-深度洞察：关于你的“预判”习惯"><a href="#4-深度洞察：关于你的“预判”习惯" class="headerlink" title="4. 深度洞察：关于你的“预判”习惯"></a>4. 深度洞察：关于你的“预判”习惯</h3><p>Whale3070，你提到过你擅长从逻辑中排除错误选项。在这个案例中：</p>
<ol>
<li><strong>错误项 A</strong>：代码逻辑没问题，但<strong>库选错了</strong>（用 ethers 读 Substrate）。</li>
<li><strong>错误项 B</strong>：网络参数没问题，但<strong>地址解析协议不支持</strong>（EVM 不认 SS58 地址）。</li>
</ol>
<p><strong>接下来的建议：</strong><br>你现在的环境是 Kali Linux，正在学习 “Production-grade dApps”。这是一个硬核的开始。如果你能提供 <code>src/index.ts</code> 的前几行代码，我可以立刻帮你指出应该换成哪个库或者哪个地址变量。</p>
<p>你想让我帮你检查一下 <code>index.ts</code> 里的连接逻辑吗？</p>
<h1 id="优化cargo-install下载问题"><a href="#优化cargo-install下载问题" class="headerlink" title="优化cargo install下载问题"></a>优化cargo install下载问题</h1><p>这是因为在默认情况下，Rust 安装后并不会自动生成 <code>config.toml</code> 这个文件。在 Linux 中，如果文件夹或文件不存在，编辑器（如 Mousepad）往往无法直接保存或打开。</p>
<h3 id="直接写入镜像源（最快的方法）"><a href="#直接写入镜像源（最快的方法）" class="headerlink" title="直接写入镜像源（最快的方法）"></a>直接写入镜像源（最快的方法）</h3><p>不用手动打开编辑器了，直接运行下面这段命令，我会帮你把中科大（USTC）的镜像源注入进去：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> &lt;&lt;<span class="hljs-string">EOF &gt; ~/.cargo/config.toml</span><br><span class="hljs-string">[source.crates-io]</span><br><span class="hljs-string">replace-with = &#x27;ustc&#x27;</span><br><span class="hljs-string"></span><br><span class="hljs-string">[source.ustc]</span><br><span class="hljs-string">registry = &quot;https://mirrors.ustc.edu.cn/crates.io-index&quot;</span><br><span class="hljs-string"></span><br><span class="hljs-string">[net]</span><br><span class="hljs-string">git-fetch-with-cli = true</span><br><span class="hljs-string">EOF</span><br><br></code></pre></div></td></tr></table></figure>

<h3 id="第三步：重新安装"><a href="#第三步：重新安装" class="headerlink" title="第三步：重新安装"></a>第三步：重新安装</h3><p>配置好之后，再次运行安装命令，你会发现 <code>Updating crates.io index</code> 的速度有了质的飞跃：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">cargo install --force --locked cargo-contract -v<br><br></code></pre></div></td></tr></table></figure>

<hr>
<h3 id="💡-为什么我建议你加-git-fetch-with-cli-true？"><a href="#💡-为什么我建议你加-git-fetch-with-cli-true？" class="headerlink" title="💡 为什么我建议你加 git-fetch-with-cli = true？"></a>💡 为什么我建议你加 <code>git-fetch-with-cli = true</code>？</h3><p>作为一个有黑客松经验和生存力的人，你应该习惯在 Kali 下处理各种网络瓶颈。</p>
<ul>
<li><strong>原因</strong>：Cargo 默认使用内置的 <code>libgit2</code> 去拉取索引，在很多复杂的网络环境下（包括 Kali 这种渗透环境）很容易卡死。</li>
<li><strong>好处</strong>：强制 Cargo 使用系统的 <code>git</code> 命令去下载，配合镜像源，能极大地避开“卡在 Fetching”的问题。</li>
</ul>
<p><strong>你可以试试现在运行安装指令，如果还是卡在某个包下载不动，请告诉我。</strong></p>
<h1 id="问题I"><a href="#问题I" class="headerlink" title="问题I"></a>问题I</h1><p>cargo是什么意思</p>
<hr>
<p>简单来说，<strong>Cargo 是 Rust 语言的“管家”</strong>。</p>
<p>如果你把 Rust 比作一门手艺（比如木工），那么 Rust 编译器（<code>rustc</code>）就是那把锯子，而 <strong>Cargo 就是一整个现代化的木工车间和物流系统</strong>。</p>
<p>在 Rust 的世界里，你几乎不会直接去敲编译器命令，所有的操作（创建、编译、运行、管理依赖）都是通过 Cargo 完成的。</p>
<hr>
<h3 id="Cargo-的核心职责"><a href="#Cargo-的核心职责" class="headerlink" title="Cargo 的核心职责"></a>Cargo 的核心职责</h3><ol>
<li><strong>包管理器（Package Manager）</strong>：<br>就像 Node.js 的 <code>npm</code>、Python 的 <code>pip</code> 或者 Java 的 <code>Maven</code>。当你需要用别人的代码（在 Rust 里叫 <strong>Crate</strong>）时，只要在配置文件里写上名字，Cargo 就会自动帮你从官方仓库（crates.io）下载并配置好。</li>
<li><strong>构建系统（Build System）</strong>：<br>它负责把你的代码及其所有依赖项，按照正确的顺序编译成可执行文件或库。</li>
<li><strong>单元测试与文档</strong>：<br>Cargo 内置了测试工具和文档生成工具，输入 <code>cargo test</code> 就能跑测试，输入 <code>cargo doc</code> 就能生成漂亮的网页文档。</li>
</ol>
<hr>
<h3 id="Cargo-的常用命令（你的“求生工具包”）"><a href="#Cargo-的常用命令（你的“求生工具包”）" class="headerlink" title="Cargo 的常用命令（你的“求生工具包”）"></a>Cargo 的常用命令（你的“求生工具包”）</h3><p>既然你已经在 Kali 上折腾 <code>cargo-contract</code>，这几个命令是你以后写代码最常碰到的：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>用途</th>
<th>对应你的现状</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>cargo new &lt;name&gt;</code></strong></td>
<td>创建一个新项目</td>
<td>开启你的第一个 ink! 合约项目</td>
</tr>
<tr>
<td><strong><code>cargo build</code></strong></td>
<td>编译代码</td>
<td>把你的代码变成机器能懂的二进制</td>
</tr>
<tr>
<td><strong><code>cargo run</code></strong></td>
<td>编译并直接运行</td>
<td>快速看结果</td>
</tr>
<tr>
<td><strong><code>cargo install</code></strong></td>
<td>安装二进制工具</td>
<td>你刚才执行的 <code>cargo-contract</code> 就是这一步</td>
</tr>
<tr>
<td><strong><code>cargo check</code></strong></td>
<td>快速检查代码是否有错</td>
<td>不生成二进制，只看逻辑对不对（非常快）</td>
</tr>
</tbody></table>
<hr>
<h3 id="为什么-Cargo-对你很重要？"><a href="#为什么-Cargo-对你很重要？" class="headerlink" title="为什么 Cargo 对你很重要？"></a>为什么 Cargo 对你很重要？</h3><p>根据你之前的“预判”逻辑：</p>
<ul>
<li><strong>生存力体现</strong>：在黑客松或快速开发中，Cargo 极大地提高了生产力。它通过 <code>Cargo.lock</code> 文件确保了<strong>确定性</strong>（Deterministic build）——无论你在哪里编译，只要版本锁定了，结果就是一致的。</li>
<li><strong>知行合一</strong>：你刚才配置 <code>config.toml</code>，其实就是在修改这个“管家”的配置文件，让它从更近的仓库取东西。</li>
</ul>
<p><strong>现在你的 <code>cargo install</code> 应该已经进入编译（Compiling）阶段了吧？有没有看到一排绿色的提示？</strong></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Web3/">Web3</a>
                    
                      <a class="hover-with-bg" href="/tags/Polkadot-Lesson/">Polkadot Lesson</a>
                    
                  </div>
                
              </div>
              
                
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2026/01/02/1526244359.html">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">我的生平（三十六）</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2026/01/01/1526244358.html">
                        <span class="hidden-mobile">my-life其他大纲的草稿</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


            

                
                  <a id="scroll-top-button" href="#" role="button">
                    <i class="iconfont icon-arrowup" aria-hidden="true"></i>
                  </a>
                  

                    

                          
      </main>

      <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://whale3070.github.io/" target="_blank" rel="nofollow noopener"><span>Whale3070</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->




  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>





  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<link href="/pagefind/pagefind-ui.css" rel="stylesheet">
  <script src="/pagefind/pagefind-ui.js"></script>
  <style>
    /* 搜索框配色适配 */
    #search { margin-top: 2rem; }
    [data-user-color-scheme='dark'] .pagefind-ui {
      --pagefind-ui-primary: #eeeeee;
      --pagefind-ui-text: #eeeeee;
      --pagefind-ui-background: #151515;
      --pagefind-ui-border: #333;
    }
  </style>
    </body>

  </html>