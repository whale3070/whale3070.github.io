

  <!DOCTYPE html>
  <html lang="zh-CN" data-default-color-scheme=&#34;dark&#34; >
  <style>
    .text1
    {
    text-shadow: 0px 0px 2px #f2f3f2;
    }
    </style>

  

<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/null">
  <link rel="icon" type="image/png" href="/null">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>cryptozombies13 - whale3070&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"192.168.126.129","root":"/","version":"1.8.7","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 7.3.0"></head>


    <body>
      <header style="height: 70vh;">
        <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>InfoSec learning</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/search/">
                <i class="iconfont icon-search"></i>
                搜索
              </a>
            </li>
          
        
        
        
          
        
      </ul>
    </div>
  </div>
</nav>

          <div class="banner" id="banner" false
            style="background: url('/img/default.png') no-repeat center center;
              background-size: cover;">
              <div class="full-bg-img">
                <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
                  <div class="page-header text-center fade-in-up">
                    <span class="h2 text1" id="subtitle" title="cryptozombies13">
                      
                        cryptozombies13
                      
                    </span>
        
                    
                      <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2025-12-06 14:30" pubdate>
        2025年12月6日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      8.9k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      97
       分钟
    </span>
  

  
  
</div>

                    
                  </div>
                    
                  </div>
                  
                </div>
              </div>
          </div>
      </header>

      <main>
        
          

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" data-pagefind-body>
            <!-- SEO header -->
            <h1 style="display: none">cryptozombies13</h1>
            
            <div class="markdown-body">
              <p><a target="_blank" rel="noopener" href="https://cryptozombies.io/zh/lesson/19/chapter/1">https://cryptozombies.io/zh/lesson/19/chapter/1</a></p>
<p>你真是越来越令人印象深刻了，但如果我们要把现实世界及其所有变化、信息与我们心爱的“僵尸”（注：结合上下文可能指特定项目或代码中的“僵尸”相关模块）结合起来，情况会如何呢？</p>
<p>在本节课中，我们将深入探讨Chainlink（柴链）和预言机（Oracles）。</p>
<p>区块链预言机是连接智能合约、“僵尸”模块与现实世界数据及计算能力的工具，能获取的信息包括货币定价数据、随机数生成器数据，以及其他任何我们能想到的数据。区块链本身无法与外部世界交互，因为其设计初衷就是具有隔离性，且本质上是确定性的（注：“确定性”指区块链上的交易和计算结果在给定初始条件下唯一且可验证，不会因外部因素变化）。</p>
<p>那么，我们要做的是不是只要信任其中一个预言机，让它如实传递数据，一切就万事大吉了呢？</p>
<p>简单来说，答案是否定的。至少在形成社会共识信任，或你开发出去中心化版本的预言机之前，事情并非如此。你费尽心力在去中心化环境中构建智能合约，若从中心化预言机获取数据，之前的所有努力基本会付诸东流！这意味着，即便数据是你亲自上传的，它依然属于中心化范畴——因为你本人就是这个数据流程中的中心化节点。</p>
<p>当智能合约包含来自预言机的数据或计算能力时，这类合约被称为“混合智能合约”。目前许多最成功的去中心化应用（DApps），都整合了来自现实世界的外部数据。</p>
<p>准备好深入学习了吗？我们开始吧！</p>
<h1 id="补充说明（针对技术术语）"><a href="#补充说明（针对技术术语）" class="headerlink" title="补充说明（针对技术术语）"></a>补充说明（针对技术术语）</h1><ol>
<li><strong>Chainlink</strong>：区块链领域知名的去中心化预言机网络，中文常译“柴链”，核心功能是解决区块链与现实世界的数据交互问题，也是Web3开发中实现“混合智能合约”的关键工具。</li>
<li><strong>Oracles（预言机）</strong>：并非传统意义上的“预言”工具，而是区块链的“数据中介”，负责将链下（现实世界）数据转化为链上（区块链）智能合约可读取、可验证的格式，是连接区块链与外部系统的核心组件。</li>
<li><strong>Hybrid Smart Contracts（混合智能合约）</strong>：结合了区块链原生代码（处理链上逻辑，如资产转账）与外部数据/计算（通过预言机获取）的智能合约，相比纯链上合约更具灵活性，能支持去中心化金融（DeFi）、供应链溯源等需现实数据支撑的场景。</li>
</ol>
<h1 id="第1章：Chainlink数据馈送（Data-Feeds）介绍"><a href="#第1章：Chainlink数据馈送（Data-Feeds）介绍" class="headerlink" title="第1章：Chainlink数据馈送（Data Feeds）介绍"></a>第1章：Chainlink数据馈送（Data Feeds）介绍</h1><p>假设你正在开发一款去中心化金融（DeFi）应用（dapp），希望让用户能够提取价值特定美元金额的以太坊（ETH）。要实现这一需求，你的智能合约（为简化说明，下文统称其为“调用方合约”）必须知晓1个以太币对应的美元价值。</p>
<p>但问题在于：JavaScript应用程序可以轻松获取这类信息——只需向币安（Binance）公开API（或其他提供公开价格馈送的服务）发起请求即可。然而，智能合约无法直接访问外部世界的数据。</p>
<p>或许你会想，那我们自己开发一个JavaScript应用程序不就行了？但这样做会引入中心化的故障点！同理，我们也不能直接调用币安API获取数据——因为这同样是一个中心化的故障点！</p>
<p>因此，我们需要从<strong>去中心化预言机网络（DON）</strong> 和<strong>去中心化数据源</strong> 获取数据。</p>
<p>Chainlink是去中心化预言机网络（DON）的核心框架，能通过多个预言机从多源获取数据。该去中心化预言机网络以去中心化方式聚合数据，并将其写入区块链上的智能合约（这类合约通常被称为“价格参考馈送”或“数据馈送”），供我们读取。也就是说，我们只需读取Chainlink网络持续为我们更新的合约数据即可！</p>
<p>在去中心化场景下，使用Chainlink数据馈送能以更低成本、更高精度、更高安全性获取现实世界数据。由于数据来自多个来源，多方可参与该生态系统，其成本甚至低于运行一个中心化预言机。Chainlink网络采用“链下报告（Off-Chain Reporting）”机制：先在链下就数据达成共识，再通过一笔经密码学验证的单一交易将数据上报至链上，供用户使用。</p>
<p>借助这一技术，你可以开发出类似Synthetix、Aave、Compound这样的协议！</p>
<h2 id="Chainlink去中心化预言机网络"><a href="#Chainlink去中心化预言机网络" class="headerlink" title="Chainlink去中心化预言机网络"></a>Chainlink去中心化预言机网络</h2><p>你可点击<a href="%E6%B3%A8%EF%BC%9A%E5%8E%9F%E6%96%87%E6%9C%AA%E7%BB%99%E5%87%BA%E5%85%B7%E4%BD%93%E9%93%BE%E6%8E%A5%EF%BC%8C%E4%BF%9D%E7%95%99%E2%80%9C%E8%BF%99%E9%87%8C%E2%80%9D%E7%9A%84%E8%A1%A8%E8%BF%B0">此处</a>查看部分去中心化预言机网络的可视化展示。</p>
<p>这些网络的具体运行机制，我们将在后续课程中详细讲解。</p>
<p>接下来，我们就学习如何读取这类数据馈送！</p>
<p>首先要做的，是初始化合约并导入Chainlink相关代码。</p>
<h2 id="实战演练"><a href="#实战演练" class="headerlink" title="实战演练"></a>实战演练</h2><p>其中部分内容你应该已经非常熟悉，唯一的核心差异在于其背后的设计逻辑！</p>
<p>在右侧代码框中，完成以下操作：</p>
<ol>
<li>在文件顶部声明编译指令（pragma）版本为^0.6.7；</li>
<li>声明一个新合约，命名为PriceConsumer（注：Chainlink聚合器接口当前版本为v3，且会随功能迭代更新版本号。为便于后续参考，需在合约名中添加版本标识）——最终声明一个名为PriceConsumerV3的新合约，暂将合约主体留空。</li>
</ol>
<h3 id="术语补充说明"><a href="#术语补充说明" class="headerlink" title="术语补充说明"></a>术语补充说明</h3><ol>
<li><strong>Data Feeds（数据馈送）</strong>：Chainlink核心功能模块，特指经去中心化聚合后写入区块链的标准化数据流（如价格数据），是智能合约获取链下数据的核心载体；</li>
<li>Decentralized Oracle Network (DON)：去中心化预言机网络，由多个独立预言机节点组成，避免单一节点故障导致的数据不可靠，是Chainlink实现去中心化数据获取的核心架构；</li>
<li>Off-Chain Reporting (OCR)：链下报告机制，Chainlink的核心共识优化方案——预言机节点先在链下协商达成数据共识，再以单笔交易将结果上链，大幅降低上链成本并提升效率；</li>
<li><strong>Aggregator Interface（聚合器接口</strong>：Chainlink定义的标准化接口，智能合约通过该接口读取聚合后的标准化数据，v3为当前主流版本，会随功能升级迭代。</li>
<li><strong>pragma版本</strong>：Solidity语言的编译版本声明，指定合约兼容的编译器版本，^0.6.7表示兼容0.6.7及以上、0.7.0以下的版本。</li>
</ol>
<h1 id="第2章：从NPM和Github导入代码"><a href="#第2章：从NPM和Github导入代码" class="headerlink" title="第2章：从NPM和Github导入代码"></a>第2章：从NPM和Github导入代码</h1><p>要让我们的合约从其他合约中获取价格数据，首先需要获取目标合约的接口（Interface）/应用二进制接口（ABI）。但目前我们并不知道Chainlink数据馈送合约的接口具体是什么样的——该如何获取呢？</p>
<h2 id="从NPM-Github导入代码"><a href="#从NPM-Github导入代码" class="headerlink" title="从NPM/Github导入代码"></a>从NPM/Github导入代码</h2><p>你知道吗？其实可以从合约项目外部导入代码！是不是很神奇？很多时候，你无需把所有代码都直接写在自己的项目里，而是可以借鉴其他应用的代码！</p>
<p>我们需要从Chainlink的GitHub代码仓库中导入<code>AggregatorV3Interface</code>（V3版本聚合器接口）。这个接口包含了与Chainlink数据馈送合约交互所需的全部函数，例如<code>latestRoundData()</code>函数——它能返回我们需要的所有价格相关信息。</p>
<p>以下是该接口的完整代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.6.0;<br><br>interface AggregatorV3Interface &#123;<br><br>  function decimals()<br>    external<br>    view<br>    returns (<br>      uint8<br>    );<br><br>  function description()<br>    external<br>    view<br>    returns (<br>      string memory<br>    );<br><br>  function version()<br>    external<br>    view<br>    returns (<br>      uint256<br>    );<br><br>  // 若没有可上报的数据，getRoundData和latestRoundData函数应抛出&quot;No data present&quot;异常，<br>  // 而非返回未初始化的值（此类值可能被误解读为真实上报数据）。<br>  function getRoundData(<br>    uint80 _roundId<br>  )<br>    external<br>    view<br>    returns (<br>      uint80 roundId,<br>      int256 answer,<br>      uint256 startedAt,<br>      uint256 updatedAt,<br>      uint80 answeredInRound<br>    );<br><br>  function latestRoundData()<br>    external<br>    view<br>    returns (<br>      uint80 roundId,<br>      int256 answer,<br>      uint256 startedAt,<br>      uint256 updatedAt,<br>      uint80 answeredInRound<br>    );<br><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>你可以在<code>AggregatorV3Interface</code>的GitHub代码仓库中找到这份代码。</p>
<p>我们既可以直接从GitHub导入该合约，也可以通过NPM包导入——具体选择哪种方式，取决于你使用的开发框架（如Truffle、Brownie、Remix、Hardhat），但导入语法大致相同！</p>
<h2 id="实战演练-1"><a href="#实战演练-1" class="headerlink" title="实战演练"></a>实战演练</h2><p>要对接Chainlink数据馈送合约，请导入合约文件：<code>@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol</code>。</p>
<blockquote>
<p>注意：我们导入v0.6版本的接口，是为了匹配当前使用的Solidity编译器版本！</p>
</blockquote>
<h3 id="术语补充说明-1"><a href="#术语补充说明-1" class="headerlink" title="术语补充说明"></a>术语补充说明</h3><ol>
<li><strong>ABI（Application Binary Interface）</strong>：应用二进制接口，是智能合约与外部（如其他合约、前端应用）交互的标准化接口，定义了合约函数的调用方式、参数和返回值格式；</li>
<li><strong>NPM（Node Package Manager）</strong>：Node.js的包管理工具，区块链开发中常用来管理Solidity合约依赖、开发工具包（如Chainlink合约包）；</li>
<li><strong>Interface（接口）</strong>：Solidity中的接口类型，仅声明函数签名（无实现逻辑），用于定义合约间的交互规范，调用外部合约时只需引入其接口即可；</li>
<li><strong>Truffle/Brownie/Remix/Hardhat</strong>：主流的以太坊智能合约开发/部署框架，各自支持不同的依赖管理方式（如NPM或直接从GitHub导入代码）；</li>
<li>**latestRoundData()**：Chainlink数据馈送接口的核心函数，返回最新一轮的聚合数据，包含价格（answer）、数据更新时间（updatedAt）等关键信息；</li>
<li><strong>SPDX-License-Identifier</strong>：Solidity合约的许可证声明，用于标注合约的开源许可协议（如MIT），是区块链开源项目的通用规范。</li>
</ol>
<h1 id="第3章：AggregatorV3Interface接口使用"><a href="#第3章：AggregatorV3Interface接口使用" class="headerlink" title="第3章：AggregatorV3Interface接口使用"></a>第3章：AggregatorV3Interface接口使用</h1><p>做得很棒！现在，要与某一个数据馈送合约交互，既然我们已经有了接口，接下来只需要获取合约地址即可。我们可以借助<strong>链上馈送注册表（Feeds Registry）</strong> ——这是一个记录所有数据馈送合约地址的链上合约；也可以直接浏览所有合约地址列表，自行选择所需的合约地址。</p>
<p>由于我们需要获取ETH对USD的兑换价格，因此要选择包含该数据的特定数据馈送合约。</p>
<p>⚠️ <strong>重要提示</strong>：不同区块链网络中，对应同一类数据的合约地址各不相同。例如，ETH/USD价格合约在以太坊主网、Polygon主网、Rinkeby测试网等网络中的地址均不相同。</p>
<p>本演示将使用Rinkeby测试网的ETH/USD数据馈送合约，你可在《Rinkeby数据馈送文档》中查询所有相关合约地址。我们选择Rinkeby测试网的原因是，在后续课程中，你将学习如何向该测试网部署合约！</p>
<h2 id="实战演练-2"><a href="#实战演练-2" class="headerlink" title="实战演练"></a>实战演练</h2><p>请完成以下操作：</p>
<ol>
<li>声明一个<strong>公共全局变量</strong>（即定义在所有函数外部的变量），命名为<code>priceFeed</code>，类型为<code>AggregatorV3Interface</code>；</li>
<li>编写一个构造函数（<code>constructor</code>）；</li>
<li>实例化<code>AggregatorV3Interface</code>合约：将以太坊主网ETH/USD合约地址<code>0x8A753747A1Fa494EC906cE90E9f37563A8AF630e</code>作为参数传入，并将实例化结果赋值给<code>priceFeed</code>变量。</li>
</ol>
<blockquote>
<p>提示：如需验证你填写的Rinkeby网络ETH/USD数据馈送合约地址是否正确，可查阅Chainlink文档的「以太坊数据馈送」页面。</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript">pragma solidity ^<span class="hljs-number">0.6</span><span class="hljs-number">.7</span>;<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol&quot;</span>;<br><br>contract <span class="hljs-title class_">PriceConsumerV3</span> &#123;<br>  <span class="hljs-title class_">AggregatorV3Interface</span> <span class="hljs-keyword">public</span> priceFeed;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) <span class="hljs-keyword">public</span> &#123;<br>      priceFeed = <span class="hljs-title class_">AggregatorV3Interface</span>(<span class="hljs-number">0x8A753747A1Fa494EC906cE90E9f37563A8AF630e</span>);<br>      &#125;<br>  &#125;<br><br></code></pre></div></td></tr></table></figure>

<h3 id="术语补充说明-2"><a href="#术语补充说明-2" class="headerlink" title="术语补充说明"></a>术语补充说明</h3><ol>
<li><strong>Feeds Registry（馈送注册表）</strong>：Chainlink推出的链上合约注册表，统一管理各数据馈送合约的地址与元数据，方便开发者快速查找不同网络/不同标的的价格馈送合约地址；</li>
<li><strong>Mainnet/Testnet</strong>：分别指区块链“主网”（真实资产流通的正式网络）和“测试网”（用于开发测试的模拟网络，无真实资产风险），Rinkeby是以太坊经典测试网之一；</li>
<li><strong>Constructor（构造函数）</strong>：Solidity合约中的特殊函数，仅在合约部署时执行一次，常用于初始化合约变量（如本例中绑定数据馈送合约地址）；</li>
<li><strong>Global variable（全局变量）</strong>：定义在合约内、所有函数外的变量，生命周期与合约一致，可被合约内所有函数访问；<code>public</code>修饰符表示该变量可被外部读取。</li>
</ol>
<h1 id="第4章：元组（Tuples）的使用"><a href="#第4章：元组（Tuples）的使用" class="headerlink" title="第4章：元组（Tuples）的使用"></a>第4章：元组（Tuples）的使用</h1><p>接下来，我们需要调用<code>priceFeed</code>合约的<code>latestRoundData</code>函数来获取ETH的最新价格。该函数包含了我们所需的全部信息，以及一些额外字段：</p>
<ul>
<li><code>roundId</code>：轮次ID。每一次价格更新都会生成唯一的轮次ID；</li>
<li><code>answer</code>：当前价格；</li>
<li><code>startedAt</code>：该轮价格计算的起始时间戳；</li>
<li><code>updatedAt</code>：该轮价格的更新时间戳；</li>
<li><code>answeredInRound</code>：计算出该价格对应的轮次ID。</li>
</ul>
<h2 id="元组（Tuples）"><a href="#元组（Tuples）" class="headerlink" title="元组（Tuples）"></a>元组（Tuples）</h2><p>不过在调用这个函数之前，先问你一个问题：你知道什么是元组吗？</p>
<p>如果你还记得之前课程里讲过的内容，可以直接跳过本节；如果不记得，跟着我们的讲解来学习就好。</p>
<p>元组是Solidity中用于<strong>语法层面组合多个表达式</strong>的一种方式。</p>
<p>当一个函数返回多个变量时（比如<code>latestRoundData</code>函数），我们会将其返回类型视为“包含多种类型的元组”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">function latestRoundData()<br>    external<br>    view<br>    returns (<br>      uint80 roundId,<br>      int256 answer,<br>      uint256 startedAt,<br>      uint256 updatedAt,<br>      uint80 answeredInRound<br>    );<br></code></pre></div></td></tr></table></figure>

<p>要为每个返回值赋值给对应的变量，我们需要使用元组语法——将变量列表用括号包裹：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">(uint80 roundId, int answer, uint startedAt, uint updatedAt, uint80 answeredInRound) = priceFeed.latestRoundData();<br></code></pre></div></td></tr></table></figure>

<p>我们也可以将变量重命名为任意名称。比如，把<code>answer</code>改名为<code>price</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">(uint80 roundId, int price, uint startedAt, uint updatedAt, uint80 answeredInRound) = priceFeed.latestRoundData();<br></code></pre></div></td></tr></table></figure>

<p>此外，如果某些返回值我们用不到，最佳实践是将其留空，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">(,int price,,,) = priceFeed.latestRoundData();<br></code></pre></div></td></tr></table></figure>
<p>这样一来，我们能清晰看到哪些变量是核心关注的，同时避免声明多余的变量。</p>
<h2 id="实战演练-3"><a href="#实战演练-3" class="headerlink" title="实战演练"></a>实战演练</h2><p>请完成以下操作：</p>
<ol>
<li>声明一个<strong>公共视图函数</strong>（<code>public view</code>），命名为<code>getLatestPrice</code>，返回值类型为<code>int</code>；</li>
<li>调用<code>priceFeed</code>合约的<code>latestRoundData</code>函数，仅将返回值中的<code>answer</code>字段存储到名为<code>price</code>的<code>int</code>类型变量中，忽略其他所有返回值（不要声明这些无用变量）。如果忘记语法可以参考上文示例，但建议先尝试独立完成；</li>
<li>返回<code>price</code>变量。</li>
</ol>
<figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">pragma solidity ^<span class="hljs-number">0.6</span><span class="hljs-number">.7</span>;<br><br><span class="hljs-keyword">import</span> &quot;@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol&quot;;<br><br>contract PriceConsumerV3 &#123;<br>  AggregatorV3Interface <span class="hljs-built_in">public</span> priceFeed;<br><br>  constructor() <span class="hljs-built_in">public</span> &#123;<br>    priceFeed = AggregatorV3Interface(<span class="hljs-number">0x8A753747A1Fa494EC906cE90E9f37563A8AF630e</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> getLatestPrice() <span class="hljs-built_in">public</span> <span class="hljs-keyword">view</span> <span class="hljs-keyword">returns</span> (<span class="hljs-type">int</span>) &#123;<br>    (,<span class="hljs-type">int</span> price,,,) = priceFeed.latestRoundData();<br>    <span class="hljs-keyword">return</span> price;<br>  &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure>

<h3 id="术语补充说明-3"><a href="#术语补充说明-3" class="headerlink" title="术语补充说明"></a>术语补充说明</h3><ol>
<li><strong>Tuple（元组）</strong>：Solidity中的复合数据结构，支持将多个不同类型的值组合成一个整体，常用于处理多返回值函数的结果，是Solidity特有的语法特性；</li>
<li><strong>View function（视图函数）</strong>：Solidity中用<code>view</code>修饰的函数，仅读取链上数据、不修改合约状态，调用此类函数无需消耗Gas；</li>
<li><strong>Timestamp（时间戳）</strong>：以Unix时间戳格式表示的时间（单位：秒），区块链中常用该格式记录事件发生的时间；</li>
<li><strong>空白占位符（,）</strong>：元组赋值时的语法技巧，用逗号表示忽略对应位置的返回值，可简化代码并减少不必要的变量声明。</li>
</ol>
<h1 id="第5章：Chainlink数据馈送的小数位数（Decimals）"><a href="#第5章：Chainlink数据馈送的小数位数（Decimals）" class="headerlink" title="第5章：Chainlink数据馈送的小数位数（Decimals）"></a>第5章：Chainlink数据馈送的小数位数（Decimals）</h1><p>太棒了！现在我们已经有了能获取以太坊兑美元最新价格的函数！</p>
<p>但你也知道，Solidity对小数的处理并不友好——那么当我们调用这个函数时，会得到什么样的结果呢？你能猜到返回值的格式吗？</p>
<p>其实不用你试了，直接告诉你：调用该函数后，我们会得到类似这样的返回值：<br><code>310523971888</code></p>
<p>等等……以太坊的价格真的有这么高吗？</p>
<p>或许在遥远的未来有可能，但在本文撰写时，实际价格远非如此——当前以太坊价格约为3105.52美元。</p>
<p>那我们该如何确定小数点的位置呢？答案很简单：<code>decimals</code>函数会告诉我们！</p>
<p>只看接口代码，你能写出一个<code>getDecimals</code>函数，返回该合约使用的小数位数吗？我相信你肯定可以！</p>
<h2 id="实战演练-4"><a href="#实战演练-4" class="headerlink" title="实战演练"></a>实战演练</h2><p>请完成以下操作：</p>
<ol>
<li>声明一个<strong>公共视图函数</strong>（<code>public view</code>），命名为<code>getDecimals</code>，其返回值需与<code>AggregatorV3Interface</code>中<code>decimals</code>函数的返回值类型一致（注意：返回值类型为<code>uint8</code>）；</li>
<li>函数第一行代码：调用<code>priceFeed.decimals()</code>函数，并将结果存储到名为<code>decimals</code>、类型为<code>uint8</code>的变量中；</li>
<li>函数第二行代码：返回这个<code>decimals</code>变量。</li>
</ol>
<h3 id="术语补充说明-4"><a href="#术语补充说明-4" class="headerlink" title="术语补充说明"></a>术语补充说明</h3><ol>
<li><strong>Decimals（小数位数）</strong>：Chainlink数据馈送合约中用于标注价格精度的参数，例如返回值<code>310523971888</code>若对应18位小数，则实际价格为<code>310523971888 / 10^18 = 3105.23971888</code>美元，该设计是为了规避Solidity不支持浮点数的问题；</li>
<li><strong>uint8</strong>：Solidity中的无符号整数类型，取值范围0~255，适用于表示小数位数这类数值范围较小的参数；</li>
<li><strong>decimals()函数</strong>：<code>AggregatorV3Interface</code>接口内置函数，返回当前数据馈送合约使用的小数位数，是解析价格数据的核心辅助函数。</li>
</ol>
<h1 id="第6章：Chainlink数据馈送参考资料"><a href="#第6章：Chainlink数据馈送参考资料" class="headerlink" title="第6章：Chainlink数据馈送参考资料"></a>第6章：Chainlink数据馈送参考资料</h1><p>太厉害了！现在你已经掌握了如何将去中心化预言机网络（DON）的数据接入智能合约。学完本课后，你可以跟着Chainlink文档中的基础教程，学习如何将这类合约部署到真实的测试网中！</p>
<p>后续我们会深入讲解这些价格馈送的底层工作原理，以及如何搭建一套DON来获取你所需的任意数据。不过在实际开发中，开发者往往更倾向于使用这些“开箱即用”的预言机服务——因为它们上手更简单，几乎无需额外配置就能使用。接下来我们还会学习更多这类“现成可用、开箱即走”的服务。</p>
<p>Chainlink预言机的功能远不止我们目前讲到的这些，后续我们会全面解析其整体工作机制，以及其他一些极具实用性的强大功能。</p>
<p>不过在此之前，先给大家提前介绍几款能让开发能力更上一层楼的工具。很快你就会学习如何使用Truffle、Hardhat等开发框架，以及前端开发、去中心化金融（DeFi）等相关知识，这些内容会让Chainlink数据馈送的应用场景变得更加丰富。等掌握这些知识点后，你可以回过头来使用Truffle入门套件、Hardhat入门套件和Brownie入门套件（Chainlink Mix），在这些开发套件中构建复杂的智能合约应用。</p>
<p>在学习这些内容之前，我们先继续探索Chainlink为我们提供的更多精彩功能吧！</p>
<p>点击“下一章”按钮，进入下一课的学习。</p>
<h3 id="术语补充说明-5"><a href="#术语补充说明-5" class="headerlink" title="术语补充说明"></a>术语补充说明</h3><ol>
<li><strong>Under the hood</strong>：技术领域常用俗语，指“底层原理/内部机制”，此处特指价格馈送合约的运行逻辑、DON节点的共识流程等底层实现；</li>
<li><strong>Out-of-the-box</strong>：直译“开箱即用”，在开发领域指无需二次开发/配置即可直接使用的工具/服务，是Chainlink核心优势之一；</li>
<li><strong>Ready-to-go out-of-the-box</strong>：强化版“开箱即用”，强调“现成可用、无需额外准备”，贴合Chainlink数据馈送低接入成本的特点；</li>
<li><strong>Starter Kit（入门套件）</strong>：Chainlink官方为主流开发框架（Truffle/Hardhat/Brownie）提供的预制开发模板，包含数据馈送、预言机交互等基础代码，降低开发者入门门槛；</li>
<li><strong>Development suites（开发套件）</strong>：整合了开发、编译、部署、测试等功能的一站式开发环境，如Truffle Suite、Hardhat生态等。</li>
</ol>
<h1 id="第七章：Chainlink-VRF-简介"><a href="#第七章：Chainlink-VRF-简介" class="headerlink" title="第七章：Chainlink VRF 简介"></a>第七章：Chainlink VRF 简介</h1><h4 id="伪随机-DNA"><a href="#伪随机-DNA" class="headerlink" title="伪随机 DNA"></a>伪随机 DNA</h4><p>在我们的合约开发过程中，我们一直使用的是伪随机数。keccak256 函数是学习编写智能合约的一个很好的入门工具，但正如我们之前提到的，若智能合约的逻辑依赖伪随机数，可能会引发严重问题。链上机制的所有环节本质上都是确定性的，这其中也包括我们使用的哈希函数。</p>
<p>当我们尝试从一个字符串生成随机 DNA 时会发现，每次得到的 DNA 结果都是完全相同的——这意味着我们的“随机数生成函数”根本不具备真正的随机性！此外，我们也无法保证用户向该函数输入的“字符串”是真实可信的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">uint(keccak256(abi.encodePacked(_str)))<br></code></pre></div></td></tr></table></figure>

<p>那么该如何解决这个问题？一种简单的思路是使用全局可用的变量，比如 msg.sender、block.difficulty 和 block.timestamp。你可能见过类似这样的随机数生成方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">uint(keccak256(abi.encodePacked(msg.sender, block.difficulty, block.timestamp)));<br></code></pre></div></td></tr></table></figure>

<p>在这个例子中，开发者试图混合这些全局变量来降低数字的可预测性，但即便如此，这些数值依然存在可被预判的漏洞：</p>
<ul>
<li>msg.sender 由交易发起方提前知晓；</li>
<li>block.difficulty 受矿工直接影响；</li>
<li>block.timestamp 可被预测。</li>
</ul>
<p>由此可见，区块链内的所有数据都是确定性的，若依赖链内生成的随机数，合约极易遭受攻击。那我们该如何获取链外的真随机数？答案正是 Chainlink 预言机！</p>
<p>让我们回到之前的僵尸合约代码——我们曾为僵尸生成伪随机 DNA，现在尝试用 Chainlink 可验证随机函数（Chainlink VRF）修复这个问题，借助其安全的随机性机制来优化合约。</p>
<h4 id="Chainlink-VRF-是什么？"><a href="#Chainlink-VRF-是什么？" class="headerlink" title="Chainlink VRF 是什么？"></a>Chainlink VRF 是什么？</h4><p>Chainlink VRF（Verifiable Randomness Function，可验证随机函数）是一种从链外获取随机数的方式，且该过程具备密码学层面的可验证性。这一点至关重要，因为我们始终希望合约逻辑是绝对不可篡改的。</p>
<p>如果简单粗暴地通过链下 API 调用第三方服务获取随机数，一旦该服务宕机、被贿赂或遭黑客攻击，返回的随机数就可能被篡改。而 Chainlink VRF 内置了链上验证合约，能够通过密码学方式证明返回的随机数是真正随机且未被篡改的。</p>
<h4 id="基础请求模型"><a href="#基础请求模型" class="headerlink" title="基础请求模型"></a>基础请求模型</h4><p>接下来我们介绍与预言机交互的<strong>基础请求模型</strong>：</p>
<ol>
<li>首先，智能合约（称为“调用方合约”）向 Chainlink 节点发起“请求”——该节点由链上合约和对应的链下节点组成。调用方合约发起请求时会触发一个特定事件，而对应的 Chainlink 节点会订阅/监听这个事件。这一步骤在一笔交易中完成。</li>
<li>随后，Chainlink 预言机处理该请求（无论是生成随机数、获取数据等），并将结果/计算值返回给调用方合约；也可能先返回给一个“中间合约”（通常称为“预言机合约”），再由该合约将响应转发给调用方合约。</li>
<li>返回结果的过程会在第二笔独立交易中完成，因此基础请求模型总共涉及两笔交易，至少需要两个区块才能完成。</li>
</ol>
<p>这种“两笔交易”的架构意义重大：它能限制对随机数或数据请求的暴力攻击，攻击者若想篡改结果，需付出极高的燃气费成本，使其攻击行为不具备经济可行性。</p>
<p>总结整个流程：</p>
<ol>
<li>调用方合约在一笔交易中发起请求；</li>
<li>调用方合约或预言机合约触发事件；</li>
<li>Chainlink 节点（链下）监听该事件，事件中会记录请求的详细信息；</li>
<li>Chainlink 节点发起第二笔交易，通过调用方合约指定的函数，将数据返回到链上；</li>
<li>对于 Chainlink VRF 而言，还会额外进行随机数验证，确保返回的数值是真随机数。</li>
</ol>
<p>与以太坊或其他兼容 Solidity 的区块链交易类似，使用预言机时需要支付“预言机燃气费”，即 LINK 代币（Chainlink 代币）。LINK 代币专为预言机生态设计，保障 Chainlink 预言机网络的安全性。每次按照基础请求模型发起请求时，合约必须预存一定数量的 LINK 代币（具体金额由所使用的预言机服务决定，不同服务的预言机燃气费不同）。</p>
<h4 id="为何数据馈送（Data-Feeds）无需这样操作？"><a href="#为何数据馈送（Data-Feeds）无需这样操作？" class="headerlink" title="为何数据馈送（Data Feeds）无需这样操作？"></a>为何数据馈送（Data Feeds）无需这样操作？</h4><p>此时你可能会问：“为什么数据馈送（Data Feeds）不需要这样的流程？”“为什么使用数据馈送时不用支付预言机燃气费？”这些都是非常好的问题。</p>
<p>数据馈送的工作方式不同：它并非向单个 Chainlink 节点发起请求，而是向一整个去中心化预言机网络（Decentralized Oracle Network）的节点群请求数据。但只需一个实体触发对整个网络的请求，我们便能受益于他人已为各类数据馈送发起的预言机请求。</p>
<p>数据馈送由 Aave、Compound、Synthetix 等众多项目联合赞助，当所上报的数据（如价格）发生微小变动时，系统会自动触发网络更新。通过集体协作，不仅能降低交易成本，还能为整个生态创造可共享的公共资源！</p>
<p>简言之，数据馈送的背后，是有人已为我们执行了更高级版本的基础请求模型。</p>
<h4 id="Chainlink-VRF-底层原理"><a href="#Chainlink-VRF-底层原理" class="headerlink" title="Chainlink VRF 底层原理"></a>Chainlink VRF 底层原理</h4><p>Chainlink VRF 遵循上述基础请求模型，并增加了一个核心优势：由于 Chainlink VRF 节点返回的随机数附带链上密码学证明，我们只需对接单个 Chainlink VRF 节点即可保证安全性。尽管随着技术发展，更去中心化的 Chainlink VRF 版本已逐步推出，但目前这种方式已能为智能合约提供足够安全的随机数。</p>
<p>我们不会深入探讨研究人员为验证 Chainlink VRF 节点返回随机数所做的密码学证明，但核心逻辑可概括为：</p>
<ol>
<li>智能合约通过指定一个哈希值（用于唯一标识某个 Chainlink 预言机）发起随机数请求；</li>
<li>Chainlink 节点利用自身的私钥和该哈希值生成随机数，随后将随机数及密码学证明一同返回至链上合约；</li>
<li>链上的 VRF 协调器合约（VRF Coordinator）接收随机数和证明，并通过预言机的公钥完成验证；</li>
<li>依托区块链公认的签名和证明验证能力，确保合约仅能使用经过链上环境验证的随机数。</li>
</ol>
<p>你可查阅 Chainlink VRF 官方合约代码，了解该系统使用的具体函数。</p>
<p>好了，这些概念虽然有一定深度，但现在我们终于可以开始学习如何在智能合约中获取随机数了。首先，我们需要从 NPM/GitHub 引入 Chainlink VRF 合约代码，通过继承 VRFConsumerBase 合约的功能，实现事件触发并定义 Chainlink 节点回调（响应）的函数。</p>
<h4 id="实战演练-5"><a href="#实战演练-5" class="headerlink" title="实战演练"></a>实战演练</h4><p>从 Chainlink 的 NPM 仓库/GitHub 导入 0.6.6 版本的 VRFConsumerBase.sol 合约文件。<br>VRFConsumerBase.sol 包含了与 Chainlink VRF 协调器和节点交互所需的所有函数，你也可在 Chainlink 官方文档中找到相关使用示例。</p>
<hr>
<h3 id="翻译说明"><a href="#翻译说明" class="headerlink" title="翻译说明"></a>翻译说明</h3><ol>
<li><p>术语统一性：</p>
<ul>
<li>Chainlink VRF：统一译为“Chainlink 可验证随机函数”，首次出现标注英文全称（Verifiable Randomness Function）；</li>
<li>Oracle：译为“预言机”（区块链领域通用译法）；</li>
<li>LINK token：译为“LINK 代币”，首次提及补充说明“Chainlink 代币”；</li>
<li>VRFConsumerBase：保留英文原名（合约名不翻译），中文描述为“VRF 消费者基础合约”；</li>
<li>VRF Coordinator：译为“VRF 协调器合约”；</li>
<li>Basic Request Model：译为“基础请求模型”（贴合技术语境）；</li>
<li>Data Feeds：译为“数据馈送”（Chainlink 官方中文文档译法）。</li>
</ul>
</li>
<li><p>技术语境适配：</p>
<ul>
<li>“brute force attacks”译为“暴力攻击”（网络安全通用译法）；</li>
<li>“gas costs”译为“燃气费”（以太坊生态通用译法）；</li>
<li>“deterministic”译为“确定性的”（区块链技术术语）；</li>
<li>“cryptographic proof”译为“密码学证明”；</li>
<li>“decentralized oracle network”译为“去中心化预言机网络”。</li>
</ul>
</li>
<li><p>句式优化：</p>
<ul>
<li>英文长句拆解为符合中文阅读习惯的短句（如“However, as we mentioned earlier…”段落）；</li>
<li>被动语态转主动语态（如“is comprised of”译为“由……组成”而非“被组成”）；</li>
<li>保留代码块完整性，仅翻译注释和上下文描述。</li>
</ul>
</li>
<li><p>补充说明：</p>
<ul>
<li>对“block.difficulty”“block.timestamp”等链上变量，补充简要解释（如“受矿工直接影响”“可被预测”），帮助理解其不可靠性；</li>
<li>对“two transaction architecture”译为“两笔交易的架构”，并补充说明“至少需要两个区块完成”，贴合区块链交易确认逻辑。</li>
</ul>
</li>
</ol>
<h1 id="第8章：构造函数嵌套调用"><a href="#第8章：构造函数嵌套调用" class="headerlink" title="第8章：构造函数嵌套调用"></a>第8章：构造函数嵌套调用</h1><p>你理解得没错！<code>VRFConsumerBase</code> 合约包含了我们向 Chainlink 预言机发送请求所需的全部代码，其中也涵盖了所有事件日志相关的代码。</p>
<p>正如我们之前所说，要与 Chainlink 节点交互，我们需要知晓几个关键变量：</p>
<ul>
<li>Chainlink 代币合约地址：我们的合约需要通过该地址确认是否持有足够的 LINK 代币来支付燃气费；</li>
<li>VRF 协调器合约地址：用于验证我们获取的数值是否为真随机数；</li>
<li>Chainlink 节点密钥哈希（keyhash）：用于指定我们想要对接的具体 Chainlink 节点；</li>
<li>Chainlink 节点手续费：代表 Chainlink 节点向我们收取的手续费（燃气费），以 LINK 代币计价。</li>
</ul>
<p>你可以在 Chainlink 官方文档的「VRF 合约地址」页面找到这些变量。需要再次说明的是，不同网络的地址各不相同，但本课程中我们仍以 Rinkeby 测试网为例进行讲解。</p>
<p>上一节课提到，我们要继承 <code>VRFConsumerBase</code> 合约的功能。但如何实现继承合约的构造函数呢？答案是：我们可以在构造函数中嵌套调用父合约的构造函数（即“构造函数嵌套调用”）。</p>
<p>我们来看这段示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">import &quot;./Y.sol&quot;;<br>contract X is Y &#123;<br>    constructor() Y() public&#123;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>要调用继承合约的构造函数，只需将父合约构造函数的声明写入当前合约的构造函数中即可。</p>
<p>我们可以对 <code>VRFConsumerBase</code> 合约执行同样的操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">constructor() VRFConsumerBase(<br>    0xb3dCcb4Cf7a26f6cf6B120Cf5A73875B7BBc655B, // VRF 协调器地址<br>    0x01BE23585060835E02B77ef475b0Cc51aA1e0709  // LINK 代币合约地址<br>) public&#123;<br><br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="动手实践"><a href="#动手实践" class="headerlink" title="动手实践"></a>动手实践</h3><ol>
<li><p>让 <code>ZombieFactory</code> 合约继承 <code>VRFConsumerBase</code> 合约。如果你忘记了语法，可参考以下示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">// 定义名为 `parent` 的父合约<br>contract parent &#123;<br><br>&#125;<br><br>// 定义名为 `child` 的子合约，继承自 `parent`<br>contract child is parent &#123;<br><br>&#125;<br></code></pre></div></td></tr></table></figure></li>
<li><p>为 <code>ZombieFactory</code> 合约编写构造函数，在其中调用 <code>VRFConsumerBase</code> 合约的构造函数，并传入 Rinkeby 网络下 VRF 协调器和 LINK 代币合约的地址作为参数。构造函数体保持为空即可。你可以直接复制粘贴上述示例中的地址，也可以从 Chainlink 文档的「VRF 合约地址」页面获取。若再次忘记语法，可参考上文给出的示例。</p>
</li>
</ol>
<h3 id="术语说明（补充）"><a href="#术语说明（补充）" class="headerlink" title="术语说明（补充）"></a>术语说明（补充）</h3><ul>
<li><strong>Constructor in a constructor</strong>：直译是“构造函数中的构造函数”，结合 Solidity 语法特性，译为“构造函数嵌套调用”更贴合语境（本质是子合约构造函数中显式调用父合约构造函数）；</li>
<li><strong>VRFConsumerBase</strong>：Chainlink VRF（可验证随机函数）的基础消费者合约，无需直译，保留原名称即可；</li>
<li><strong>VRF Coordinator</strong>：VRF 协调器（Chainlink 网络中负责管理随机数请求的核心合约）；</li>
<li><strong>keyhash</strong>：密钥哈希（Chainlink 节点的唯一标识，用于指定交互节点）；</li>
<li><strong>Rinkeby</strong>：以太坊经典测试网名称，保留原名称（中文可译“林克比”，但行业内通用英文）。</li>
</ul>
<hr>
<figure class="highlight delphi"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">()</span> <span class="hljs-title">VRFConsumerBase</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        0x6168499c0cFfCaCD319c818142124B7A15E857ab,</span></span><br><span class="hljs-params"><span class="hljs-function">        0x01BE23585060835E02B77ef475b0Cc51aA1e0709 </span></span><br><span class="hljs-params"><span class="hljs-function">    )</span> <span class="hljs-title">public</span><span class="hljs-comment">&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function"></span></span><br><span class="hljs-comment"><span class="hljs-function">    &#125;</span> 这个代码是什么意思？</span><br></code></pre></div></td></tr></table></figure>

<p>这段代码是 <strong>Solidity 智能合约中构造函数的核心写法</strong>，本质是<strong>子合约构造函数显式调用父合约 <code>VRFConsumerBase</code> 的构造函数</strong>，并传入关键参数。下面拆解每一部分的含义，帮你彻底理解：</p>
<h3 id="1-核心语法结构"><a href="#1-核心语法结构" class="headerlink" title="1. 核心语法结构"></a>1. 核心语法结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">constructor() VRFConsumerBase(参数1, 参数2) public &#123;<br>    // 构造函数体（此处为空）<br>&#125;<br></code></pre></div></td></tr></table></figure>
<table>
<thead>
<tr>
<th>部分</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>constructor()</code></td>
<td>当前合约的构造函数声明：<br>- Solidity 中 <code>constructor</code> 是合约部署时<strong>仅执行一次</strong>的特殊函数；<br>- 空括号 <code>()</code> 表示该构造函数无入参。</td>
</tr>
<tr>
<td><code>VRFConsumerBase(...)</code></td>
<td>显式调用父合约 <code>VRFConsumerBase</code> 的构造函数：<br>- 因为当前合约继承了 <code>VRFConsumerBase</code>，必须通过这种方式传参初始化父合约；<br>- 括号内是传给父合约构造函数的参数。</td>
</tr>
<tr>
<td><code>public</code></td>
<td>构造函数的可见性修饰符（Solidity 0.5.x 及之前版本要求显式声明，0.6.x+ 可省略）。</td>
</tr>
<tr>
<td>空函数体 <code>&#123;&#125;</code></td>
<td>当前合约构造函数无需额外逻辑，仅完成父合约的初始化。</td>
</tr>
</tbody></table>
<h3 id="2-传入的两个参数含义"><a href="#2-传入的两个参数含义" class="headerlink" title="2. 传入的两个参数含义"></a>2. 传入的两个参数含义</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">0x6168499c0cFfCaCD319c818142124B7A15E857ab  // VRF Coordinator 地址<br>0x01BE23585060835E02B77ef475b0Cc51aA1e0709  // LINK 代币合约地址<br></code></pre></div></td></tr></table></figure>
<p>这两个地址是 <strong>Rinkeby 测试网</strong> 下 Chainlink VRF 所需的核心配置，作用分别是：</p>
<ul>
<li><strong>VRF Coordinator 地址</strong>：<br>Chainlink 网络中负责<strong>管理随机数请求、验证随机数合法性</strong>的核心合约地址。<code>VRFConsumerBase</code> 必须知道这个地址，才能向 Chainlink 节点发起随机数请求，并验证返回结果是否真实有效。</li>
<li><strong>LINK 代币合约地址</strong>：<br>Chainlink 生态的原生代币合约地址。<code>VRFConsumerBase</code> 通过这个地址：<br>① 检查当前合约是否持有足够的 LINK 代币（支付 Chainlink 节点的手续费）；<br>② 完成手续费的转账扣减（若有自动扣费逻辑）。</li>
</ul>
<h3 id="3-完整业务逻辑"><a href="#3-完整业务逻辑" class="headerlink" title="3. 完整业务逻辑"></a>3. 完整业务逻辑</h3><p>这段代码的作用是：<br>当你部署当前合约（比如 <code>ZombieFactory</code>）时，会先调用父合约 <code>VRFConsumerBase</code> 的构造函数，把 Rinkeby 测试网的 VRF 协调器和 LINK 代币地址传入并初始化父合约的核心变量。<br>初始化完成后，当前合约就具备了：<br>✅ 向 Chainlink 节点发起随机数请求的能力；<br>✅ 验证随机数合法性的能力；<br>✅ 用 LINK 代币支付手续费的基础条件。</p>
<h3 id="补充注意点"><a href="#补充注意点" class="headerlink" title="补充注意点"></a>补充注意点</h3><ol>
<li>地址的网络适配性：<br>你用的 <code>0x6168499c0cFfCaCD319c818142124B7A15E857ab</code> 是 Rinkeby 测试网的 VRF 协调器地址，<strong>换网络（如 Sepolia、主网）必须替换成对应地址</strong>，否则合约无法正常工作。</li>
<li>构造函数调用规则：<br>Solidity 中如果父合约有带参构造函数，子合约<strong>必须显式调用</strong>（像这样写在子构造函数后），否则编译报错——这也是这段代码的核心目的。</li>
<li>函数体为空的原因：<br>这里只需要完成父合约的初始化，当前合约（<code>ZombieFactory</code>）的构造逻辑如果没有额外需求（比如初始化僵尸相关的基础变量），就可以留空。</li>
</ol>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Web3/">Web3</a>
                    
                  </div>
                
              </div>
              
                
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/12/06/1236fbf5e3fb/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">2027年学习计划</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/12/06/c13a0ef7f949/">
                        <span class="hidden-mobile">Defi对于全球国家货币主权的冲击</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


            

                
                  <a id="scroll-top-button" href="#" role="button">
                    <i class="iconfont icon-arrowup" aria-hidden="true"></i>
                  </a>
                  

                    

                          
      </main>

      <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://whale3070.github.io/" target="_blank" rel="nofollow noopener"><span>Whale3070</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<link href="/pagefind/pagefind-ui.css" rel="stylesheet">
  <script src="/pagefind/pagefind-ui.js"></script>
  <style>
    /* 搜索框配色适配 */
    #search { margin-top: 2rem; }
    [data-user-color-scheme='dark'] .pagefind-ui {
      --pagefind-ui-primary: #eeeeee;
      --pagefind-ui-text: #eeeeee;
      --pagefind-ui-background: #151515;
      --pagefind-ui-border: #333;
    }
  </style>
    </body>

  </html>