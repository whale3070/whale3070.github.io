

  <!DOCTYPE html>
  <html lang="zh-CN" data-default-color-scheme=&#34;dark&#34; >
  <style>
    .text1
    {
    text-shadow: 0px 0px 2px #f2f3f2;
    }
    </style>

  <script>
    // 强制内网 IP 识别为安全上下文
    if (window.location.hostname !== 'localhost' && window.location.protocol === 'http:') {
        // 尝试手动映射 crypto 属性
        if (!window.crypto.subtle && window.crypto.webkitSubtle) {
            window.crypto.subtle = window.crypto.webkitSubtle;
        }
    }
    
    // 终极补丁：如果还是没有 subtle，则创建一个占位符避免报错
    // 提示：这通常能解决加载报错，但如果插件强依赖原生加密，建议执行下面的“降级”预判
    if (!window.isSecureContext) {
        console.warn('当前环境非安全上下文，正在尝试兼容内网加密解密...');
    }
</script>


<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/null">
  <link rel="icon" type="image/png" href="/null">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>javascript2 - whale3070&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.4.0/styles/github-gist.min.css" />
    
  

  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"whale3070.github.io","root":"/","version":"1.8.7","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":false,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 7.3.0"></head>


    <body>
      <header style="height: 70vh;">
        <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>InfoSec learning</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/search/">
                <i class="iconfont icon-search"></i>
                搜索
              </a>
            </li>
          
        
        
        
          
        
      </ul>
    </div>
  </div>
</nav>

          <div class="banner" id="banner" false
            style="background: url('/img/default.png') no-repeat center center;
              background-size: cover;">
              <div class="full-bg-img">
                <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
                  <div class="page-header text-center fade-in-up">
                    <span class="h2 text1" id="subtitle" title="javascript2">
                      
                        javascript2
                      
                    </span>
        
                    
                      <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2025-12-03 05:20" pubdate>
        2025年12月3日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      10.3k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      123
       分钟
    </span>
  

  
  
</div>

                    
                  </div>
                    
                  </div>
                  
                </div>
              </div>
          </div>
      </header>

      <main>
        
          

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" data-pagefind-body>
            <!-- SEO header -->
            <h1 style="display: none">javascript2</h1>
            
            <div class="markdown-body">
              <h1 id="js文档"><a href="#js文档" class="headerlink" title="js文档"></a>js文档</h1><p><a target="_blank" rel="noopener" href="https://javascript.info/devtools">https://javascript.info/devtools</a></p>
<h2 id="use-strict"><a href="#use-strict" class="headerlink" title="use strict"></a>use strict</h2><p> ECMAScript 5 (ES5) 的出现。ES5 为该语言添加了新特性，并修改了一些现有特性。为了保持旧代码的兼容性，大多数此类修改默认情况下处于关闭状态。您需要使用特殊指令显式启用它们：”use strict”。</p>
<p>该指令看起来像一个字符串：”use strict”或’use strict’。当它位于脚本顶部时，整个脚本将以“现代”方式运行。</p>
<p>现代 JavaScript 支持“类”和“模块”——这些高级语言结构（我们稍后会详细介绍）会use strict自动启用。因此，如果我们使用它们，就不需要添加”use strict”指令。</p>
<p>所以，目前”use strict”;它只是脚本开头的一个有用组成部分。以后，当你的代码全部放在类和模块中时，就可以省略它了。</p>
<p>就目前而言，我们只能了解use strict一些基本情况。</p>
<p>在接下来的章节中，随着我们学习语言特性，我们将看到严格模式和旧模式之间的区别。幸运的是，区别并不多，而且它们实际上让我们的生活更便捷。</p>
<p>本教程中的所有示例均假定为严格模式，除非（极少数情况下）另有说明。</p>
<h2 id="变量-常量"><a href="#变量-常量" class="headerlink" title="变量 &amp; 常量"></a>变量 &amp; 常量</h2><p>变量用let<br>常量用const</p>
<p>变量名应该具有清晰、明确的含义，描述它所存储的数据。</p>
<p>变量命名是编程中最重要也是最复杂的技能之一。只需看一眼变量名，就能分辨出代码是出自新手之手还是经验丰富的开发者之手。</p>
<p>在实际项目中，大部分时间都花在修改和扩展现有代码库上，而不是从头开始编写全新的代码。当我们在忙其他事情一段时间后再回到之前的代码时，如果变量名称清晰明了，查找信息就容易得多。</p>
<p>请在声明变量之前花时间仔细考虑其名称的恰当性。这样做会让你受益匪浅。</p>
<p>一些值得遵循的规则包括：</p>
<p>使用易于理解的名称，例如userName或shoppingCart。<br>除非你清楚自己在做什么，否则请避免使用缩写或简称，例如a、b和c。<br>变量名应尽可能简洁明了，并尽可能具有描述性。例如，<code>a</code>data和 <code>b</code>就是糟糕的变量value名，它们没有任何意义。只有当代码上下文能够非常清晰地表明变量引用的是哪个数据或值时，才可以使用这类变量名。<br>在团队内部以及你们自己心中达成共识。如果网站访问者被称为“用户”，那么我们应该用其他名称来命名相关的变量currentUser，而newUser不是用“用户”或currentVisitor“访客newManInTown”。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>js有8种数据类型</p>
<ol>
<li><p>数字</p>
</li>
<li><p>大数字</p>
</li>
<li><p>字符串</p>
</li>
<li><p>布尔值</p>
</li>
<li><p>null值<br>在 JavaScript 中，null它不像其他一些语言那样是“指向不存在对象的引用”或“空指针”。<br>它只是一个特殊值，表示“无”、“空”或“值未知”。<br>上面的代码表明该值age未知。</p>
</li>
<li><p>未定义undefined<br>其含义undefined是“未赋值”。</p>
</li>
</ol>
<p>如果一个变量已声明但未赋值，则其值为undefined</p>
<ol start="7">
<li>object</li>
<li>typeof运算符<br>该typeof运算符返回操作数的类型。当我们想要区别处理不同类型的值，或者只是想进行快速检查时，它非常有用。</li>
</ol>
<p>调用该函数会typeof x返回一个包含类型名称的字符串</p>
<p>JavaScript 中有 8 种基本数据类型。</p>
<p>七种基本数据类型：<br>number对于任何类型的数字：整数或浮点数，整数受限制。±(253-1)<br>bigint对于任意长度的整数。<br>string对于字符串而言，一个字符串可以包含零个或多个字符，没有单独的单字符类型。<br>boolean为了true&#x2F; false。<br>null对于未知值——具有单个值的独立类型null。<br>undefined对于未赋值——具有单个值的独立类型undefined。<br>symbol用于唯一标识符。</p>
<p>还有一种非原始数据类型：<br>object适用于更复杂的数据结构。<br>该typeof运算符允许我们查看变量中存储的是哪种类型。</p>
<p>通常用作typeof x，但typeof(x)也可以使用。<br>返回一个包含类型名称的字符串，例如”string”。<br>对于null返回值”object”——这是语言上的错误，它实际上并不是一个对象。</p>
<h1 id="switch-和if的区别是什么，在js中"><a href="#switch-和if的区别是什么，在js中" class="headerlink" title="switch 和if的区别是什么，在js中"></a>switch 和if的区别是什么，在js中</h1><p>在 JavaScript 中，<code>switch</code> 和 <code>if</code> 都是<strong>条件判断语句</strong>，核心目的是根据不同条件执行不同代码，但两者的<strong>判断逻辑、使用场景、执行机制</strong>有显著区别，选择时需结合具体需求。以下是详细对比：</p>
<h3 id="一、核心区别总览"><a href="#一、核心区别总览" class="headerlink" title="一、核心区别总览"></a>一、核心区别总览</h3><p>| 对比维度         | <code>if</code> 语句                                  | <code>switch</code> 语句                              |<br>| <strong>判断逻辑</strong>     | 基于「布尔条件表达式」（true&#x2F;false）判断    | 基于「表达式的值」与 <code>case</code> 进行「全等匹配（&#x3D;&#x3D;&#x3D;）」 |<br>| <strong>适用场景</strong>     | 复杂条件（范围、多表达式组合）、少量分支    | 单值匹配（固定选项）、多分支（可读性更优） |<br>| <strong>执行流程</strong>     | 顺序判断，满足一个条件后直接跳出（除非无 <code>else if</code>） | 匹配 <code>case</code> 后执行，需 <code>break</code> 终止（否则穿透） |<br>| <strong>灵活性</strong>       | 极高（支持任意布尔逻辑：<code>&amp;&amp;</code>&#x2F;<code>||</code>&#x2F;<code>&gt;</code>&#x2F;<code>&lt;</code> 等） | 有限（仅支持「值全等匹配」，不支持范围判断） |<br>| <strong>可读性</strong>       | 分支少&#x2F;条件复杂时清晰，分支多时冗余        | 分支多时更简洁（结构化展示选项）            |<br>| <strong>性能</strong>         | 分支越多，判断效率越低（逐个校验）          | 分支较多时可能更优（引擎可能优化为查找表） |</p>
<h3 id="二、关键差异详解（附代码示例）"><a href="#二、关键差异详解（附代码示例）" class="headerlink" title="二、关键差异详解（附代码示例）"></a>二、关键差异详解（附代码示例）</h3><h4 id="1-判断逻辑：「布尔条件」vs「值全等匹配」"><a href="#1-判断逻辑：「布尔条件」vs「值全等匹配」" class="headerlink" title="1. 判断逻辑：「布尔条件」vs「值全等匹配」"></a>1. 判断逻辑：「布尔条件」vs「值全等匹配」</h4><p><code>if</code> 的核心是<strong>判断条件是否为 true</strong>，条件可以是任意布尔表达式（范围、多条件组合等）；<br><code>switch</code> 的核心是<strong>将「表达式结果」与「case 值」做全等比较（&#x3D;&#x3D;&#x3D;）</strong>，必须类型和值都一致才匹配。</p>
<h5 id="示例1：范围判断（只能用-if）"><a href="#示例1：范围判断（只能用-if）" class="headerlink" title="示例1：范围判断（只能用 if）"></a>示例1：范围判断（只能用 <code>if</code>）</h5><p>需求：根据成绩分级（90+优秀、80+良好、70+及格、否则不及格）</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> score = <span class="hljs-number">85</span>;<br><br><span class="hljs-comment">// if 可以直接写范围条件</span><br><span class="hljs-keyword">if</span> (score &gt;= <span class="hljs-number">90</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;优秀&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (score &gt;= <span class="hljs-number">80</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;良好&quot;</span>); <span class="hljs-comment">// 执行</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (score &gt;= <span class="hljs-number">70</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;及格&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;不及格&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// switch 无法直接写范围，只能强行枚举值（极冗余，不推荐）</span><br><span class="hljs-keyword">switch</span> (<span class="hljs-literal">true</span>) &#123; <span class="hljs-comment">// 表达式为 true，case 需是布尔值</span><br>  <span class="hljs-keyword">case</span> score &gt;= <span class="hljs-number">90</span>:<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;优秀&quot;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> score &gt;= <span class="hljs-number">80</span>:<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;良好&quot;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-comment">// ... 省略其他 case</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<h5 id="示例2：固定值匹配（switch-更简洁）"><a href="#示例2：固定值匹配（switch-更简洁）" class="headerlink" title="示例2：固定值匹配（switch 更简洁）"></a>示例2：固定值匹配（<code>switch</code> 更简洁）</h5><p>需求：根据状态码提示信息（200&#x3D;成功、404&#x3D;未找到、500&#x3D;服务器错误）</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> statusCode = <span class="hljs-number">404</span>;<br><br><span class="hljs-comment">// if 写法（分支多了会冗余）</span><br><span class="hljs-keyword">if</span> (statusCode === <span class="hljs-number">200</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;请求成功&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (statusCode === <span class="hljs-number">404</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;资源未找到&quot;</span>); <span class="hljs-comment">// 执行</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (statusCode === <span class="hljs-number">500</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;服务器错误&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;未知错误&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// switch 写法（结构化展示，更清晰）</span><br><span class="hljs-keyword">switch</span> (statusCode) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">200</span>:<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;请求成功&quot;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">404</span>:<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;资源未找到&quot;</span>); <span class="hljs-comment">// 执行</span><br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">500</span>:<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;服务器错误&quot;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-attr">default</span>: <span class="hljs-comment">// 无匹配时执行（类似 if 的 else）</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;未知错误&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h4 id="2-执行流程：「顺序跳出」vs「穿透特性」"><a href="#2-执行流程：「顺序跳出」vs「穿透特性」" class="headerlink" title="2. 执行流程：「顺序跳出」vs「穿透特性」"></a>2. 执行流程：「顺序跳出」vs「穿透特性」</h4><ul>
<li><code>if</code> 语句：一旦某个 <code>if</code>&#x2F;<code>else if</code> 条件成立，执行对应代码后<strong>直接跳出整个 if 结构</strong>（无需额外操作）；  </li>
<li><code>switch</code> 语句：匹配到 <code>case</code> 后，会<strong>继续执行后续所有 case</strong>（直到遇到 <code>break</code> 或 <code>return</code>），这就是「穿透特性」（可利用但需谨慎）。</li>
</ul>
<h5 id="示例3：switch-的穿透特性（双刃剑）"><a href="#示例3：switch-的穿透特性（双刃剑）" class="headerlink" title="示例3：switch 的穿透特性（双刃剑）"></a>示例3：switch 的穿透特性（双刃剑）</h5><p>需求：12&#x2F;1&#x2F;2 月是冬季，3&#x2F;4&#x2F;5 月是春季（利用穿透减少重复代码）</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> month = <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">switch</span> (month) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">12</span>:<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-comment">// 匹配 12、1、2 时都会执行下面的代码（穿透）</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;冬季&quot;</span>);<br>    <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 终止穿透</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;春季&quot;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-comment">// ... 其他季节</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>⚠️ 注意：如果忘记写 <code>break</code>，会导致代码“穿透”到下一个 <code>case</code> 执行（例如上面去掉 <code>case 2</code> 后的 <code>break</code>，会继续执行 <code>case 3</code> 的逻辑），这可能是 bug 来源，也可能是刻意优化。</p>
<h4 id="3-灵活性与使用场景"><a href="#3-灵活性与使用场景" class="headerlink" title="3. 灵活性与使用场景"></a>3. 灵活性与使用场景</h4><ul>
<li><p>用 <code>if</code> 的场景：</p>
<ul>
<li>条件是「范围」（如 <code>age &gt; 18</code>、<code>score &gt;= 60 &amp;&amp; score &lt; 80</code>）；</li>
<li>条件是「多表达式组合」（如 <code>user.type === &#39;admin&#39; &amp;&amp; user.status === &#39;active&#39;</code>）；</li>
<li>分支数量少（1-3 个），条件复杂。</li>
</ul>
</li>
<li><p>用 <code>switch</code> 的场景：</p>
<ul>
<li>条件是「单值匹配」（如状态码、类型枚举、下拉框选项）；</li>
<li>分支数量多（4 个以上），需要结构化展示（比一堆 <code>else if</code> 更易读）；</li>
<li>需利用「穿透特性」减少重复代码（如多个值对应同一逻辑）。</li>
</ul>
</li>
</ul>
<h3 id="三、补充细节"><a href="#三、补充细节" class="headerlink" title="三、补充细节"></a>三、补充细节</h3><ol>
<li><p><code>switch</code> 的「全等匹配」：<br><code>case</code> 与表达式的匹配是 <code>===</code>（严格相等），类型不同会匹配失败。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> x = <span class="hljs-string">&quot;1&quot;</span>;<br><span class="hljs-keyword">switch</span> (x) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;数字1&quot;</span>); <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 不匹配（字符串 vs 数字）</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;1&quot;</span>: <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;字符串1&quot;</span>); <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 匹配</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
</li>
<li><p><code>default</code> 的位置：<br><code>default</code> 是「默认分支」（无匹配时执行），可以放在任意位置（不一定在最后），但建议放在末尾，且需加 <code>break</code>（否则会穿透）。</p>
</li>
<li><p><code>switch</code> 的表达式支持任意类型：<br>表达式可以是数字、字符串、布尔值、甚至函数调用（只要返回一个值），例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">switch</span> (<span class="hljs-title function_">getUserType</span>()) &#123; <span class="hljs-comment">// getUserType() 返回 &#x27;admin&#x27;/&#x27;user&#x27;/&#x27;guest&#x27;</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;admin&#x27;</span>: <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;user&#x27;</span>: <span class="hljs-comment">// ...</span><br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li>
</ol>
<h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>| 选择依据               | 推荐用       |<br>| 范围判断&#x2F;多条件组合    | <code>if</code>         |<br>| 单值匹配&#x2F;多分支        | <code>switch</code>     |<br>| 分支少（1-3个）        | <code>if</code>         |<br>| 分支多（4个以上）      | <code>switch</code>     |<br>| 需利用穿透特性         | <code>switch</code>     |</p>
<p>简单记：<strong>复杂条件用 if，固定选项用 switch</strong>，核心是让代码更易读、更易维护。</p>
<h1 id="异步编程（async-await）是什么？在js中"><a href="#异步编程（async-await）是什么？在js中" class="headerlink" title="异步编程（async&#x2F;await）是什么？在js中"></a>异步编程（async&#x2F;await）是什么？在js中</h1><p>在 JavaScript 中，<strong><code>async/await</code> 是基于 Promise 的「语法糖」</strong>，核心目的是让异步代码的写法更简洁、更接近同步代码的逻辑，同时解决了 Promise 链（<code>.then()</code> 嵌套）可能出现的冗余问题，让异步流程更易读、易调试。</p>
<p>要理解 <code>async/await</code>，首先要明确一个前提：<strong>它没有改变 JS 异步编程的本质（依然是基于事件循环、非阻塞），只是简化了语法</strong>，底层仍然依赖 Promise 实现。</p>
<h3 id="一、先搞懂：为什么需要-async-await？"><a href="#一、先搞懂：为什么需要-async-await？" class="headerlink" title="一、先搞懂：为什么需要 async/await？"></a>一、先搞懂：为什么需要 <code>async/await</code>？</h3><p>在 <code>async/await</code> 出现前，JS 异步编程主要靠「回调函数」和「Promise」：</p>
<ul>
<li>回调函数：容易出现「回调地狱」（嵌套层级过深，代码可读性差）；</li>
<li>Promise：通过 <code>.then()</code> 链式调用解决了回调地狱，但多个异步操作串行时，<code>.then()</code> 链依然会显得冗长，逻辑不够直观。</li>
</ul>
<p><code>async/await</code> 正是为了解决这个问题——让异步代码像同步代码一样「线性书写」，逻辑更清晰。</p>
<h4 id="示例对比：Promise-vs-async-await"><a href="#示例对比：Promise-vs-async-await" class="headerlink" title="示例对比：Promise  vs  async&#x2F;await"></a>示例对比：Promise  vs  async&#x2F;await</h4><p>需求：先请求用户信息，再根据用户 ID 请求用户订单（两个异步操作串行）</p>
<h5 id="1-Promise-写法（链式调用）"><a href="#1-Promise-写法（链式调用）" class="headerlink" title="1. Promise 写法（链式调用）"></a>1. Promise 写法（链式调用）</h5><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 模拟异步请求：获取用户信息</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getUser</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(&#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;张三&quot;</span> &#125;), <span class="hljs-number">1000</span>);<br>  &#125;);<br>&#125;<br><br><span class="hljs-comment">// 模拟异步请求：根据用户ID获取订单</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getOrders</span>(<span class="hljs-params">userId</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>([&#123; <span class="hljs-attr">id</span>: <span class="hljs-number">101</span>, <span class="hljs-attr">goods</span>: <span class="hljs-string">&quot;手机&quot;</span> &#125;]), <span class="hljs-number">1000</span>);<br>  &#125;);<br>&#125;<br><br><span class="hljs-comment">// Promise 链式调用</span><br><span class="hljs-title function_">getUser</span>()<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;用户信息：&quot;</span>, user);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">getOrders</span>(user.<span class="hljs-property">id</span>); <span class="hljs-comment">// 传递用户ID给下一个异步操作</span><br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">orders</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;用户订单：&quot;</span>, orders);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;出错了：&quot;</span>, error); <span class="hljs-comment">// 捕获所有异步错误</span><br>  &#125;);<br></code></pre></div></td></tr></table></figure>

<h5 id="2-async-await-写法（同步风格）"><a href="#2-async-await-写法（同步风格）" class="headerlink" title="2. async&#x2F;await 写法（同步风格）"></a>2. async&#x2F;await 写法（同步风格）</h5><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 同样的两个异步函数（返回Promise）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getUser</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/* ... 同上 ... */</span> &#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getOrders</span>(<span class="hljs-params">userId</span>) &#123; <span class="hljs-comment">/* ... 同上 ... */</span> &#125;<br><br><span class="hljs-comment">// 用 async 修饰函数，内部可使用 await</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getUser</span>(); <span class="hljs-comment">// 暂停执行，等待Promise成功 resolve</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;用户信息：&quot;</span>, user);<br>    <br>    <span class="hljs-keyword">const</span> orders = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getOrders</span>(user.<span class="hljs-property">id</span>); <span class="hljs-comment">// 基于上一个异步结果，继续等待</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;用户订单：&quot;</span>, orders);<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;出错了：&quot;</span>, error); <span class="hljs-comment">// 捕获所有 await 抛出的错误</span><br>  &#125;<br>&#125;<br><br><span class="hljs-title function_">fetchData</span>(); <span class="hljs-comment">// 调用异步函数</span><br></code></pre></div></td></tr></table></figure>

<p>可以明显看到：<code>async/await</code> 去掉了 <code>.then()</code> 链，代码逻辑和同步代码完全一致，可读性大幅提升。</p>
<h3 id="二、核心语法：async-和-await-各自的作用"><a href="#二、核心语法：async-和-await-各自的作用" class="headerlink" title="二、核心语法：async 和 await 各自的作用"></a>二、核心语法：<code>async</code> 和 <code>await</code> 各自的作用</h3><p><code>async/await</code> 是成对出现的（<code>await</code> 必须在 <code>async</code> 函数内使用），两者分工明确：</p>
<h4 id="1-async-关键字"><a href="#1-async-关键字" class="headerlink" title="1. async 关键字"></a>1. <code>async</code> 关键字</h4><ul>
<li>作用：修饰一个函数，使其成为「异步函数」；</li>
<li>返回值：异步函数的返回值会被自动包装成一个 <code>Promise</code>：<ul>
<li>如果函数内返回一个普通值（如数字、对象），则返回 <code>Promise.resolve(普通值)</code>；</li>
<li>如果函数内抛出错误（如 <code>throw new Error()</code>），则返回 <code>Promise.reject(错误)</code>；</li>
<li>如果函数内直接返回一个 <code>Promise</code>，则直接返回该 <code>Promise</code>（不额外包装）。</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 1. 返回普通值 → 包装成 resolved Promise</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn1</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>&#125;<br><span class="hljs-title function_">fn1</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)); <span class="hljs-comment">// 输出：hello</span><br><br><span class="hljs-comment">// 2. 抛出错误 → 包装成 rejected Promise</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn2</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;出错了&quot;</span>);<br>&#125;<br><span class="hljs-title function_">fn2</span>().<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>)); <span class="hljs-comment">// 输出：出错了</span><br><br><span class="hljs-comment">// 3. 返回 Promise → 直接返回该 Promise</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn3</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;直接返回Promise&quot;</span>);<br>&#125;<br><span class="hljs-title function_">fn3</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)); <span class="hljs-comment">// 输出：直接返回Promise</span><br></code></pre></div></td></tr></table></figure>

<h4 id="2-await-关键字"><a href="#2-await-关键字" class="headerlink" title="2. await 关键字"></a>2. <code>await</code> 关键字</h4><ul>
<li>作用：暂停 <code>async</code> 函数的执行，等待后面的「Promise 决议」（成功或失败）；</li>
<li>只能用在 <code>async</code> 函数内（普通函数中使用会报错）；</li>
<li>等待结果：<ul>
<li>如果 <code>await</code> 后面是一个 <code>Promise</code>：会等待该 Promise 成功（<code>resolve</code>），并返回 <code>resolve</code> 的值；如果 Promise 失败（<code>reject</code>），则会抛出异常，需要用 <code>try/catch</code> 捕获；</li>
<li>如果 <code>await</code> 后面是一个非 Promise 值（如数字、字符串）：会直接返回该值（相当于 <code>await Promise.resolve(非Promise值)</code>）。</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">testAwait</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 等待 Promise 成功</span><br>  <span class="hljs-keyword">const</span> res1 = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;成功的值&quot;</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res1); <span class="hljs-comment">// 输出：成功的值</span><br><br>  <span class="hljs-comment">// 等待非 Promise 值（自动包装成 resolved Promise）</span><br>  <span class="hljs-keyword">const</span> res2 = <span class="hljs-keyword">await</span> <span class="hljs-number">123</span>;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res2); <span class="hljs-comment">// 输出：123</span><br><br>  <span class="hljs-comment">// 等待 Promise 失败（会抛出异常，需用 try/catch 捕获）</span><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> res3 = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;失败的原因&quot;</span>);<br>  &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err); <span class="hljs-comment">// 输出：失败的原因</span><br>  &#125;<br>&#125;<br><br><span class="hljs-title function_">testAwait</span>();<br></code></pre></div></td></tr></table></figure>


<h3 id="三、关键特性：错误处理"><a href="#三、关键特性：错误处理" class="headerlink" title="三、关键特性：错误处理"></a>三、关键特性：错误处理</h3><p>由于 <code>await</code> 会把 Promise 的 <code>reject</code> 转化为「异常」，因此 <strong><code>async/await</code> 必须配合 <code>try/catch</code> 处理错误</strong>，否则未捕获的异常会导致程序崩溃（或被全局错误监听捕获）。</p>
<h4 id="两种错误处理场景："><a href="#两种错误处理场景：" class="headerlink" title="两种错误处理场景："></a>两种错误处理场景：</h4><ol>
<li><strong>多个异步操作共享错误处理</strong>（一个出错就终止）：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getUser</span>(); <span class="hljs-comment">// 若失败，直接进入 catch</span><br>    <span class="hljs-keyword">const</span> orders = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getOrders</span>(user.<span class="hljs-property">id</span>); <span class="hljs-comment">// 上一步失败则不会执行</span><br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;任意一个异步操作出错：&quot;</span>, error);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<ol start="2">
<li><strong>多个异步操作独立错误处理</strong>（一个出错不影响其他）：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 每个 await 单独 try/catch</span><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getUser</span>();<br>  &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;获取用户失败：&quot;</span>, err);<br>  &#125;<br><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> orders = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getOrders</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 假设ID固定，即使上一步失败也执行</span><br>  &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;获取订单失败：&quot;</span>, err);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>


<h3 id="四、常见使用场景"><a href="#四、常见使用场景" class="headerlink" title="四、常见使用场景"></a>四、常见使用场景</h3><h4 id="1-串行异步操作（按顺序执行）"><a href="#1-串行异步操作（按顺序执行）" class="headerlink" title="1. 串行异步操作（按顺序执行）"></a>1. 串行异步操作（按顺序执行）</h4><p>多个异步操作依赖前一个的结果（如先登录获取 token，再用 token 请求数据），<code>async/await</code> 比 <code>.then()</code> 更直观：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">loginAndFetch</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> token = <span class="hljs-keyword">await</span> <span class="hljs-title function_">login</span>(<span class="hljs-string">&quot;用户名&quot;</span>, <span class="hljs-string">&quot;密码&quot;</span>); <span class="hljs-comment">// 第一步：登录获取token</span><br>    <span class="hljs-keyword">const</span> userInfo = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchUserInfo</span>(token); <span class="hljs-comment">// 第二步：用token获取用户信息</span><br>    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchDataByUser</span>(userInfo.<span class="hljs-property">id</span>); <span class="hljs-comment">// 第三步：用用户ID获取数据</span><br>    <span class="hljs-keyword">return</span> data;<br>  &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;流程出错：&quot;</span>, err);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h4 id="2-并行异步操作（同时执行，提高效率）"><a href="#2-并行异步操作（同时执行，提高效率）" class="headerlink" title="2. 并行异步操作（同时执行，提高效率）"></a>2. 并行异步操作（同时执行，提高效率）</h4><p>多个异步操作互不依赖，需要同时执行（如同时请求商品列表和分类列表），可配合 <code>Promise.all()</code> 使用（<code>await</code> 等待所有 Promise 完成）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchParallel</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 同时启动两个异步请求（并行执行，总耗时取最长的那个）</span><br>    <span class="hljs-keyword">const</span> promise1 = <span class="hljs-title function_">fetchGoods</span>(); <span class="hljs-comment">// 请求商品列表</span><br>    <span class="hljs-keyword">const</span> promise2 = <span class="hljs-title function_">fetchCategories</span>(); <span class="hljs-comment">// 请求分类列表</span><br><br>    <span class="hljs-comment">// 等待两个请求都完成，返回结果数组</span><br>    <span class="hljs-keyword">const</span> [goods, categories] = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([promise1, promise2]);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;商品列表：&quot;</span>, goods);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;分类列表：&quot;</span>, categories);<br>  &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;任意一个请求失败：&quot;</span>, err); <span class="hljs-comment">// 只要有一个失败，就进入catch</span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h4 id="3-可选异步操作（失败不影响主流程）"><a href="#3-可选异步操作（失败不影响主流程）" class="headerlink" title="3. 可选异步操作（失败不影响主流程）"></a>3. 可选异步操作（失败不影响主流程）</h4><p>如果某个异步操作失败后，主流程仍需继续，可使用 <code>Promise.catch()</code> 单独处理该操作的错误：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchWithFallback</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 即使 fetchRecommend 失败，也不会影响主流程</span><br>  <span class="hljs-keyword">const</span> recommend = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchRecommend</span>().<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-string">&quot;默认推荐内容&quot;</span>);<br>  <span class="hljs-keyword">const</span> goods = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchGoods</span>(); <span class="hljs-comment">// 正常执行</span><br><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;推荐内容：&quot;</span>, recommend);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;商品列表：&quot;</span>, goods);<br>&#125;<br></code></pre></div></td></tr></table></figure>


<h3 id="五、注意事项（避坑点）"><a href="#五、注意事项（避坑点）" class="headerlink" title="五、注意事项（避坑点）"></a>五、注意事项（避坑点）</h3><ol>
<li><strong><code>await</code> 不能在普通函数中使用</strong>：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 错误：普通函数内不能用 await</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchData</span>(); <span class="hljs-comment">// 语法错误</span><br>&#125;<br><br><span class="hljs-comment">// 正确：必须用 async 修饰函数</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchData</span>();<br>&#125;<br></code></pre></div></td></tr></table></figure>

<ol start="2">
<li><strong><code>async</code> 函数不会阻塞主线程</strong>：<br><code>await</code> 只会暂停当前 <code>async</code> 函数的执行，不会阻塞整个 JS 主线程（其他同步代码或异步任务仍会正常执行）：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;开始&quot;</span>);<br>  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">1000</span>)); <span class="hljs-comment">// 暂停1秒</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;async函数内继续执行&quot;</span>);<br>&#125;<br><br><span class="hljs-title function_">fn</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;主线程同步代码（不会被阻塞）&quot;</span>);<br><br><span class="hljs-comment">// 输出顺序：</span><br><span class="hljs-comment">// 开始 → 主线程同步代码（不会被阻塞） → （1秒后）async函数内继续执行</span><br></code></pre></div></td></tr></table></figure>

<ol start="3">
<li><strong><code>Promise.all()</code> 的「快速失败」特性</strong>：<br>如果 <code>Promise.all()</code> 中的任意一个 Promise 失败，整个 <code>Promise.all()</code> 会立即 reject，其他未完成的 Promise 仍会继续执行，但结果会被忽略。如果需要「所有 Promise 都执行完，不管成功失败」，可使用 <code>Promise.allSettled()</code>：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchAllSettled</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> promise1 = <span class="hljs-title function_">fetchGoods</span>();<br>  <span class="hljs-keyword">const</span> promise2 = <span class="hljs-title function_">fetchInvalidUrl</span>(); <span class="hljs-comment">// 故意请求错误地址</span><br><br>  <span class="hljs-comment">// 等待所有 Promise 完成（无论成功/失败）</span><br>  <span class="hljs-keyword">const</span> results = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>([promise1, promise2]);<br><br>  <span class="hljs-comment">// 遍历结果，分别处理成功和失败</span><br>  results.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">result, index</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (result.<span class="hljs-property">status</span> === <span class="hljs-string">&quot;fulfilled&quot;</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`第<span class="hljs-subst">$&#123;index+<span class="hljs-number">1</span>&#125;</span>个请求成功：`</span>, result.<span class="hljs-property">value</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`第<span class="hljs-subst">$&#123;index+<span class="hljs-number">1</span>&#125;</span>个请求失败：`</span>, result.<span class="hljs-property">reason</span>);<br>    &#125;<br>  &#125;);<br>&#125;<br></code></pre></div></td></tr></table></figure>


<h3 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h3><ol>
<li><strong>本质</strong>：<code>async/await</code> 是 Promise 的语法糖，不改变 JS 异步本质；</li>
<li><strong>核心优势</strong>：让异步代码像同步代码一样线性书写，可读性、可维护性远超回调和 Promise 链；</li>
<li><strong>使用规则</strong>：<ul>
<li><code>async</code> 修饰函数，返回 Promise；</li>
<li><code>await</code> 只能在 <code>async</code> 函数内使用，等待 Promise 决议；</li>
<li>必须用 <code>try/catch</code> 处理 <code>await</code> 可能抛出的错误；</li>
</ul>
</li>
<li><strong>适用场景</strong>：<ul>
<li>串行异步操作（依赖前一个结果）；</li>
<li>并行异步操作（配合 <code>Promise.all()</code>）；</li>
<li>复杂异步流程（多分支、条件判断）。</li>
</ul>
</li>
</ol>
<p>如今，<code>async/await</code> 已成为 JS 异步编程的「最佳实践」，几乎完全替代了复杂的 <code>.then()</code> 链，是前端开发中必须掌握的核心语法。</p>
<h1 id="回调地狱是什么？"><a href="#回调地狱是什么？" class="headerlink" title="回调地狱是什么？"></a>回调地狱是什么？</h1><p>在 JavaScript 中，<strong>回调地狱（Callback Hell）</strong> 是指「异步操作依赖前一个异步操作结果」时，使用回调函数嵌套导致的「代码层级过深、可读性差、维护困难」的现象。</p>
<p>它的核心原因是：JS 异步操作（如定时器、网络请求、文件读写）默认通过「回调函数」通知结果，当多个异步操作需要<strong>按顺序串行执行</strong>（后一个操作依赖前一个的结果）时，只能把后一个回调嵌套在前一个回调的内部，最终形成「金字塔式」的嵌套结构。</p>
<h3 id="一、直观感受：回调地狱长什么样？"><a href="#一、直观感受：回调地狱长什么样？" class="headerlink" title="一、直观感受：回调地狱长什么样？"></a>一、直观感受：回调地狱长什么样？</h3><p>举个实际场景：<br>需求是「先获取用户信息 → 再根据用户 ID 获取订单 → 最后根据订单 ID 获取物流信息」，三个异步操作必须按顺序执行（后一个依赖前一个的结果）。</p>
<h4 id="回调地狱示例（嵌套层级深）"><a href="#回调地狱示例（嵌套层级深）" class="headerlink" title="回调地狱示例（嵌套层级深）"></a>回调地狱示例（嵌套层级深）</h4><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 模拟异步请求：获取用户信息（回调函数接收结果）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getUser</span>(<span class="hljs-params">callback</span>) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> user = &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;张三&quot;</span> &#125;;<br>    <span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>, user); <span class="hljs-comment">// 异步完成后调用回调，传递结果</span><br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-comment">// 模拟异步请求：根据用户ID获取订单</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getOrders</span>(<span class="hljs-params">userId, callback</span>) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> orders = [&#123; <span class="hljs-attr">id</span>: <span class="hljs-number">101</span>, <span class="hljs-attr">goods</span>: <span class="hljs-string">&quot;手机&quot;</span>, <span class="hljs-attr">userId</span>: <span class="hljs-number">1</span> &#125;];<br>    <span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>, orders[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 取第一个订单</span><br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-comment">// 模拟异步请求：根据订单ID获取物流</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getLogistics</span>(<span class="hljs-params">orderId, callback</span>) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> logistics = &#123; <span class="hljs-attr">orderId</span>: <span class="hljs-number">101</span>, <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;已发货&quot;</span> &#125;;<br>    <span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>, logistics);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-comment">// 回调嵌套实现串行逻辑（回调地狱出现！）</span><br><span class="hljs-title function_">getUser</span>(<span class="hljs-function">(<span class="hljs-params">err, user</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;获取用户失败：&quot;</span>, err);<br>  <br>  <span class="hljs-comment">// 第一个回调内部嵌套第二个异步操作</span><br>  <span class="hljs-title function_">getOrders</span>(user.<span class="hljs-property">id</span>, <span class="hljs-function">(<span class="hljs-params">err, order</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;获取订单失败：&quot;</span>, err);<br>    <br>    <span class="hljs-comment">// 第二个回调内部嵌套第三个异步操作</span><br>    <span class="hljs-title function_">getLogistics</span>(order.<span class="hljs-property">id</span>, <span class="hljs-function">(<span class="hljs-params">err, logistics</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;获取物流失败：&quot;</span>, err);<br>      <br>      <span class="hljs-comment">// 三层嵌套后，才拿到最终结果</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;用户：&quot;</span>, user.<span class="hljs-property">name</span>);<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;订单：&quot;</span>, order.<span class="hljs-property">goods</span>);<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;物流：&quot;</span>, logistics.<span class="hljs-property">status</span>);<br>    &#125;);<br>  &#125;);<br>&#125;);<br></code></pre></div></td></tr></table></figure>

<p>这段代码的问题很明显：</p>
<ul>
<li>嵌套层级越来越深（上面是 3 层，实际场景可能 5 层以上），形成「右缩进金字塔」；</li>
<li>代码逻辑被切割在不同的回调函数内，阅读时需要「跳着看」，理解成本高；</li>
<li>维护困难：如果要在中间加一个步骤（比如获取用户后校验权限），需要修改多层嵌套结构；</li>
<li>错误处理分散：每个回调都要单独处理 <code>err</code>，冗余且容易遗漏。</li>
</ul>
<h3 id="二、回调地狱的核心危害"><a href="#二、回调地狱的核心危害" class="headerlink" title="二、回调地狱的核心危害"></a>二、回调地狱的核心危害</h3><ol>
<li><strong>可读性极差</strong>：嵌套层级越深，代码越像「金字塔」，后续开发者需要逐层梳理逻辑关系；</li>
<li><strong>维护成本高</strong>：修改某一层逻辑时，可能需要改动外层或内层的回调，容易引发 bug；</li>
<li><strong>错误处理繁琐</strong>：每个异步操作的错误都要单独捕获（如上面的 <code>if (err)</code>），无法统一处理；</li>
<li><strong>调试困难</strong>：报错时的调用栈会被回调函数割裂，难以定位是哪一层异步操作出了问题。</li>
</ol>
<h3 id="三、怎么解决回调地狱？"><a href="#三、怎么解决回调地狱？" class="headerlink" title="三、怎么解决回调地狱？"></a>三、怎么解决回调地狱？</h3><p>回调地狱的本质是「回调嵌套导致的流程碎片化」，解决思路是「让异步流程扁平化」，JS 中主要有两种主流方案：</p>
<h4 id="方案-1：使用-Promise-链式调用（替代嵌套回调）"><a href="#方案-1：使用-Promise-链式调用（替代嵌套回调）" class="headerlink" title="方案 1：使用 Promise 链式调用（替代嵌套回调）"></a>方案 1：使用 Promise 链式调用（替代嵌套回调）</h4><p>Promise 是为了解决回调地狱而生的异步规范，它通过 <code>.then()</code> 方法将异步操作串联起来，避免了嵌套。</p>
<p>改造上面的示例（先把回调函数改成返回 Promise）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 1. 把回调函数改成返回 Promise</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getUser</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(&#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;张三&quot;</span> &#125;), <span class="hljs-number">1000</span>);<br>  &#125;);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getOrders</span>(<span class="hljs-params">userId</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(&#123; <span class="hljs-attr">id</span>: <span class="hljs-number">101</span>, <span class="hljs-attr">goods</span>: <span class="hljs-string">&quot;手机&quot;</span>, <span class="hljs-attr">userId</span>: <span class="hljs-number">1</span> &#125;), <span class="hljs-number">1000</span>);<br>  &#125;);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getLogistics</span>(<span class="hljs-params">orderId</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(&#123; <span class="hljs-attr">orderId</span>: <span class="hljs-number">101</span>, <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;已发货&quot;</span> &#125;), <span class="hljs-number">1000</span>);<br>  &#125;);<br>&#125;<br><br><span class="hljs-comment">// 2. Promise 链式调用（扁平化流程）</span><br><span class="hljs-title function_">getUser</span>()<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;用户：&quot;</span>, user.<span class="hljs-property">name</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">getOrders</span>(user.<span class="hljs-property">id</span>); <span class="hljs-comment">// 返回 Promise，衔接下一个 .then()</span><br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">order</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;订单：&quot;</span>, order.<span class="hljs-property">goods</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">getLogistics</span>(order.<span class="hljs-property">id</span>); <span class="hljs-comment">// 继续衔接</span><br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">logistics</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;物流：&quot;</span>, logistics.<span class="hljs-property">status</span>);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;出错了：&quot;</span>, err); <span class="hljs-comment">// 统一捕获所有异步错误（无需单独处理）</span><br>  &#125;);<br></code></pre></div></td></tr></table></figure>

<p>优势：</p>
<ul>
<li>嵌套层级消失，代码横向展开，逻辑线性化；</li>
<li>错误处理统一：所有 <code>.then()</code> 中的错误都会被末尾的 <code>.catch()</code> 捕获；</li>
<li>可读性比回调嵌套提升明显。</li>
</ul>
<h4 id="方案-2：使用-async-await（最简洁的方案）"><a href="#方案-2：使用-async-await（最简洁的方案）" class="headerlink" title="方案 2：使用 async&#x2F;await（最简洁的方案）"></a>方案 2：使用 async&#x2F;await（最简洁的方案）</h4><p><code>async/await</code> 是 Promise 的语法糖，能让异步代码完全像同步代码一样书写，是目前解决回调地狱的「最佳实践」。</p>
<p>改造上面的示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 复用上面返回 Promise 的三个函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getUser</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/* ... */</span> &#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getOrders</span>(<span class="hljs-params">userId</span>) &#123; <span class="hljs-comment">/* ... */</span> &#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getLogistics</span>(<span class="hljs-params">orderId</span>) &#123; <span class="hljs-comment">/* ... */</span> &#125;<br><br><span class="hljs-comment">// async 函数内使用 await 等待异步结果</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getUser</span>(); <span class="hljs-comment">// 等待用户信息（暂停，不阻塞主线程）</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;用户：&quot;</span>, user.<span class="hljs-property">name</span>);<br>    <br>    <span class="hljs-keyword">const</span> order = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getOrders</span>(user.<span class="hljs-property">id</span>); <span class="hljs-comment">// 等待订单（依赖用户ID）</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;订单：&quot;</span>, order.<span class="hljs-property">goods</span>);<br>    <br>    <span class="hljs-keyword">const</span> logistics = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getLogistics</span>(order.<span class="hljs-property">id</span>); <span class="hljs-comment">// 等待物流（依赖订单ID）</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;物流：&quot;</span>, logistics.<span class="hljs-property">status</span>);<br>  &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;出错了：&quot;</span>, err); <span class="hljs-comment">// 统一捕获所有错误</span><br>  &#125;<br>&#125;<br><br><span class="hljs-title function_">fetchData</span>();<br></code></pre></div></td></tr></table></figure>

<p>优势：</p>
<ul>
<li>代码完全线性化，和同步逻辑几乎一致，可读性最强；</li>
<li>错误处理更直观（<code>try/catch</code> 包裹所有异步操作）；</li>
<li>调试方便：断点可以像同步代码一样逐行执行，无需跳回调。</li>
</ul>
<h3 id="四、补充：避免回调地狱的其他小技巧"><a href="#四、补充：避免回调地狱的其他小技巧" class="headerlink" title="四、补充：避免回调地狱的其他小技巧"></a>四、补充：避免回调地狱的其他小技巧</h3><ol>
<li><strong>拆分函数</strong>：把嵌套的回调函数拆成独立的命名函数，即使使用回调，也能减少嵌套层级：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 拆分独立函数（避免嵌套）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleUser</span>(<span class="hljs-params">err, user</span>) &#123;<br>  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);<br>  <span class="hljs-title function_">getOrders</span>(user.<span class="hljs-property">id</span>, handleOrder); <span class="hljs-comment">// 调用下一个独立函数</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleOrder</span>(<span class="hljs-params">err, order</span>) &#123;<br>  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);<br>  <span class="hljs-title function_">getLogistics</span>(order.<span class="hljs-property">id</span>, handleLogistics);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleLogistics</span>(<span class="hljs-params">err, logistics</span>) &#123;<br>  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(logistics);<br>&#125;<br><br><span class="hljs-comment">// 初始调用（无嵌套）</span><br><span class="hljs-title function_">getUser</span>(handleUser);<br></code></pre></div></td></tr></table></figure>

<ol start="2">
<li><strong>使用工具库</strong>：早期还有 <code>async.js</code> 这类库专门处理异步流程，但现在 Promise + async&#x2F;await 已原生支持，基本无需依赖第三方库。</li>
</ol>
<h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><ul>
<li><strong>回调地狱是什么</strong>：异步回调嵌套导致的代码层级过深、可读性差、维护困难的现象；</li>
<li><strong>为什么会出现</strong>：多个串行异步操作依赖前一个结果，只能通过回调嵌套实现；</li>
<li><strong>怎么解决</strong>：核心是「流程扁平化」，优先使用 <code>async/await</code>（最简洁），其次是 Promise 链式调用；</li>
<li><strong>核心结论</strong>：回调地狱本身不是语法错误，而是代码设计问题，现代 JS 已通过 Promise 和 async&#x2F;await 完美解决，实际开发中应尽量避免直接使用嵌套回调。</li>
</ul>
<h1 id="是所有语言都存在回调地狱的问题，还是只有javascript存在？"><a href="#是所有语言都存在回调地狱的问题，还是只有javascript存在？" class="headerlink" title="是所有语言都存在回调地狱的问题，还是只有javascript存在？"></a>是所有语言都存在回调地狱的问题，还是只有javascript存在？</h1><p>你的两个疑问其实是“Solidity开发是否必须精通JS”和“回调地狱的语言边界”，这两个点都需要结合实际开发场景拆解，结论先明确：<strong>Solidity开发不需要“精通”JS（有替代方案），回调地狱也不是JS独有——它是“异步回调嵌套”的通用问题，现在多数语言都有成熟解决方案</strong>。下面详细展开：</p>
<h3 id="一、先澄清：Solidity开发≠必须精通JavaScript"><a href="#一、先澄清：Solidity开发≠必须精通JavaScript" class="headerlink" title="一、先澄清：Solidity开发≠必须精通JavaScript"></a>一、先澄清：Solidity开发≠必须精通JavaScript</h3><p>你之所以有“必须精通JS”的错觉，是因为入门时接触的Truffle、Hardhat等工具默认用JS&#x2F;TS写测试脚本，但这只是“主流方案”，不是“唯一方案”：</p>
<h4 id="1-JS-TS的真实定位：“测试-工具链的常用语言”，而非“核心开发语言”"><a href="#1-JS-TS的真实定位：“测试-工具链的常用语言”，而非“核心开发语言”" class="headerlink" title="1. JS&#x2F;TS的真实定位：“测试&#x2F;工具链的常用语言”，而非“核心开发语言”"></a>1. JS&#x2F;TS的真实定位：“测试&#x2F;工具链的常用语言”，而非“核心开发语言”</h4><p>Solidity开发的核心是写合约（用Solidity），JS&#x2F;TS的作用主要是：</p>
<ul>
<li>写测试脚本（验证合约功能&#x2F;安全）；</li>
<li>写部署脚本（把合约部署到链上）；</li>
<li>写前端交互逻辑（比如DApp调用合约）。</li>
</ul>
<p>但这些工作对JS的要求是“熟练使用”（比如掌握异步、Promise、测试库API），而非“精通”（比如深入JS引擎、框架源码）——大部分场景下，掌握基础语法+测试工具（Hardhat&#x2F;Waffle）的使用即可。</p>
<h4 id="2-完全不用JS的替代方案：Foundry"><a href="#2-完全不用JS的替代方案：Foundry" class="headerlink" title="2. 完全不用JS的替代方案：Foundry"></a>2. 完全不用JS的替代方案：Foundry</h4><p>现在行业内（尤其是大厂、安全团队）越来越流行用 <strong>Foundry</strong> 开发测试，它的核心特点是：</p>
<ul>
<li>用Solidity写测试脚本（不用JS&#x2F;TS），直接用Solidity语法模拟合约交互、断言结果；</li>
<li>更贴近合约逻辑，测试效率更高（比如模拟攻击场景更直观）；</li>
<li>适合深度安全测试（比如模糊测试、形式化验证）。</li>
</ul>
<p>比如用Foundry测试“管理员才能暂停合约”，直接用Solidity写测试用例，完全不涉及JS：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">// Foundry测试示例（Solidity语法）<br>function testOnlyAdminCanPause() public &#123;<br>  // 普通用户调用暂停函数，预期失败<br>  vm.prank(user); // 模拟普通用户身份<br>  vm.expectRevert(&quot;Only admin&quot;); // 预期 revert 信息<br>  myContract.pause();<br><br>  // 管理员调用暂停函数，预期成功<br>  vm.prank(admin); // 模拟管理员身份<br>  myContract.pause();<br>  assertEq(myContract.paused(), true); // 断言结果<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>所以结论：<strong>Solidity开发的核心是Solidity本身，JS&#x2F;TS是“工具层语言”，可替代，无需精通</strong>——入门时可以先熟练JS+Hardhat，后续如果想侧重安全测试，再学Foundry即可。</p>
<h3 id="二、回调地狱：不是JS独有，是“异步回调嵌套”的通用问题"><a href="#二、回调地狱：不是JS独有，是“异步回调嵌套”的通用问题" class="headerlink" title="二、回调地狱：不是JS独有，是“异步回调嵌套”的通用问题"></a>二、回调地狱：不是JS独有，是“异步回调嵌套”的通用问题</h3><p>要搞懂这个问题，先明确“回调地狱”的本质：</p>
<h4 id="1-回调地狱的定义"><a href="#1-回调地狱的定义" class="headerlink" title="1. 回调地狱的定义"></a>1. 回调地狱的定义</h4><p>当需要连续执行多个<strong>异步操作</strong>（比如“先部署合约→再给合约转账→再调用合约函数”），且后一个操作依赖前一个的结果时，如果用“回调函数嵌套”的方式实现，就会出现代码层层缩进、可读性差、维护难的情况——这就是回调地狱。</p>
<p>它的核心是“<strong>异步+回调嵌套</strong>”，和语言无关，只要语言支持“异步回调”，就可能出现这个问题。</p>
<h4 id="2-哪些语言会有回调地狱？（分两类）"><a href="#2-哪些语言会有回调地狱？（分两类）" class="headerlink" title="2. 哪些语言会有回调地狱？（分两类）"></a>2. 哪些语言会有回调地狱？（分两类）</h4><h5 id="（1）有回调地狱风险的语言（支持异步回调，早期无更好方案）"><a href="#（1）有回调地狱风险的语言（支持异步回调，早期无更好方案）" class="headerlink" title="（1）有回调地狱风险的语言（支持异步回调，早期无更好方案）"></a>（1）有回调地狱风险的语言（支持异步回调，早期无更好方案）</h5><ul>
<li><strong>JavaScript&#x2F;TypeScript</strong>：最典型的是早期Node.js（比如用<code>fs.readFile</code>嵌套读取多个文件），但现在已经用<code>Promise</code>+<code>async/await</code>彻底解决了；</li>
<li><strong>Python</strong>：早期用<code>requests</code>+回调函数处理异步（比如爬虫异步请求），会出现嵌套问题，现在有<code>asyncio</code>+<code>await</code>；</li>
<li><strong>Java</strong>：早期用<code>Runnable</code>+<code>Handler</code>处理异步（比如Android开发），嵌套回调会导致“回调地狱”，现在用<code>CompletableFuture</code>+<code>lambda</code>解决；</li>
<li><strong>C#</strong>：早期用委托（Delegate）做异步回调，会有嵌套问题，现在用<code>Task</code>+<code>async/await</code>。</li>
</ul>
<p>举个JS早期的回调地狱例子（现在没人这么写了）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 早期Node.js读取文件的回调地狱</span><br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;file1.txt&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err1, data1</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (err1) <span class="hljs-keyword">throw</span> err1;<br>  fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;file2.txt&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err2, data2</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err2) <span class="hljs-keyword">throw</span> err2;<br>    fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;file3.txt&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err3, data3</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (err3) <span class="hljs-keyword">throw</span> err3;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data1 + data2 + data3); <span class="hljs-comment">// 三层嵌套，可读性差</span><br>    &#125;);<br>  &#125;);<br>&#125;);<br></code></pre></div></td></tr></table></figure>

<h5 id="（2）基本没有回调地狱的语言（两种情况）"><a href="#（2）基本没有回调地狱的语言（两种情况）" class="headerlink" title="（2）基本没有回调地狱的语言（两种情况）"></a>（2）基本没有回调地狱的语言（两种情况）</h5><ul>
<li><strong>本身是同步执行的语言</strong>：比如Solidity、Java（非异步场景）、Go（同步代码）——因为没有“异步操作”，自然不需要回调，也就不会有回调地狱；</li>
<li><strong>有原生异步方案（非回调嵌套）的语言</strong>：<ul>
<li>Go：用<code>goroutine</code>+<code>channel</code>处理异步，无需回调嵌套；</li>
<li>Rust：用<code>Future</code>+<code>async/await</code>，异步逻辑线性编写，无嵌套；</li>
<li>Solidity：合约执行是完全同步的（链上操作都是阻塞式的，比如转账、调用函数会立即返回结果），不存在“异步回调”，所以绝对不会有回调地狱；</li>
<li>PHP：早期以同步为主，现在支持<code>async/await</code>，但很少用回调嵌套。</li>
</ul>
</li>
</ul>
<h4 id="3-关键结论：回调地狱是“历史问题”，现在已被彻底解决"><a href="#3-关键结论：回调地狱是“历史问题”，现在已被彻底解决" class="headerlink" title="3. 关键结论：回调地狱是“历史问题”，现在已被彻底解决"></a>3. 关键结论：回调地狱是“历史问题”，现在已被彻底解决</h4><p>不管是JS还是其他语言，现在都不会再用“回调嵌套”的方式写异步代码，而是用更优雅的方案：</p>
<ul>
<li>JS&#x2F;TS：<code>Promise</code>+<code>async/await</code>（把嵌套改成线性代码）；</li>
<li>Python：<code>asyncio</code>+<code>await</code>；</li>
<li>Java：<code>CompletableFuture</code>+<code>thenApply</code>（链式调用）；</li>
<li>C#：<code>Task</code>+<code>async/await</code>。</li>
</ul>
<p>比如上面JS的回调地狱例子，现在用<code>async/await</code>改写后，完全没有嵌套：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 现在的JS写法（无回调地狱）</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">readFiles</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> data1 = <span class="hljs-keyword">await</span> fs.<span class="hljs-property">promises</span>.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;file1.txt&#x27;</span>);<br>  <span class="hljs-keyword">const</span> data2 = <span class="hljs-keyword">await</span> fs.<span class="hljs-property">promises</span>.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;file2.txt&#x27;</span>);<br>  <span class="hljs-keyword">const</span> data3 = <span class="hljs-keyword">await</span> fs.<span class="hljs-property">promises</span>.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;file3.txt&#x27;</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data1 + data2 + data3); <span class="hljs-comment">// 线性代码，可读性强</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>而你在Solidity测试中用JS&#x2F;TS时，也都是用<code>async/await</code>写测试脚本（Hardhat默认支持），比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// Hardhat测试脚本（async/await，无回调地狱）</span><br><span class="hljs-title function_">describe</span>(<span class="hljs-string">&quot;MyContract&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">it</span>(<span class="hljs-string">&quot;should pause only by admin&quot;</span>, <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> [admin, user] = <span class="hljs-keyword">await</span> ethers.<span class="hljs-title function_">getSigners</span>(); <span class="hljs-comment">// 异步获取账号</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title class_">MyContract</span> = <span class="hljs-keyword">await</span> ethers.<span class="hljs-title function_">getContractFactory</span>(<span class="hljs-string">&quot;MyContract&quot;</span>);<br>    <span class="hljs-keyword">const</span> myContract = <span class="hljs-keyword">await</span> <span class="hljs-title class_">MyContract</span>.<span class="hljs-title function_">deploy</span>(admin.<span class="hljs-property">address</span>); <span class="hljs-comment">// 异步部署</span><br><br>    <span class="hljs-comment">// 普通用户调用暂停，预期失败</span><br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">expect</span>(myContract.<span class="hljs-title function_">connect</span>(user).<span class="hljs-title function_">pause</span>()).<span class="hljs-property">to</span>.<span class="hljs-property">be</span>.<span class="hljs-title function_">revertedWith</span>(<span class="hljs-string">&quot;Only admin&quot;</span>);<br>    <span class="hljs-comment">// 管理员调用暂停，预期成功</span><br>    <span class="hljs-keyword">await</span> myContract.<span class="hljs-title function_">connect</span>(admin).<span class="hljs-title function_">pause</span>();<br>    <span class="hljs-title function_">expect</span>(<span class="hljs-keyword">await</span> myContract.<span class="hljs-title function_">paused</span>()).<span class="hljs-property">to</span>.<span class="hljs-property">be</span>.<span class="hljs-property">true</span>;<br>  &#125;);<br>&#125;);<br></code></pre></div></td></tr></table></figure>

<p>所以你完全不用为“回调地狱”担心——现在的JS开发已经没有这个问题了。</p>
<h3 id="三、对你的学习启示"><a href="#三、对你的学习启示" class="headerlink" title="三、对你的学习启示"></a>三、对你的学习启示</h3><ol>
<li><strong>不用强迫自己“精通JS”</strong>：Solidity开发的核心是合约编写和安全测试，JS只要掌握“基础语法+异步（Promise&#x2F;async&#x2F;await）+Hardhat测试库使用”就够了，后续可以学Foundry用Solidity写测试，彻底摆脱JS依赖；</li>
<li><strong>不用害怕“回调地狱”</strong>：它是早期异步编程的历史问题，现在所有主流语言都有解决方案，实际开发中几乎遇不到；</li>
<li><strong>JS的核心价值（如果要学）</strong>：除了测试，JS还能帮你写DApp前端（比如用React+Ethers.js调用合约），这是Solidity开发的加分项，但不是必选项。</li>
</ol>
<p>总结：Solidity开发≠精通JS，回调地狱也不是JS独有（且已被解决）。你可以先聚焦Solidity本身和“JS基础+Hardhat测试”，后续根据需求选择是否深入JS（比如做前端）或转向Foundry（比如侧重安全）。</p>
<h1 id="同步执行的语言和异步执行的语言有什么区别"><a href="#同步执行的语言和异步执行的语言有什么区别" class="headerlink" title="同步执行的语言和异步执行的语言有什么区别"></a>同步执行的语言和异步执行的语言有什么区别</h1><p>同步执行语言和异步执行语言的核心区别，在于 <strong>代码执行的“顺序规则”和“资源利用方式”</strong> ——本质是“是否允许程序在等待某个操作完成时，去做其他事情”。结合你熟悉的 Solidity（同步）、JavaScript（异步），以及传统开发经验，用通俗的逻辑+实际场景拆解，你会更容易理解：</p>
<h3 id="一、先搞懂核心定义：用“排队办事”比喻"><a href="#一、先搞懂核心定义：用“排队办事”比喻" class="headerlink" title="一、先搞懂核心定义：用“排队办事”比喻"></a>一、先搞懂核心定义：用“排队办事”比喻</h3><h4 id="1-同步执行：“排队等，做完一个再做下一个”"><a href="#1-同步执行：“排队等，做完一个再做下一个”" class="headerlink" title="1. 同步执行：“排队等，做完一个再做下一个”"></a>1. 同步执行：“排队等，做完一个再做下一个”</h4><p>就像去银行办事，所有任务按顺序排队，<strong>必须等前一个任务完全完成，后一个才开始执行</strong>。<br>如果前一个任务卡住（比如等待文件读取、网络请求），整个程序会“阻塞”（暂停），直到这个任务结束，后续代码才会继续跑。</p>
<h4 id="2-异步执行：“多窗口并行，不用死等”"><a href="#2-异步执行：“多窗口并行，不用死等”" class="headerlink" title="2. 异步执行：“多窗口并行，不用死等”"></a>2. 异步执行：“多窗口并行，不用死等”</h4><p>就像餐厅同时接待多个顾客，一个任务如果需要等待（比如煮菜要5分钟），程序不会闲着，而是去处理其他不需要等待的任务；等之前的任务完成后（比如菜煮好了），再回头处理它的后续逻辑。<br>核心是“非阻塞”——等待过程中不浪费时间，提高资源利用率。</p>
<h3 id="二、关键区别对比（表格更清晰）"><a href="#二、关键区别对比（表格更清晰）" class="headerlink" title="二、关键区别对比（表格更清晰）"></a>二、关键区别对比（表格更清晰）</h3><p>| 对比维度                | 同步执行语言                          | 异步执行语言                          |<br>| 执行顺序                | 严格按代码书写顺序，串行执行          | 不按固定顺序，“谁先完成谁先执行”，并行（逻辑上） |<br>| 等待操作的处理方式      | 阻塞：等待时程序暂停，啥也不做        | 非阻塞：等待时去执行其他任务，不浪费资源 |<br>| 核心场景                | 不需要等待的操作（CPU密集型）：比如计算、逻辑判断、合约执行 | 需要等待的操作（IO密集型）：比如网络请求、文件读取、链上交互 |<br>| 代码复杂度              | 逻辑简单，容易调试（顺序明确）        | 逻辑稍复杂（需处理“回调&#x2F;异步结果”），但现在有 <code>async/await</code> 简化 |<br>| 资源利用率              | 较低（等待时CPU闲置）                 | 较高（等待时CPU处理其他任务）          |<br>| 典型语言&#x2F;场景           | Solidity、Java（同步代码）、C（基础场景）：比如合约转账、数学计算 | JavaScript&#x2F;TypeScript、Python（asyncio）、Go（goroutine）：比如DApp前端请求、合约测试（部署&#x2F;调用链上合约） |</p>
<h3 id="三、用你熟悉的场景，拆解具体差异"><a href="#三、用你熟悉的场景，拆解具体差异" class="headerlink" title="三、用你熟悉的场景，拆解具体差异"></a>三、用你熟悉的场景，拆解具体差异</h3><p>结合你学过的 Solidity 开发，举2个实际例子，瞬间懂：</p>
<h4 id="例子1：Solidity-合约执行（同步）"><a href="#例子1：Solidity-合约执行（同步）" class="headerlink" title="例子1：Solidity 合约执行（同步）"></a>例子1：Solidity 合约执行（同步）</h4><p>Solidity 是 <strong>纯同步语言</strong>，链上合约的所有操作都必须同步执行——因为区块链需要保证“交易结果的确定性”（比如转账后余额必须立即更新，不能出现“异步延迟导致的余额混乱”）。<br>比如一个合约函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">function transfer(address to, uint256 amount) public &#123;<br>  require(balance[msg.sender] &gt;= amount, &quot;余额不足&quot;); // 任务1：检查余额<br>  balance[msg.sender] -= amount; // 任务2：扣钱<br>  balance[to] += amount; // 任务3：加钱<br>  emit Transfer(msg.sender, to, amount); // 任务4：发事件<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>执行时必须按“1→2→3→4”的顺序，<strong>任务1没完成，任务2绝对不会开始</strong>；如果任务1失败（余额不足），后续所有任务都直接终止——这就是同步的“确定性”，也是区块链安全的基础（不能让转账过程中出现“半成功半失败”）。</p>
<h4 id="例子2：JS-写-Solidity-测试（异步）"><a href="#例子2：JS-写-Solidity-测试（异步）" class="headerlink" title="例子2：JS 写 Solidity 测试（异步）"></a>例子2：JS 写 Solidity 测试（异步）</h4><p>你用 Hardhat&#x2F;JS 写测试时，经常会写 <code>await</code>，这就是典型的异步场景：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">testTransfer</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> contract = <span class="hljs-keyword">await</span> ethers.<span class="hljs-title function_">getContractFactory</span>(<span class="hljs-string">&quot;MyToken&quot;</span>); <span class="hljs-comment">// 任务1：加载合约（需读文件+网络交互，要等）</span><br>  <span class="hljs-keyword">const</span> deployedContract = <span class="hljs-keyword">await</span> contract.<span class="hljs-title function_">deploy</span>(); <span class="hljs-comment">// 任务2：部署合约（链上操作，要等）</span><br>  <span class="hljs-keyword">const</span> balance = <span class="hljs-keyword">await</span> deployedContract.<span class="hljs-title function_">balanceOf</span>(admin.<span class="hljs-property">address</span>); <span class="hljs-comment">// 任务3：查余额（链上查询，要等）</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<ul>
<li>如果是同步执行：任务1没完成（合约没加载好），就不能开始任务2，且等待时 JS 引擎完全闲置；</li>
<li>实际是异步执行：<code>await</code> 会让当前任务“暂停等待”，但 JS 引擎可以去处理其他测试用例的初始化、链上连接等操作，等当前任务完成后再继续——这样能大幅提高测试效率（不用在每个链上操作的等待时间里“空转”）。</li>
</ul>
<h3 id="四、关键澄清：3个容易踩的误区"><a href="#四、关键澄清：3个容易踩的误区" class="headerlink" title="四、关键澄清：3个容易踩的误区"></a>四、关键澄清：3个容易踩的误区</h3><h4 id="1-异步-≠-多线程（很多人混淆）"><a href="#1-异步-≠-多线程（很多人混淆）" class="headerlink" title="1. 异步 ≠ 多线程（很多人混淆）"></a>1. 异步 ≠ 多线程（很多人混淆）</h4><ul>
<li>多线程：真正的“同时执行多个任务”（比如电脑同时开浏览器、微信、编辑器），需要CPU多核支持；</li>
<li>异步：逻辑上的“并行”，但可能是单线程实现的（比如JS是单线程，靠“事件循环”处理异步任务）——比如JS引擎同一时间只能执行一个代码，但通过“等待时切换任务”，让人感觉是“同时在做多个事”。</li>
</ul>
<h4 id="2-没有“绝对更好”的语言，只有“适配场景”"><a href="#2-没有“绝对更好”的语言，只有“适配场景”" class="headerlink" title="2. 没有“绝对更好”的语言，只有“适配场景”"></a>2. 没有“绝对更好”的语言，只有“适配场景”</h4><ul>
<li>同步适合：需要“顺序确定性”“无依赖的快速操作”——比如合约执行（必须保证每一步的结果正确后再下一步）、数学计算（CPU密集型，不需要等待）；</li>
<li>异步适合：需要“等待外部资源”（IO密集型）——比如前端请求API、测试时调用链上合约、后端读取数据库（这些操作的“等待时间”远大于执行时间，异步能避免资源浪费）。</li>
</ul>
<h4 id="3-同步语言也能“模拟异步”，异步语言也能“写同步代码”"><a href="#3-同步语言也能“模拟异步”，异步语言也能“写同步代码”" class="headerlink" title="3. 同步语言也能“模拟异步”，异步语言也能“写同步代码”"></a>3. 同步语言也能“模拟异步”，异步语言也能“写同步代码”</h4><ul>
<li>同步语言（比如Java）：可以用“多线程+回调”模拟异步（比如用 <code>Thread</code> 开启新线程处理IO操作）；</li>
<li>异步语言（比如JS）：如果所有代码都不用 <code>await</code>、不写回调，就是同步执行（比如简单的数学计算 <code>1+1=2</code>，不需要等待，直接执行）。</li>
</ul>
<h3 id="五、对你的学习启示（结合Solidity开发）"><a href="#五、对你的学习启示（结合Solidity开发）" class="headerlink" title="五、对你的学习启示（结合Solidity开发）"></a>五、对你的学习启示（结合Solidity开发）</h3><ol>
<li><strong>Solidity 永远是同步的，不用纠结“异步合约”</strong>：链上执行必须保证确定性，所以合约代码的执行顺序、结果都是固定的，你写 Solidity 时，只需要关注“顺序逻辑”（比如先检查权限，再执行转账），不用考虑异步相关的问题；</li>
<li><strong>JS&#x2F;TS 的异步是“工具层需求”</strong>：你用 JS 写测试、写DApp前端时，之所以需要异步，是因为要和“链上资源”“文件”“网络”交互（这些都需要等待），掌握 <code>Promise</code>+<code>async/await</code> 就够了，不用深入复杂的异步原理；</li>
<li><strong>选择同步还是异步，看“是否需要等待”</strong>：比如你写合约函数（同步，不需要等待外部资源），写测试脚本（异步，需要等待链上操作）——两者是“互补”的，不是“对立”的。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>同步和异步的核心区别，本质是 <strong>“等待时是否浪费资源”和“执行顺序是否固定”</strong>：</p>
<ul>
<li>同步：顺序固定、阻塞等待，适合需要确定性的场景（比如Solidity合约）；</li>
<li>异步：顺序灵活、非阻塞等待，适合IO密集型场景（比如JS测试、前端交互）。</li>
</ul>
<p>对你来说，不用纠结“哪种语言更好”，而是记住：<strong>Solidity 写合约用同步逻辑，工具层（测试&#x2F;前端）用JS的异步（<code>async/await</code>）处理等待场景</strong>——这正是你学习 Solidity 开发时会遇到的最常见情况，掌握这个搭配就够应对大部分工作了。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Web3/">Web3</a>
                    
                  </div>
                
              </div>
              
                
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/12/03/10508.html">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">javascript3</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/12/02/19536.html">
                        <span class="hidden-mobile">javascript</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


            

                
                  <a id="scroll-top-button" href="#" role="button">
                    <i class="iconfont icon-arrowup" aria-hidden="true"></i>
                  </a>
                  

                    

                          
      </main>

      <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://whale3070.github.io/" target="_blank" rel="nofollow noopener"><span>Whale3070</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->




  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>





  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<link href="/pagefind/pagefind-ui.css" rel="stylesheet">
  <script src="/pagefind/pagefind-ui.js"></script>
  <style>
    /* 搜索框配色适配 */
    #search { margin-top: 2rem; }
    [data-user-color-scheme='dark'] .pagefind-ui {
      --pagefind-ui-primary: #eeeeee;
      --pagefind-ui-text: #eeeeee;
      --pagefind-ui-background: #151515;
      --pagefind-ui-border: #333;
    }
  </style>
    </body>

  </html>