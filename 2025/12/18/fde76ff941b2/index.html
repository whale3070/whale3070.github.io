

  <!DOCTYPE html>
  <html lang="en" data-default-color-scheme=&#34;dark&#34; >
  <style>
    .text1
    {
    text-shadow: 0px 0px 2px #f2f3f2;
    }
    </style>

  

<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/null">
  <link rel="icon" type="image/png" href="/null">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>Damn Vulnerable DeFi（五） - whale3070&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.7","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


    <body>
      <header style="height: 70vh;">
        <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>InfoSec learning</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          
        
      </ul>
    </div>
  </div>
</nav>

          <div class="banner" id="banner" false
            style="background: url('/img/default.png') no-repeat center center;
              background-size: cover;">
              <div class="full-bg-img">
                <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
                  <div class="page-header text-center fade-in-up">
                    <span class="h2 text1" id="subtitle" title="Damn Vulnerable DeFi（五）">
                      
                        Damn Vulnerable DeFi（五）
                      
                    </span>
        
                    
                      <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2025-12-18 08:32" pubdate>
        December 18, 2025 am
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6.9k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      83
       分钟
    </span>
  

  
  
</div>

                    
                  </div>
                    
                  </div>
                  
                </div>
              </div>
          </div>
      </header>

      <main>
        
          

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Damn Vulnerable DeFi（五）</h1>
            
            <div class="markdown-body">
              <p><a target="_blank" rel="noopener" href="https://whale3070.com/2025/12/17/b4758d396ba6/">上一篇： Damn Vulnerable DeFi（四）</a></p>
<p>昨天稍微用slither扫描了一下naive-receiver，发现有4个合约。</p>
<p>用ai每一行生成了注释，看不明白，然后用slither静态分析了一下。似乎有重入漏洞，能让攻击者一直调用函数，导致接收者资金耗尽。</p>
<p>然后我用slither还扫描了下Unstoppable，发现这个工具貌似无法检测出逻辑漏洞。</p>
<h1 id="ai的回复"><a href="#ai的回复" class="headerlink" title="ai的回复"></a>ai的回复</h1><p>你对 Naive Receiver 合约的分析方向非常准！这个经典的以太坊智能合约漏洞案例核心就是<strong>利用重入/循环调用+固定gas消耗</strong>，让接收者的资金被持续扣除直至耗尽。我先帮你理清这个合约的核心逻辑、漏洞成因，再结合 Slither 的分析结果拆解问题，让你能彻底看懂。</p>
<h3 id="一、先明确-Naive-Receiver-合约的核心角色（对应你看到的4个合约）"><a href="#一、先明确-Naive-Receiver-合约的核心角色（对应你看到的4个合约）" class="headerlink" title="一、先明确 Naive Receiver 合约的核心角色（对应你看到的4个合约）"></a>一、先明确 Naive Receiver 合约的核心角色（对应你看到的4个合约）</h3><p>Naive Receiver 是 Damn Vulnerable DeFi 中的经典题目，通常包含以下核心合约（4个合约大概率是：基础接口、借贷池、接收者、攻击者合约）：</p>
<ol>
<li><code>FlashLoanReceiver</code>：闪电贷接收者的接口（定义 <code>executeFlashLoan</code> 方法）；</li>
<li><code>NaiveReceiverLenderPool</code>：闪电贷池子（提供闪电贷，收取固定手续费）；</li>
<li><code>NaiveReceiver</code>：有漏洞的接收者合约（实现了 <code>executeFlashLoan</code>，但未做防护）；</li>
<li><code>Attacker</code>：攻击者合约（专门利用漏洞攻击接收者）。</li>
</ol>
<h3 id="二、漏洞核心逻辑（为什么会导致资金耗尽）"><a href="#二、漏洞核心逻辑（为什么会导致资金耗尽）" class="headerlink" title="二、漏洞核心逻辑（为什么会导致资金耗尽）"></a>二、漏洞核心逻辑（为什么会导致资金耗尽）</h3><h4 id="1-先看关键合约的核心代码（带注释版）"><a href="#1-先看关键合约的核心代码（带注释版）" class="headerlink" title="1. 先看关键合约的核心代码（带注释版）"></a>1. 先看关键合约的核心代码（带注释版）</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">// 闪电贷池子合约（核心收费逻辑）<br>contract NaiveReceiverLenderPool &#123;<br>    // 每次闪电贷收取 1 ETH 手续费（固定金额，不是比例）<br>    uint256 public constant FIXED_FEE = 1 ether; <br><br>    // 提供闪电贷的核心函数<br>    function flashLoan(address borrower, uint256 borrowAmount) external &#123;<br>        // 1. 检查接收者合约是否实现了 FlashLoanReceiver 接口<br>        FlashLoanReceiver receiver = FlashLoanReceiver(borrower);<br>        // 2. 检查接收者余额是否足够偿还（借款金额 + 手续费）<br>        uint256 balanceBefore = address(borrower).balance;<br>        require(balanceBefore &gt;= borrowAmount, &quot;Insufficient balance&quot;);<br><br>        // 3. 给接收者转钱（闪电贷核心：先借出去）<br>        payable(borrower).transfer(borrowAmount);<br>        <br>        // 4. 调用接收者的 executeFlashLoan 方法（漏洞关键：外部调用）<br>        receiver.executeFlashLoan(borrowAmount);<br><br>        // 5. 检查接收者是否偿还了手续费（核心扣费逻辑）<br>        require(address(borrower).balance == balanceBefore - FIXED_FEE, &quot;Flash loan not repaid&quot;);<br>    &#125;<br>&#125;<br><br>// 有漏洞的接收者合约<br>contract NaiveReceiver is FlashLoanReceiver &#123;<br>    address payable public owner;<br>    NaiveReceiverLenderPool public pool;<br><br>    constructor(address poolAddress) &#123;<br>        owner = payable(msg.sender);<br>        pool = NaiveReceiverLenderPool(poolAddress);<br>    &#125;<br><br>    // 实现闪电贷接口，但未限制调用者和调用次数<br>    function executeFlashLoan(uint256 amount) external override &#123;<br>        // 无任何防护：任何人都能调用，且调用多少次都可以<br>        require(msg.sender == address(pool), &quot;Only pool can call&quot;);<br>    &#125;<br><br>    // 辅助函数：查看合约余额<br>    function getBalance() external view returns (uint256) &#123;<br>        return address(this).balance;<br>    &#125;<br><br>    // 提现函数（仅所有者）<br>    function withdraw() external &#123;<br>        require(msg.sender == owner, &quot;Only owner can withdraw&quot;);<br>        owner.transfer(address(this).balance);<br>    &#125;<br><br>    // 接收 ETH 的 fallback 函数<br>    receive() external payable &#123;&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h4 id="2-漏洞成因（Slither-能检测到的关键问题）"><a href="#2-漏洞成因（Slither-能检测到的关键问题）" class="headerlink" title="2. 漏洞成因（Slither 能检测到的关键问题）"></a>2. 漏洞成因（Slither 能检测到的关键问题）</h4><p>你提到的“重入漏洞”本质是<strong>无限制的外部调用 + 固定手续费扣费逻辑</strong>，Slither 会识别出以下风险点：</p>
<ul>
<li><strong>未限制函数调用频率/次数</strong>：<code>flashLoan</code> 函数没有限制对同一个接收者的调用次数，攻击者可以循环调用；</li>
<li><strong>外部调用未做防护</strong>：<code>flashLoan</code> 中直接调用 <code>receiver.executeFlashLoan()</code>，且未检查调用后的状态是否异常；</li>
<li><strong>固定手续费设计缺陷</strong>：手续费是固定 1 ETH，而非比例，即使借款金额为 0，也会扣 1 ETH（这是最致命的点）。</li>
</ul>
<h4 id="3-攻击者的攻击流程（资金耗尽的全过程）"><a href="#3-攻击者的攻击流程（资金耗尽的全过程）" class="headerlink" title="3. 攻击者的攻击流程（资金耗尽的全过程）"></a>3. 攻击者的攻击流程（资金耗尽的全过程）</h4><p><img src="1.png" srcset="/img/loading.gif"></p>
<pre><code class=" mermaid">graph TD
    A[攻击者] --&gt;|1. 循环调用池子的 flashLoan 函数| B[NaiveReceiverLenderPool]
    B --&gt;|2. 每次调用给接收者转 0 ETH（借款金额为0）| C[NaiveReceiver]
    B --&gt;|3. 调用接收者的 executeFlashLoan 方法| C
    B --&gt;|4. 扣除接收者 1 ETH 手续费| C
    A --&gt;|5. 重复步骤1-4，直到接收者余额为0| B
</code></pre>

<p>核心攻击代码（攻击者合约）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">contract Attacker &#123;<br>    NaiveReceiverLenderPool public pool;<br>    NaiveReceiver public receiver;<br><br>    constructor(address poolAddress, address receiverAddress) &#123;<br>        pool = NaiveReceiverLenderPool(poolAddress);<br>        receiver = NaiveReceiver(receiverAddress);<br>    &#125;<br><br>    // 攻击核心：循环调用 flashLoan，每次扣 1 ETH<br>    function attack() external &#123;<br>        // 循环调用，直到接收者余额不足 1 ETH<br>        while (address(receiver).balance &gt;= 1 ether) &#123;<br>            // 借款金额为 0，但手续费仍扣 1 ETH<br>            pool.flashLoan(address(receiver), 0);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="三、Slither-检测到的关键告警（对应你的发现）"><a href="#三、Slither-检测到的关键告警（对应你的发现）" class="headerlink" title="三、Slither 检测到的关键告警（对应你的发现）"></a>三、Slither 检测到的关键告警（对应你的发现）</h3><p>Slither 扫描时会输出以下核心风险（你看到的“重入漏洞”其实是这类告警的统称）：</p>
<ol>
<li><strong>Unprotected external call</strong>（未受保护的外部调用）：<ul>
<li>告警位置：<code>NaiveReceiverLenderPool.flashLoan</code> 中调用 <code>receiver.executeFlashLoan()</code>；</li>
<li>含义：外部调用未做重入防护（如 ReentrancyGuard），且未限制调用次数；</li>
</ul>
</li>
<li><strong>Function has no access control</strong>（函数无访问控制，进阶检测）：<ul>
<li>告警位置：虽然 <code>executeFlashLoan</code> 限制了 msg.sender 为池子，但池子的 <code>flashLoan</code> 函数任何人都能调用；</li>
</ul>
</li>
<li><strong>Unchecked return value for external call</strong>（外部调用返回值未检查）：<ul>
<li>告警位置：<code>payable(borrower).transfer(borrowAmount)</code> 未检查转账结果（虽然 transfer 会抛异常，但逻辑上仍有风险）。</li>
</ul>
</li>
</ol>
<h3 id="四、漏洞修复方案（验证你的分析）"><a href="#四、漏洞修复方案（验证你的分析）" class="headerlink" title="四、漏洞修复方案（验证你的分析）"></a>四、漏洞修复方案（验证你的分析）</h3><p>要解决这个问题，核心是<strong>限制闪电贷的调用权限和调用次数</strong>，常见修复方式：</p>
<ol>
<li>在接收者合约中限制闪电贷的调用者（仅所有者）：<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">function executeFlashLoan(uint256 amount) external override &#123;<br>    require(msg.sender == address(pool), &quot;Only pool can call&quot;);<br>    // 新增：只有所有者发起的闪电贷才允许执行<br>    require(tx.origin == owner, &quot;Only owner can initiate flash loan&quot;);<br>&#125;<br></code></pre></div></td></tr></table></figure></li>
<li>在池子合约中限制单次调用的手续费或调用频率：<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">// 新增：记录每个地址的闪电贷调用次数<br>mapping(address =&gt; uint256) public flashLoanCount;<br>// 限制每天最多调用 1 次<br>uint256 public constant MAX_CALLS_PER_DAY = 1;<br><br>function flashLoan(address borrower, uint256 borrowAmount) external &#123;<br>    // 新增：检查调用次数<br>    require(flashLoanCount[borrower] &lt; MAX_CALLS_PER_DAY, &quot;Too many flash loans&quot;);<br>    flashLoanCount[borrower]++;<br><br>    // 原有逻辑...<br>&#125;<br></code></pre></div></td></tr></table></figure></li>
<li>将固定手续费改为比例手续费（如借款金额的 1%），避免 0 借款扣 1 ETH：<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">// 替换固定手续费为比例<br>uint256 public constant FEE_RATIO = 1; // 1%<br>function flashLoan(address borrower, uint256 borrowAmount) external &#123;<br>    uint256 fee = borrowAmount * FEE_RATIO / 100;<br>    // 后续逻辑用 fee 替代 FIXED_FEE...<br>&#125;<br></code></pre></div></td></tr></table></figure></li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>Naive Receiver 的核心漏洞不是传统意义上的“重入”（即利用 fallback 递归调用），而是<strong>无限制的闪电贷调用 + 固定手续费扣费</strong>，攻击者可循环调用耗尽接收者资金；</li>
<li>Slither 检测到的“重入风险”本质是“未受保护的外部调用”，这是触发漏洞的关键前提；</li>
<li>修复的核心思路是：限制闪电贷的调用权限、调用频率，或修改手续费计算方式，避免无借款却扣费的情况。</li>
</ol>
<p>你能通过 Slither 扫描发现这个风险，说明已经抓住了智能合约安全分析的核心——关注外部调用、权限控制和资金扣减逻辑，这是非常关键的进步！</p>
<h1 id="我想问一下你这个生成图片用的什么技术，使用了什么原理？"><a href="#我想问一下你这个生成图片用的什么技术，使用了什么原理？" class="headerlink" title="我想问一下你这个生成图片用的什么技术，使用了什么原理？"></a>我想问一下你这个生成图片用的什么技术，使用了什么原理？</h1><p>你看到的这个流程图是用 <strong>Mermaid 语法</strong> 生成的，它是一种专门用于绘制文本驱动型图表的标记语言，核心原理是<strong>用纯文本描述图表结构，再由支持 Mermaid 的工具渲染成可视化图形</strong>。</p>
<h3 id="一、核心技术与原理"><a href="#一、核心技术与原理" class="headerlink" title="一、核心技术与原理"></a>一、核心技术与原理</h3><ol>
<li><p><strong>Mermaid 的本质</strong><br>Mermaid 是一个开源的 JavaScript 库，遵循 <strong>“代码即图表”</strong> 的理念：</p>
<ul>
<li>你用简单的文本语法定义图表的节点、连线、关系；</li>
<li>支持 Mermaid 的平台（如 Markdown 编辑器、GitHub、Notion 等）会自动调用其渲染引擎，将文本转换为 SVG 或 PNG 格式的图表。</li>
<li>它的优势是无需手动拖拽画图，纯文本编写即可，且易于版本控制。</li>
</ul>
</li>
<li><p><strong>你贴的代码对应的图表类型</strong><br>你用的 <code>graph TD</code> 是 Mermaid 中 <strong>自上而下的流程图</strong>：</p>
<ul>
<li><code>graph</code>：声明这是一个流程图；</li>
<li><code>TD</code>：是 <code>Top Down</code> 的缩写，表示图表的流向是<strong>从上到下</strong>；</li>
<li>其他流向还包括 <code>LR</code>（Left to Right，从左到右）、<code>BT</code>（Bottom to Top，从下到上）等。</li>
</ul>
</li>
<li><p><strong>语法拆解（以你的代码为例）</strong></p>
<pre><code class=" mermaid">graph TD
    A[攻击者] --&gt;|1. 循环调用池子的 flashLoan 函数| B[NaiveReceiverLenderPool]
    B --&gt;|2. 每次调用给接收者转 0 ETH（借款金额为0）| C[NaiveReceiver]
    B --&gt;|3. 调用接收者的 executeFlashLoan 方法| C
    B --&gt;|4. 扣除接收者 1 ETH 手续费| C
    A --&gt;|5. 重复步骤1-4，直到接收者余额为0| B
</code></pre>
<ul>
<li><code>A[攻击者]</code>：定义一个节点，ID 为 <code>A</code>，显示文本为 <code>攻击者</code>；</li>
<li><code>--&gt;|描述文本|</code>：定义带标签的连线，<code>| |</code> 内的内容是连线的说明；</li>
<li>节点可以是任意文本，支持中文、代码片段等。</li>
</ul>
</li>
</ol>
<h3 id="二、支持-Mermaid-的工具"><a href="#二、支持-Mermaid-的工具" class="headerlink" title="二、支持 Mermaid 的工具"></a>二、支持 Mermaid 的工具</h3><ol>
<li><p><strong>在线编辑器</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://mermaid.live/">Mermaid Live Editor</a>：官方在线工具，写代码实时渲染，支持导出图片（PNG/SVG）；</li>
<li>适合快速调试图表语法，生成后可直接下载使用。</li>
</ul>
</li>
<li><p><strong>文档与笔记工具</strong></p>
<ul>
<li><strong>GitHub/GitLab</strong>：Markdown 文件中直接写 Mermaid 代码，会自动渲染；</li>
<li><strong>Notion/语雀</strong>：支持 Mermaid 语法，插入代码块选择 <code>mermaid</code> 即可；</li>
<li><strong>VS Code</strong>：安装插件（如 <code>Mermaid Markdown Syntax Highlighting</code>），预览 Markdown 时自动渲染。</li>
</ul>
</li>
<li><p><strong>集成工具</strong></p>
<ul>
<li>一些博客平台（如 Hexo、Hugo）、文档生成工具（如 Docusaurus）也支持 Mermaid，可用于技术文档中的架构图、流程图。</li>
</ul>
</li>
</ol>
<h3 id="三、扩展用法（适合区块链审计）"><a href="#三、扩展用法（适合区块链审计）" class="headerlink" title="三、扩展用法（适合区块链审计）"></a>三、扩展用法（适合区块链审计）</h3><p>除了流程图，Mermaid 还能画区块链审计常用的图表：</p>
<ul>
<li><strong>时序图</strong>（<code>sequenceDiagram</code>）：描述合约函数调用的先后顺序；</li>
<li><strong>状态图</strong>（<code>stateDiagram</code>）：描述合约的状态转换（如众筹合约的“募集-成功-失败”状态）；</li>
<li><strong>类图</strong>（<code>classDiagram</code>）：描述合约的继承关系和函数结构。</li>
</ul>
<p>比如用时序图描述 Naive Receiver 的攻击流程，会更清晰地展示“攻击者→池子→接收者”的调用时序。</p>
<p>需要我帮你把这个攻击流程改成<strong>Mermaid时序图</strong>，更直观地展示函数调用顺序吗？ </p>
<h1 id="你觉得我有必要学习mermaid吗，还是用平板电脑，手绘流程图比较好呢？"><a href="#你觉得我有必要学习mermaid吗，还是用平板电脑，手绘流程图比较好呢？" class="headerlink" title="你觉得我有必要学习mermaid吗，还是用平板电脑，手绘流程图比较好呢？"></a>你觉得我有必要学习mermaid吗，还是用平板电脑，手绘流程图比较好呢？</h1><p>对于区块链安全审计的工作场景，<strong>优先学习 Mermaid 更实用</strong>，手绘（包括平板手绘）可以作为补充，两者并非对立关系。以下是结合你的职业需求的详细分析：</p>
<h3 id="一、为什么-Mermaid-更适配你的区块链审计工作"><a href="#一、为什么-Mermaid-更适配你的区块链审计工作" class="headerlink" title="一、为什么 Mermaid 更适配你的区块链审计工作"></a>一、为什么 Mermaid 更适配你的区块链审计工作</h3><ol>
<li><p><strong>和技术文档强绑定，效率更高</strong><br> 区块链审计的核心产出是<strong>审计报告</strong>，而 Mermaid 是<strong>文本化的图表语法</strong>，可以直接嵌入 Markdown/Word 等报告文档中，无需额外导出、插入图片。</p>
<ul>
<li>你分析 <code>Naive Receiver</code> 这类合约时，写完漏洞流程的 Mermaid 代码，就能在 GitHub、审计报告里实时渲染，分享给团队或客户时格式不会乱；</li>
<li>手绘（包括平板）需要画完拍照/导出，再插入文档，修改时还要重新画，效率远低于直接改几行 Mermaid 代码。</li>
</ul>
</li>
<li><p><strong>精准还原合约逻辑，避免手绘歧义</strong><br> 区块链审计的流程图需要<strong>严谨的节点关系</strong>（比如函数调用顺序、资金流向），Mermaid 的文本语法能精准定义：</p>
<ul>
<li>比如 <code>graph TD</code> 里的节点 ID、连线标签，能明确区分“攻击者调用池子”“池子扣接收者手续费”等步骤；</li>
<li>手绘容易出现线条混乱、标注不清的问题，尤其是复杂合约（如 Uniswap V3 路由、借贷合约的多步清算），文本化的 Mermaid 能避免歧义。</li>
</ul>
</li>
<li><p><strong>版本可控，便于复盘和协作</strong><br> 审计工作需要<strong>追溯漏洞分析的迭代过程</strong>，Mermaid 代码可以和合约代码、审计笔记一起提交到 Git 仓库，每次修改都有记录；<br> 而手绘的流程图很难版本化，时间久了可能分不清哪一版是最终的漏洞分析流程。</p>
</li>
<li><p><strong>学习成本低，上手快</strong><br> 你用到的流程图（<code>graph TD/LR</code>）、时序图（<code>sequenceDiagram</code>）是 Mermaid 最基础的语法，花 1-2 小时就能掌握核心用法，结合你分析 <code>Naive Receiver</code> 的场景，写几次攻击流程就能熟练。</p>
</li>
</ol>
<h3 id="二、平板手绘的适用场景（作为补充）"><a href="#二、平板手绘的适用场景（作为补充）" class="headerlink" title="二、平板手绘的适用场景（作为补充）"></a>二、平板手绘的适用场景（作为补充）</h3><p>平板手绘并非没用，适合以下场景：</p>
<ol>
<li><strong>快速头脑风暴，梳理复杂逻辑</strong><br> 拿到一个新合约（比如 DeFi 聚合器），你可以先用平板手绘快速勾勒<strong>核心资金流向、函数调用关系</strong>，不用纠结语法，先把漏洞的大致思路理清楚；</li>
<li><strong>向非技术人员讲解漏洞</strong><br> 如果客户不懂代码，手绘的流程图（搭配标注）会比文本化的 Mermaid 更直观，更容易理解“攻击者如何循环调用耗尽资金”这类逻辑。</li>
</ol>
<h3 id="三、总结建议"><a href="#三、总结建议" class="headerlink" title="三、总结建议"></a>三、总结建议</h3><ol>
<li><p><strong>优先级：先学 Mermaid，平板手绘按需补充</strong></p>
<ul>
<li>花半天时间掌握 Mermaid 的 <strong>流程图、时序图</strong> 两种核心语法，足够覆盖 90% 的审计报告场景；</li>
<li>平板可以暂时不买，如果后续经常需要和客户面对面沟通、或者头脑风暴的需求很高，再考虑入手（普通平板+手写笔即可，无需高端型号）。</li>
</ul>
</li>
<li><p><strong>两者结合的最佳实践</strong><br> 分析合约时：</p>
<ol>
<li> 平板手绘快速梳理漏洞核心逻辑（比如“攻击者→池子→接收者”的大致流向）；</li>
<li> 把手绘的思路转化为 Mermaid 代码，嵌入审计报告，保证文档的严谨性和可复用性。</li>
</ol>
</li>
</ol>
<p>需要我帮你把 <code>Naive Receiver</code> 的攻击流程改成<strong>更专业的 Mermaid 时序图</strong>，直接用于审计报告吗？</p>
<h1 id="Truster"><a href="#Truster" class="headerlink" title="Truster"></a>Truster</h1><p><a target="_blank" rel="noopener" href="https://www.damnvulnerabledefi.xyz/challenges/truster/">https://www.damnvulnerabledefi.xyz/challenges/truster/</a></p>
<p>More and more lending pools are offering flashloans. In this case, a new pool has launched that is offering flashloans of DVT tokens for free.<br>越来越多的借贷池开始提供闪电贷。在这种情况下，一个新的借贷池已经推出，它免费提供DVT代币的闪电贷。</p>
<p>The pool holds 1 million DVT tokens. You have nothing.<br>该资金池持有100万枚DVT代币。你一无所有。</p>
<p>To pass this challenge, rescue all funds in the pool executing a single transaction. Deposit the funds into the designated recovery account.<br>要通过这项挑战，需执行一笔交易来赎回资金池中的所有资金，并将这些资金存入指定的回收账户。</p>
<h1 id="slither审计结果"><a href="#slither审计结果" class="headerlink" title="slither审计结果"></a>slither审计结果</h1><p>slither /home/kali/Desktop/test10/damn-vulnerable-defi/src/truster/ –detect all<br>‘forge clean’ running (wd: /home/kali/Desktop/test10/damn-vulnerable-defi)<br>‘forge config –json’ running<br>‘forge build –build-info src/truster’ running (wd: /home/kali/Desktop/test10/damn-vulnerable-defi)</p>
<p>INFO:Detectors:<br>TrusterLenderPool.flashLoan(uint256,address,address,bytes) (src/truster/TrusterLenderPool.sol#20-35) ignores return value by token.transfer(borrower,amount) (src/truster/TrusterLenderPool.sol#27)<br>Reference: <a target="_blank" rel="noopener" href="https://github.com/crytic/slither/wiki/Detector-Documentation#unchecked-transfer">https://github.com/crytic/slither/wiki/Detector-Documentation#unchecked-transfer</a></p>
<p>INFO:Detectors:<br>TrusterLenderPool.flashLoan(uint256,address,address,bytes) (src/truster/TrusterLenderPool.sol#20-35) ignores return value by target.functionCall(data) (src/truster/TrusterLenderPool.sol#28)<br>Reference: <a target="_blank" rel="noopener" href="https://github.com/crytic/slither/wiki/Detector-Documentation#unused-return">https://github.com/crytic/slither/wiki/Detector-Documentation#unused-return</a></p>
<h2 id="审计结果分析"><a href="#审计结果分析" class="headerlink" title="审计结果分析"></a>审计结果分析</h2><p>你现在看到的是 Slither（以太坊智能合约静态分析工具）对 damn-vulnerable-defi 中 Truster 合约的审计结果，核心是指出了两个<strong>忽略返回值</strong>的安全问题，这是智能合约中非常常见且高危的漏洞类型。</p>
<h3 id="审计结果逐句解读"><a href="#审计结果逐句解读" class="headerlink" title="审计结果逐句解读"></a>审计结果逐句解读</h3><h4 id="第一个问题：token-transfer-borrower-amount-忽略返回值"><a href="#第一个问题：token-transfer-borrower-amount-忽略返回值" class="headerlink" title="第一个问题：token.transfer(borrower, amount) 忽略返回值"></a>第一个问题：<code>token.transfer(borrower, amount)</code> 忽略返回值</h4><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">TrusterLenderPool.flashLoan(...) ignores <span class="hljs-keyword">return</span> value <span class="hljs-keyword">by</span> token.transfer(borrower,amount)<br></code></pre></div></td></tr></table></figure>
<ol>
<li><strong>核心含义</strong>：<br>ERC20 代币的 <code>transfer</code> 函数会返回一个 <code>bool</code> 类型的值（<code>true</code> 表示转账成功，<code>false</code> 表示失败），但合约中的 <code>flashLoan</code> 函数调用 <code>token.transfer</code> 后，<strong>没有检查这个返回值</strong>。</li>
<li><strong>风险</strong>：<ul>
<li>如果代币转账失败（比如代币合约有特殊限制、转账金额超过余额、合约不接收代币等），<code>transfer</code> 会返回 <code>false</code>，但合约会误以为转账成功，继续执行后续逻辑，导致资金对账错误、业务逻辑异常，甚至被攻击者利用。</li>
<li>注意：部分代币（如 USDT）的 <code>transfer</code> 函数不返回 <code>bool</code>，而是失败时直接回滚交易，这种情况看似“安全”，但忽略返回值仍会导致合约兼容性问题。</li>
</ul>
</li>
</ol>
<h4 id="第二个问题：target-functionCall-data-忽略返回值"><a href="#第二个问题：target-functionCall-data-忽略返回值" class="headerlink" title="第二个问题：target.functionCall(data) 忽略返回值"></a>第二个问题：<code>target.functionCall(data)</code> 忽略返回值</h4><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TrusterLenderPool</span>.</span></span>flash<span class="hljs-constructor">Loan(<span class="hljs-operator">...</span>)</span> ignores return value by target.<span class="hljs-keyword">function</span><span class="hljs-constructor">Call(<span class="hljs-params">data</span>)</span><br></code></pre></div></td></tr></table></figure>
<ol>
<li><strong>核心含义</strong>：<br><code>functionCall</code> 是 Solidity 中调用外部合约函数的底层方法，它会返回被调用函数的返回值，但合约中<strong>没有接收/检查这个返回值</strong>。</li>
<li><strong>风险</strong>：<br><code>flashLoan</code> 函数允许用户指定任意目标合约（<code>target</code>）和调用数据（<code>data</code>），相当于把合约的权限“委托”给了外部地址。如果不检查 <code>functionCall</code> 的返回值：<ul>
<li>无法确认外部函数调用是否成功执行（比如外部合约返回错误标识，但合约仍认为执行完成）；</li>
<li>结合 Truster 合约的业务逻辑（闪电贷），攻击者可构造恶意的 <code>target</code> 和 <code>data</code>，让合约在不验证结果的情况下执行有害操作（比如授权攻击者转走合约所有代币）。</li>
</ul>
</li>
</ol>
<h3 id="修复方案（完整示例）"><a href="#修复方案（完整示例）" class="headerlink" title="修复方案（完整示例）"></a>修复方案（完整示例）</h3><p>以下是修复后的 <code>TrusterLenderPool.sol</code> 核心代码，重点是<strong>检查返回值</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;<br>import &quot;@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol&quot;; // 引入SafeERC20<br><br>contract TrusterLenderPool &#123;<br>    using SafeERC20 for IERC20; // 使用SafeERC20封装，自动检查返回值<br><br>    IERC20 public immutable damnValuableToken;<br><br>    constructor(IERC20 _token) &#123;<br>        damnValuableToken = _token;<br>    &#125;<br><br>    function flashLoan(<br>        uint256 borrowAmount,<br>        address borrower,<br>        address target,<br>        bytes calldata data<br>    ) external &#123;<br>        uint256 balanceBefore = damnValuableToken.balanceOf(address(this));<br>        require(balanceBefore &gt;= borrowAmount, &quot;Not enough tokens in pool&quot;);<br><br>        // 修复1：使用safeTransfer替代transfer，自动检查返回值<br>        damnValuableToken.safeTransfer(borrower, borrowAmount);<br><br>        // 修复2：检查functionCall的返回值（或使用safeCall）<br>        (bool success, bytes memory returnData) = target.functionCall(data);<br>        require(success, &quot;External call failed&quot;); // 检查调用是否成功<br>        // 可选：根据业务逻辑验证returnData（比如特定返回值）<br>        // if (returnData.length &gt; 0) &#123; ... &#125;<br><br>        uint256 balanceAfter = damnValuableToken.balanceOf(address(this));<br>        require(balanceAfter &gt;= balanceBefore, &quot;Flash loan not repaid&quot;);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h4 id="关键修复点说明："><a href="#关键修复点说明：" class="headerlink" title="关键修复点说明："></a>关键修复点说明：</h4><ol>
<li>**引入 <code>SafeERC20</code>**：OpenZeppelin 的 <code>SafeERC20</code> 库封装了 ERC20 操作，<code>safeTransfer</code> 会自动检查 <code>transfer</code> 的返回值，失败时直接回滚交易，避免忽略返回值的问题。</li>
<li><strong>检查 <code>functionCall</code> 返回值</strong>：<ul>
<li><code>(bool success, ...) = target.functionCall(data)</code>：接收调用是否成功的标识（<code>success</code>）；</li>
<li><code>require(success, &quot;External call failed&quot;)</code>：如果外部调用失败，直接回滚，阻止后续逻辑执行。</li>
</ul>
</li>
</ol>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol>
<li><strong>核心问题</strong>：合约调用外部函数（<code>transfer</code>/<code>functionCall</code>）时未检查返回值，导致无法感知操作失败，存在资金安全风险。</li>
<li><strong>修复核心</strong>：<ul>
<li>ERC20 转账优先使用 <code>SafeERC20.safeTransfer</code> 替代原生 <code>transfer</code>；</li>
<li>外部合约调用需显式检查 <code>functionCall</code> 的成功标识（<code>success</code>）；</li>
</ul>
</li>
<li><strong>业务风险延伸</strong>：Truster 合约的 <code>flashLoan</code> 允许任意外部调用，属于“权限过大”的设计，除了检查返回值，还需限制 <code>target</code> 范围或验证 <code>data</code> 的合法性（视业务场景而定）。</li>
</ol>
<p>简单来说，这两个审计结果的本质是：<strong>合约“盲目信任”外部操作的执行结果，没有做最基本的失败校验，是智能合约中典型的“粗心型”高危漏洞</strong>。</p>
<h1 id="查看reference"><a href="#查看reference" class="headerlink" title="查看reference"></a>查看reference</h1><p><a target="_blank" rel="noopener" href="https://github.com/crytic/slither/wiki/Detector-Documentation#unchecked-transfer">https://github.com/crytic/slither/wiki/Detector-Documentation#unchecked-transfer</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/crytic/slither/wiki/Detector-Documentation#unused-return">https://github.com/crytic/slither/wiki/Detector-Documentation#unused-return</a></p>
<h2 id="未经核查的转移"><a href="#未经核查的转移" class="headerlink" title="未经核查的转移"></a>未经核查的转移</h2><p>配置<br>查看：unchecked-transfer<br>严重程度：High<br>信心：Medium<br>描述<br>不会检查外部 transfer/transferFrom 调用的返回值。</p>
<p>漏洞利用场景：</p>
<figure class="highlight zephir"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs zephir">contract Token &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transferFrom</span><span class="hljs-params">(address _from, address _to, uint256 _value)</span> <span class="hljs-title">public</span> <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">bool</span> success)</span></span>;<br>&#125;<br>contract MyBank&#123;  <br>    mapping(address =&gt; <span class="hljs-keyword">uint</span>) balances;<br>    Token token;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deposit</span><span class="hljs-params">(<span class="hljs-keyword">uint</span> amount)</span> <span class="hljs-title">public</span></span>&#123;<br>        token.transferFrom(msg.sender, address(this), amount);<br>        balances[msg.sender] += amount;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>某些令牌在失败时不会回滚，而是返回 false。如果在交易中使用了这些令牌MyBank，deposit即使转账失败也不会回滚，攻击者可以deposit免费调用这些令牌。</p>
<p>推荐<br>使用SafeERC20，或者确保检查 transfer/transferFrom 返回值。</p>
<h2 id="unchecked-transfer漏洞分析"><a href="#unchecked-transfer漏洞分析" class="headerlink" title="unchecked-transfer漏洞分析"></a>unchecked-transfer漏洞分析</h2><p>你提供的这段代码核心漏洞和上一轮提到的 Slither 审计问题完全一致：<strong>调用 <code>transferFrom</code> 后没有检查返回值</strong>，这会导致合约在代币转账失败时，依然错误地更新用户余额，最终造成资产对账混乱和资金损失。</p>
<h3 id="漏洞详细分析"><a href="#漏洞详细分析" class="headerlink" title="漏洞详细分析"></a>漏洞详细分析</h3><h4 id="1-核心问题：忽略-transferFrom-的返回值"><a href="#1-核心问题：忽略-transferFrom-的返回值" class="headerlink" title="1. 核心问题：忽略 transferFrom 的返回值"></a>1. 核心问题：忽略 <code>transferFrom</code> 的返回值</h4><p><code>Token</code> 合约定义的 <code>transferFrom</code> 函数明确返回 <code>bool</code> 类型（<code>true</code> 成功/<code>false</code> 失败），但 <code>MyBank.deposit</code> 函数调用 <code>token.transferFrom(...)</code> 时，<strong>完全没有接收和验证这个返回值</strong>。</p>
<h4 id="2-具体风险场景"><a href="#2-具体风险场景" class="headerlink" title="2. 具体风险场景"></a>2. 具体风险场景</h4><p>假设出现以下情况：</p>
<ul>
<li>用户 A 想存入 100 个 Token，但他给 <code>MyBank</code> 合约的授权额度只有 50（或 Token 余额不足）；</li>
<li>调用 <code>token.transferFrom(msg.sender, address(this), 100)</code> 时，Token 合约会返回 <code>false</code>（转账失败）；</li>
<li>但 <code>MyBank</code> 合约没有检查这个结果，依然执行 <code>balances[msg.sender] += 100</code>，导致用户 A 的余额被错误记为 100；</li>
<li>后续用户 A 尝试提现时，合约会基于错误的余额向他转账，最终造成 <code>MyBank</code> 合约的资产损失。</li>
</ul>
<p>更危险的是：部分非标准 ERC20 代币（如 USDT）的 <code>transferFrom</code> 不返回 <code>bool</code>，而是失败时直接回滚交易——这看似“安全”，但如果合约对接的是<strong>返回 bool 但不回滚</strong>的代币，漏洞就会被触发。</p>
<h4 id="3-代码层面的直观问题"><a href="#3-代码层面的直观问题" class="headerlink" title="3. 代码层面的直观问题"></a>3. 代码层面的直观问题</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">function deposit(uint amount) public&#123;<br>    // 问题行：没有检查 transferFrom 的返回值<br>    token.transferFrom(msg.sender, address(this), amount);<br>    // 即使转账失败，这行依然执行，余额错误增加<br>    balances[msg.sender] += amount;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="修复后的完整代码"><a href="#修复后的完整代码" class="headerlink" title="修复后的完整代码"></a>修复后的完整代码</h3><p>核心修复思路是：<strong>检查 <code>transferFrom</code> 的返回值</strong>，推荐使用 OpenZeppelin 的 <code>SafeERC20</code> 库（行业最佳实践），它会自动处理返回值检查，失败时直接回滚交易。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>// 引入 OpenZeppelin 的安全库（需先安装：forge install OpenZeppelin/openzeppelin-contracts）<br>import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;<br>import &quot;@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol&quot;;<br><br>contract MyBank &#123;<br>    // 使用 SafeERC20 库，为 IERC20 类型增加安全方法<br>    using SafeERC20 for IERC20;<br><br>    mapping(address =&gt; uint) public balances;<br>    IERC20 public immutable token; // 改用标准 IERC20 接口，更通用<br><br>    // 构造函数初始化代币地址<br>    constructor(IERC20 _tokenAddress) &#123;<br>        token = _tokenAddress;<br>    &#125;<br><br>    function deposit(uint amount) public &#123;<br>        // 修复核心：使用 safeTransferFrom 替代原生 transferFrom<br>        // 自动检查返回值，失败则回滚，不会执行后续余额更新<br>        token.safeTransferFrom(msg.sender, address(this), amount);<br>        <br>        // 只有转账成功，才更新余额<br>        balances[msg.sender] += amount;<br>    &#125;<br><br>    // 可选：提现函数（示例，同样使用 safeTransfer）<br>    function withdraw(uint amount) public &#123;<br>        require(balances[msg.sender] &gt;= amount, &quot;Insufficient balance&quot;);<br>        balances[msg.sender] -= amount;<br>        token.safeTransfer(msg.sender, amount);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h4 id="修复关键点说明："><a href="#修复关键点说明：" class="headerlink" title="修复关键点说明："></a>修复关键点说明：</h4><ol>
<li>**引入 <code>SafeERC20</code>**：这是以太坊生态处理 ERC20 转账的标准方案，避免手动检查返回值的遗漏；</li>
<li>**<code>safeTransferFrom</code> 替代 <code>transferFrom</code>**：<code>safeTransferFrom</code> 会：<ul>
<li>调用原生 <code>transferFrom</code> 并检查返回值；</li>
<li>如果返回 <code>false</code>，直接触发 <code>revert</code>，终止交易；</li>
<li>兼容非标准代币（如不返回 bool 的 USDT），避免兼容性问题；</li>
</ul>
</li>
<li><strong>接口标准化</strong>：改用 <code>IERC20</code> 接口而非自定义 <code>Token</code> 合约，符合行业规范。</li>
</ol>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ol>
<li><strong>核心漏洞</strong>：调用 <code>transferFrom</code> 未检查返回值，导致转账失败时余额仍被错误更新，引发资产对账错误和资金损失；</li>
<li><strong>修复关键</strong>：使用 OpenZeppelin 的 <code>SafeERC20</code> 库的 <code>safeTransferFrom</code>/<code>safeTransfer</code> 替代原生 ERC20 方法，自动校验返回值；</li>
<li><strong>扩展建议</strong>：智能合约中所有外部函数调用（尤其是涉及资产转移的），都必须检查返回值或使用安全封装库，避免“盲目信任”外部操作结果。</li>
</ol>
<p>这个漏洞是 ERC20 代币操作中最常见的高危漏洞之一，也是审计工具（如 Slither）重点检测的内容，记住“<strong>所有 ERC20 转账必用 SafeERC20</strong>”是规避这类问题的核心原则。</p>
<h2 id="Unused-return-未使用的返回值"><a href="#Unused-return-未使用的返回值" class="headerlink" title="Unused return 未使用的返回值"></a>Unused return 未使用的返回值</h2><p>Configuration 配置<br>Check: unused-return 检查：unused-return<br>Severity: Medium 严重程度：Medium<br>Confidence: Medium 置信度：Medium<br>Description 描述<br>The return value of an external call is not stored in a local or state variable.<br>外部调用的返回值未存储在局部变量或状态变量中。</p>
<p>Exploit Scenario: 漏洞利用场景：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">contract MyConc&#123;<br>    <span class="hljs-keyword">using</span> SafeMath <span class="hljs-keyword">for</span> <span class="hljs-built_in">uint</span>;   <br>    <span class="hljs-function">function <span class="hljs-title">my_func</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> a, <span class="hljs-built_in">uint</span> b</span>) <span class="hljs-keyword">public</span></span>&#123;<br>        a.<span class="hljs-keyword">add</span>(b);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>MyConc calls add of SafeMath, but does not store the result in a. As a result, the computation has no effect.<br>MyConc 调用了 SafeMath 的 add 方法，但没有将结果存储在 a 中。因此，该计算没有任何效果。</p>
<p>Recommendation 建议<br>Ensure that all the return values of the function calls are used.<br>确保函数调用的所有返回值都得到使用。</p>
<h2 id="调用了-SafeMath-的-add-方法，但没有将结果存储在-a-中。那么如何修改，才能将结果存储到a中呢"><a href="#调用了-SafeMath-的-add-方法，但没有将结果存储在-a-中。那么如何修改，才能将结果存储到a中呢" class="headerlink" title="调用了 SafeMath 的 add 方法，但没有将结果存储在 a 中。那么如何修改，才能将结果存储到a中呢?"></a>调用了 SafeMath 的 add 方法，但没有将结果存储在 a 中。那么如何修改，才能将结果存储到a中呢?</h2><p>你想要解决的核心问题是：调用 <code>SafeMath.add()</code> 后没有将计算结果赋值回变量 <code>a</code>，导致计算结果完全无效。要修复这个问题，关键是<strong>将 <code>add()</code> 的返回值重新赋值给变量</strong>，我会分两种场景给你清晰的修改方案。</p>
<h3 id="方案1：修改本地变量-a（仅函数内有效）"><a href="#方案1：修改本地变量-a（仅函数内有效）" class="headerlink" title="方案1：修改本地变量 a（仅函数内有效）"></a>方案1：修改本地变量 <code>a</code>（仅函数内有效）</h3><p>如果你的需求只是在函数内部更新 <code>a</code> 的值（仅函数执行期间有效，不会永久存储），只需给 <code>a</code> 赋值即可。注意 <code>a</code> 是函数参数，默认是 <code>memory</code> 类型（本地变量），修改后仅在当前函数调用中生效：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>// 注意：Solidity 0.8.0+ 已内置溢出检查，SafeMath 仅对低版本必要<br>import &quot;@openzeppelin/contracts/utils/math/SafeMath.sol&quot;;<br><br>contract MyConc &#123;<br>    using SafeMath for uint;   <br>    <br>    function my_func(uint a, uint b) public &#123;<br>        // 核心修改：将 add 的返回值赋值给 a<br>        a = a.add(b); <br>        // 此时 a 的值就是 a + b 的结果（仅函数内有效）<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="方案2：永久存储计算结果（最常用）"><a href="#方案2：永久存储计算结果（最常用）" class="headerlink" title="方案2：永久存储计算结果（最常用）"></a>方案2：永久存储计算结果（最常用）</h3><p>通常我们需要将计算结果<strong>永久保存在合约中</strong>（而不是仅修改本地变量），这需要先定义一个状态变量，再把计算结果赋值给它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>import &quot;@openzeppelin/contracts/utils/math/SafeMath.sol&quot;;<br><br>contract MyConc &#123;<br>    using SafeMath for uint;   <br>    <br>    // 定义状态变量，用于永久存储计算结果<br>    uint public result; // 加 public 可外部查看结果<br>    <br>    function my_func(uint a, uint b) public &#123;<br>        // 方案2.1：直接赋值给状态变量<br>        result = a.add(b); <br>        <br>        // 或方案2.2：先修改本地a，再赋值给状态变量（按需选择）<br>        // a = a.add(b);<br>        // result = a;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="关键代码解释"><a href="#关键代码解释" class="headerlink" title="关键代码解释"></a>关键代码解释</h3><ol>
<li>**<code>a = a.add(b)</code>**：<code>SafeMath.add(x, y)</code> 本质是返回 <code>x + y</code>（并做溢出检查），这里把返回值重新赋值给 <code>a</code>，才让加法运算有实际效果；</li>
<li>**状态变量 <code>result</code>**：函数参数 <code>a</code> 是“临时变量”，函数执行结束后就会销毁，定义 <code>result</code> 这个状态变量可以把计算结果永久存在合约中，外部可通过 <code>result()</code> 方法查询；</li>
<li><strong>SafeMath 的作用</strong>：对 Solidity 0.8.0 以下版本，<code>add()</code> 会检查加法是否溢出（比如 <code>uint(-1)</code> 这种非法值），0.8.0+ 版本虽然内置了溢出检查，但使用 SafeMath 也完全兼容。</li>
</ol>
<h3 id="扩展：返回计算结果（更实用的场景）"><a href="#扩展：返回计算结果（更实用的场景）" class="headerlink" title="扩展：返回计算结果（更实用的场景）"></a>扩展：返回计算结果（更实用的场景）</h3><p>如果需要函数执行后直接返回计算结果，还可以给函数加返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">function my_func(uint a, uint b) public returns (uint) &#123;<br>    a = a.add(b);<br>    return a; // 返回计算后的a值<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ol>
<li>核心修复逻辑：<strong>必须将 <code>SafeMath.add()</code> 的返回值赋值给变量</strong>（本地变量或状态变量），否则计算无任何效果；</li>
<li>本地变量 <code>a</code> 的修改仅在函数内有效，若需永久保存结果，要定义<strong>状态变量</strong>并赋值；</li>
<li>Solidity 0.8.0+ 可直接用 <code>a + b</code> 替代 <code>a.add(b)</code>（内置溢出检查），但 SafeMath 写法对低版本更兼容。</li>
</ol>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Web3/">Web3</a>
                    
                      <a class="hover-with-bg" href="/tags/audit/">audit</a>
                    
                  </div>
                
              </div>
              
                
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/12/18/239b7516722f/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Damn Vulnerable DeFi（六）</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/12/18/35bbf2603850/">
                        <span class="hidden-mobile">我的生平（三十二）</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


            

                
                  <a id="scroll-top-button" href="#" role="button">
                    <i class="iconfont icon-arrowup" aria-hidden="true"></i>
                  </a>
                  

                    
                      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
                        

                          
      </main>

      <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://whale3070.github.io/" target="_blank" rel="nofollow noopener"><span>Whale3070</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>






  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



    </body>

  </html>