

  <!DOCTYPE html>
  <html lang="zh-CN" data-default-color-scheme=&#34;dark&#34; >
  <style>
    .text1
    {
    text-shadow: 0px 0px 2px #f2f3f2;
    }
    </style>

  

<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/null">
  <link rel="icon" type="image/png" href="/null">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>university.alchemy - whale3070&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"192.168.126.129","root":"/","version":"1.8.7","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 7.3.0"></head>


    <body>
      <header style="height: 70vh;">
        <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>InfoSec learning</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/search/">
                <i class="iconfont icon-search"></i>
                搜索
              </a>
            </li>
          
        
        
        
          
        
      </ul>
    </div>
  </div>
</nav>

          <div class="banner" id="banner" false
            style="background: url('/img/default.png') no-repeat center center;
              background-size: cover;">
              <div class="full-bg-img">
                <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
                  <div class="page-header text-center fade-in-up">
                    <span class="h2 text1" id="subtitle" title="university.alchemy">
                      
                        university.alchemy
                      
                    </span>
        
                    
                      <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2025-12-10 03:36" pubdate>
        2025年12月10日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      5.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      63
       分钟
    </span>
  

  
  
</div>

                    
                  </div>
                    
                  </div>
                  
                </div>
              </div>
          </div>
      </header>

      <main>
        
          

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" data-pagefind-body>
            <!-- SEO header -->
            <h1 style="display: none">university.alchemy</h1>
            
            <div class="markdown-body">
              <p>学习资料： <a target="_blank" rel="noopener" href="https://university.alchemy.com/course/solidity/">https://university.alchemy.com/course/solidity/</a></p>
<p>安全最大化<br>gas最小化</p>
<h1 id="EVM-opcodes-https-www-evm-codes-是什么"><a href="#EVM-opcodes-https-www-evm-codes-是什么" class="headerlink" title="EVM opcodes: https://www.evm.codes/ 是什么"></a>EVM opcodes: <a target="_blank" rel="noopener" href="https://www.evm.codes/">https://www.evm.codes/</a> 是什么</h1><p>简单来说，evm.codes 是一个用于查看和学习 Ethereum Virtual Machine（EVM）操作码（opcodes）的<strong>交互式参考网站／工具</strong>。(<a target="_blank" rel="noopener" href="https://www.evm.codes/?utm_source=chatgpt.com" title="EVM Codes - An Ethereum Virtual Machine Opcodes Interactive Reference">EVM Codes</a>)</p>
<h2 id="✅-evm-codes-是什么"><a href="#✅-evm-codes-是什么" class="headerlink" title="✅ evm.codes 是什么"></a>✅ evm.codes 是什么</h2><ul>
<li>evm.codes 提供了一个完整的 EVM opcode 表 — 列出所有 EVM 支持的基本指令（操作码）、对应的十六进制值 (0x00–0xFF)、以及它们的功能&#x2F;含义。(<a target="_blank" rel="noopener" href="https://www.evm.codes/?utm_source=chatgpt.com" title="EVM Codes - An Ethereum Virtual Machine Opcodes Interactive Reference">EVM Codes</a>)</li>
<li>除了静态表，它还是“交互式 (interactive)” — 用户可以方便地查找、阅读、对比各个 opcode（例如算术操作、存储&#x2F;内存操作、合约调用、日志、控制流等）。(<a target="_blank" rel="noopener" href="https://www.evm.codes/" title="EVM Codes - An Ethereum Virtual Machine Opcodes Interactive Reference">EVM Codes</a>)</li>
<li>evm.codes 还提供 “Playground” (演练场) 功能，让你写一些 EVM bytecode（或查看编译结果），然后观察它如何被 opcode 执行 — 对理解 EVM 内部工作机制特别有帮助。(<a target="_blank" rel="noopener" href="https://www.evm.codes/playground?utm_source=chatgpt.com" title="EVM Codes - Playground">EVM Codes</a>)</li>
</ul>
<h2 id="🧠-背景：为什么-EVM-和-opcodes-很重要"><a href="#🧠-背景：为什么-EVM-和-opcodes-很重要" class="headerlink" title="🧠 背景：为什么 EVM 和 opcodes 很重要"></a>🧠 背景：为什么 EVM 和 opcodes 很重要</h2><ul>
<li>EVM 是以太坊网络上执行智能合约 (smart contract) 的“虚拟机 (VM)”。合约（例如用 Solidity 写的合约）在部署前会被编译成“字节码 (bytecode)” —— 这些字节码最终由 EVM 解释执行。(<a target="_blank" rel="noopener" href="https://www.evm.codes/about?utm_source=chatgpt.com" title="EVM Codes - About the EVM">EVM Codes</a>)</li>
<li>“Opcodes” 是 EVM 的最底层指令 (instructions)。这些是 EVM 能识别和执行的基本操作，比如加减乘除 (ADD, SUB, MUL, DIV)，内存读写 (MLOAD &#x2F; MSTORE)，日志 (LOG), 合约调用 (CALL &#x2F; DELEGATECALL &#x2F; STATICCALL) 等。(<a target="_blank" rel="noopener" href="https://ethereum.org/developers/docs/evm/opcodes?utm_source=chatgpt.com" title="Opcodes for the EVM - ethereum.org">ethereum.org</a>)</li>
<li>因为智能合约会被编译为这些 opcodes，理解 opcodes 有助于你更深入掌握底层执行逻辑 — 对安全审计 (audit)、gas 优化、反编译、漏洞分析、以及编译器&#x2F;工具链开发都非常有用。(<a target="_blank" rel="noopener" href="https://blog.csdn.net/mutourend/article/details/127304954?utm_source=chatgpt.com" title="揭秘EVM Opcodes_evm bytecode转换op code-CSDN博客">CSDN</a>)</li>
</ul>
<h2 id="🎯-evm-codes-对谁有用-适合什么场景"><a href="#🎯-evm-codes-对谁有用-适合什么场景" class="headerlink" title="🎯 evm.codes 对谁有用 &#x2F; 适合什么场景"></a>🎯 evm.codes 对谁有用 &#x2F; 适合什么场景</h2><ul>
<li>如果你是 Solidity &#x2F; EVM 智能合约开发者 — 用它查看编译出来的 bytecode 里到底是什么 opcode，理解 gas 成本 &amp; 底层执行。</li>
<li>如果你从事合约安全、审计、漏洞分析 — 想更底层地了解合约如何执行、可能出错、如何优化 gas 或规避安全问题。</li>
<li>如果你对 EVM 工作机制 (虚拟机 + 字节码 + 执行模型) 感兴趣 — evm.codes 是一个直观、交互式的入口。</li>
<li>做教育 &#x2F; 学习 &#x2F;研究 — 比起抽象语言 (Solidity) better：直接理解 “机器语言层面” 的合约行为。</li>
</ul>
<p>如果你愿意，我可以<strong>推荐几个学习 EVM opcodes 的中文 &#x2F; 英文资源</strong>（包括教程、可视化工具、深入解释等），帮助你快速上手。你要我帮你整理吗？</p>
<h1 id="EVM-opcodes是solidity下层的语言，类似于汇编和c的关系"><a href="#EVM-opcodes是solidity下层的语言，类似于汇编和c的关系" class="headerlink" title="EVM opcodes是solidity下层的语言，类似于汇编和c的关系"></a>EVM opcodes是solidity下层的语言，类似于汇编和c的关系</h1><p>是的，<strong>EVM opcodes</strong> 确实可以看作是 Solidity 的底层语言，类似于汇编语言和高级语言（如 C 语言）之间的关系。我们可以这样理解：</p>
<h3 id="Solidity-和-EVM-Opcodes-的关系："><a href="#Solidity-和-EVM-Opcodes-的关系：" class="headerlink" title="Solidity 和 EVM Opcodes 的关系："></a>Solidity 和 EVM Opcodes 的关系：</h3><ul>
<li><strong>Solidity</strong> 是一种高级语言，它让开发者能够编写易于理解和管理的智能合约代码。就像 C 语言是为程序员设计的，而不直接对硬件进行操作一样，Solidity 主要为开发人员提供了一个高层次的接口来编写合约。</li>
<li><strong>EVM Opcodes</strong> 则是 Solidity 编译后生成的机器级指令，相当于智能合约在以太坊虚拟机（EVM）中执行时所用的“汇编”代码。它们是以太坊网络能够直接执行的操作码，类似于汇编语言在传统计算机中的角色。</li>
</ul>
<h3 id="类比汇编和-C-语言："><a href="#类比汇编和-C-语言：" class="headerlink" title="类比汇编和 C 语言："></a>类比汇编和 C 语言：</h3><ul>
<li><strong>C 语言</strong>（高级语言）编写的程序最终会被<strong>编译器</strong>转化为对应的<strong>汇编语言</strong>，然后再由汇编器（assembler）转化为机器码，这些机器码最终能被处理器执行。</li>
<li>类似地，<strong>Solidity</strong>（高级语言）编写的智能合约会被<strong>Solidity 编译器</strong>（如 <code>solc</code>）编译成 EVM 字节码，这些字节码会被解析为<strong>EVM Opcodes</strong>，最终由以太坊网络上的虚拟机（EVM）执行。</li>
</ul>
<h3 id="重要的对比："><a href="#重要的对比：" class="headerlink" title="重要的对比："></a>重要的对比：</h3><ul>
<li><strong>Solidity 编译器</strong>（如 <code>solc</code>）的工作类似于一个编译器，它将 Solidity 源代码翻译为 EVM 字节码（opcode）。</li>
<li><strong>EVM Opcodes</strong> 则类似于传统计算机中的汇编语言指令，执行这些操作码的“机器”就是 EVM（Ethereum Virtual Machine）。EVM 类似于计算机的 CPU，负责执行这些低层次的命令。</li>
</ul>
<h3 id="为什么理解-EVM-Opcodes-很重要："><a href="#为什么理解-EVM-Opcodes-很重要：" class="headerlink" title="为什么理解 EVM Opcodes 很重要："></a>为什么理解 EVM Opcodes 很重要：</h3><ol>
<li><strong>Gas 优化</strong>：因为每个 EVM 操作码的执行都有对应的 gas 消耗（即执行费用），理解这些操作码能帮助开发者优化合约的执行效率，减少不必要的 gas 消耗。</li>
<li><strong>合约安全性</strong>：了解底层操作，可以帮助你识别潜在的安全漏洞。某些 EVM 操作可能会导致安全问题，如重入攻击（Reentrancy）等。</li>
<li><strong>反向工程与审计</strong>：通过分析 EVM 字节码和操作码，可以进行合约反向工程，理解其实现方式，帮助进行合约的安全审计。</li>
</ol>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>Solidity 是用来编写智能合约的高级语言，EVM opcodes 是其编译结果的底层执行指令，类似于汇编语言和 C 语言的关系。这种层级结构使得开发者可以专注于更高效和易于理解的代码，而 EVM 则处理底层的执行和优化。</p>
<p>如果你有兴趣深入理解 EVM 操作码或进一步学习如何优化 Solidity 合约的执行，evm.codes 是一个非常实用的参考工具。</p>
<h1 id="视频笔记"><a href="#视频笔记" class="headerlink" title="视频笔记"></a>视频笔记</h1><p><a target="_blank" rel="noopener" href="https://university.alchemy.com/course/solidity/md/64e7b20d71fe4b0002cf49f4">https://university.alchemy.com/course/solidity/md/64e7b20d71fe4b0002cf49f4</a></p>
<ol>
<li>uint是uint256的缩写，或者别名</li>
<li>int8  &#x2F;&#x2F;-128 到127</li>
</ol>
<h2 id="constructor在智能合约中只运行一次，那么一般用来写什么逻辑，做什么呢？"><a href="#constructor在智能合约中只运行一次，那么一般用来写什么逻辑，做什么呢？" class="headerlink" title="constructor在智能合约中只运行一次，那么一般用来写什么逻辑，做什么呢？"></a>constructor在智能合约中只运行一次，那么一般用来写什么逻辑，做什么呢？</h2><p>在智能合约中，<strong><code>constructor</code></strong> 是一个特殊的函数，它在合约部署时执行，只运行一次。<code>constructor</code> 通常用来初始化合约的状态，设置合约的初始条件，或进行一些合约部署时必须完成的操作。</p>
<h3 id="constructor-的作用"><a href="#constructor-的作用" class="headerlink" title="constructor 的作用"></a><code>constructor</code> 的作用</h3><ul>
<li><strong>初始化状态变量</strong>：通常用于设置合约的初始状态，或者初始化重要的合约参数。例如，可以在部署合约时传入一些参数，并用这些参数初始化状态变量。</li>
<li><strong>授权设置</strong>：通常在合约的构造函数中指定合约的拥有者、管理员或授权人。这对于权限控制非常重要，确保只有特定的地址能够调用某些特权函数。</li>
<li><strong>合约依赖关系设置</strong>：如果合约需要与其他合约交互或依赖其他合约，可以在构造函数中传入其他合约的地址，设置依赖关系。</li>
<li><strong>合约初始状态的设定</strong>：可以通过 constructor 来设置初始状态，比如余额、交易的最大限制、费用的初始值等。</li>
</ul>
<h3 id="常见的构造函数用途："><a href="#常见的构造函数用途：" class="headerlink" title="常见的构造函数用途："></a>常见的构造函数用途：</h3><ol>
<li><p><strong>设置合约的拥有者（Owner）</strong></p>
<ul>
<li>通常在智能合约中，会有一个 <code>owner</code> 状态变量，指定合约的创建者或管理员。在构造函数中通常会将 <code>owner</code> 设置为部署合约的地址，以便控制权限或管理合约。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">address public owner;<br><br>constructor() &#123;<br>    owner = msg.sender;  // msg.sender 是部署合约的地址<br>&#125;<br></code></pre></div></td></tr></table></figure>
</li>
<li><p><strong>初始化合约参数</strong></p>
<ul>
<li>合约部署时可以接收参数，通过构造函数将这些参数传入并初始化合约的状态变量。例如，设置合约的初始余额、费用、某些设定等。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">uint256 public initialBalance;<br><br>constructor(uint256 _balance) &#123;<br>    initialBalance = _balance;<br>&#125;<br></code></pre></div></td></tr></table></figure>
</li>
<li><p><strong>设置管理员或授权角色</strong></p>
<ul>
<li>如果合约需要有多种角色（比如管理员、普通用户），可以在构造函数中指定某些用户的权限。例如，管理员可以有更高权限进行某些操作。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">mapping(address =&gt; bool) public admins;<br><br>constructor(address _admin) &#123;<br>    admins[_admin] = true;<br>&#125;<br></code></pre></div></td></tr></table></figure>
</li>
<li><p><strong>合约依赖的地址（其他合约的地址）</strong></p>
<ul>
<li>如果合约需要依赖其他合约（比如通过地址与其他合约交互），可以在构造函数中传入其他合约的地址并将其设置为依赖项。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">address public anotherContract;<br><br>constructor(address _contractAddress) &#123;<br>    anotherContract = _contractAddress;<br>&#125;<br></code></pre></div></td></tr></table></figure>
</li>
<li><p><strong>初始化集合或数组</strong></p>
<ul>
<li>可以在构造函数中初始化一些合约的数据集合，如数组或映射（mapping），以便在合约生命周期内使用。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">mapping(address =&gt; uint256) public balances;<br><br>constructor(address[] memory _addresses, uint256[] memory _initialBalances) &#123;<br>    for (uint i = 0; i &lt; _addresses.length; i++) &#123;<br>        balances[_addresses[i]] = _initialBalances[i];<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li>
</ol>
<h3 id="需要注意的几点："><a href="#需要注意的几点：" class="headerlink" title="需要注意的几点："></a>需要注意的几点：</h3><ol>
<li><strong>只能调用一次</strong>：<code>constructor</code> 只会在合约部署时执行一次，之后不可再调用。因此，它的逻辑通常用于初始化，而不是执行常规的合约功能。</li>
<li><strong>参数化部署</strong>：在合约部署时，构造函数的参数是可以设置的，部署者可以根据需要传递不同的值来影响合约的初始化行为。</li>
<li><strong>与 <code>fallback</code> 和 <code>receive</code> 函数不同</strong>：<code>constructor</code> 只在合约创建时执行一次，而 <code>fallback</code> 和 <code>receive</code> 函数则用于接收 Ether 并响应特定的调用。</li>
</ol>
<h3 id="示例：一个简单的智能合约的构造函数"><a href="#示例：一个简单的智能合约的构造函数" class="headerlink" title="示例：一个简单的智能合约的构造函数"></a>示例：一个简单的智能合约的构造函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">pragma solidity ^0.8.0;<br><br>contract MyContract &#123;<br>    address public owner;<br>    uint256 public totalSupply;<br>    <br>    // 通过构造函数初始化合约<br>    constructor(uint256 _initialSupply) &#123;<br>        owner = msg.sender;           // 将合约部署者设为拥有者<br>        totalSupply = _initialSupply; // 初始化代币总供应量<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>在这个例子中：</p>
<ul>
<li><code>owner</code> 会被设置为部署合约的账户地址。</li>
<li><code>totalSupply</code> 会被初始化为部署时传入的参数 <code>_initialSupply</code>。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>constructor</code> 在 Solidity 合约中用于合约的初始化操作，通常包括设置初始状态、赋值权限、配置依赖等。它在合约部署时执行一次，不可再被调用，确保合约的初始化逻辑只运行一次。</p>
<h2 id="constructor在-Solidity-合约中用于合约的初始化操作，只运行一次。但智能合约不一定要有constructor对吗"><a href="#constructor在-Solidity-合约中用于合约的初始化操作，只运行一次。但智能合约不一定要有constructor对吗" class="headerlink" title="constructor在 Solidity 合约中用于合约的初始化操作，只运行一次。但智能合约不一定要有constructor对吗"></a>constructor在 Solidity 合约中用于合约的初始化操作，只运行一次。但智能合约不一定要有constructor对吗</h2><p>是的，<strong>智能合约并不一定需要有 <code>constructor</code></strong>。在 Solidity 中，<code>constructor</code> 是可选的，如果不定义构造函数，合约仍然可以正常部署和运行。</p>
<h3 id="什么时候可以不使用-constructor？"><a href="#什么时候可以不使用-constructor？" class="headerlink" title="什么时候可以不使用 constructor？"></a>什么时候可以不使用 <code>constructor</code>？</h3><ul>
<li><strong>不需要初始化状态变量</strong>：如果你的合约没有特别需要在部署时初始化的状态变量，那么就可以省略 <code>constructor</code>。在这种情况下，Solidity 会自动使用默认值初始化所有状态变量（例如 <code>0</code>、<code>false</code>、<code>&quot;&quot;</code> 等）。</li>
<li><strong>合约逻辑无需部署时设置特殊参数</strong>：如果合约的初始化不依赖于外部参数（如传入初始值），那么也可以省略 <code>constructor</code>，让合约的行为从合约部署后的第一个函数调用开始。</li>
</ul>
<h3 id="默认情况下的初始化行为"><a href="#默认情况下的初始化行为" class="headerlink" title="默认情况下的初始化行为"></a>默认情况下的初始化行为</h3><p>如果合约没有定义构造函数（<code>constructor</code>），Solidity 会自动为状态变量赋予默认值：</p>
<ul>
<li>数值类型（如 <code>uint256</code>、<code>int</code>）会初始化为 <code>0</code>。</li>
<li>布尔类型（<code>bool</code>）会初始化为 <code>false</code>。</li>
<li>地址类型（<code>address</code>）会初始化为 <code>0x0000000000000000000000000000000000000000</code>。</li>
<li>字符串、字节数组等引用类型会初始化为空（<code>&quot;&quot;</code> 或 <code>bytes(&quot;&quot;)</code>）。</li>
</ul>
<h3 id="示例：没有-constructor-的合约"><a href="#示例：没有-constructor-的合约" class="headerlink" title="示例：没有 constructor 的合约"></a>示例：没有 <code>constructor</code> 的合约</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">pragma solidity ^0.8.0;<br><br>contract NoConstructorContract &#123;<br>    address public owner;<br>    uint256 public balance;<br><br>    // 合约没有构造函数，状态变量会被初始化为默认值<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>在这个例子中：</p>
<ul>
<li><code>owner</code> 会被自动初始化为 <code>0x0000000000000000000000000000000000000000</code>（空地址）。</li>
<li><code>balance</code> 会被自动初始化为 <code>0</code>。</li>
</ul>
<h3 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h3><ul>
<li><p><strong>访问权限和初始化</strong>：如果你的合约有特定的权限（如只有某个地址才能执行某些操作），通常使用 <code>constructor</code> 来初始化这些权限。例如，在 <code>constructor</code> 中设置合约的拥有者。没有 <code>constructor</code> 时，你可能需要设计一个额外的函数来初始化这些权限。</p>
</li>
<li><p><strong>依赖合约地址</strong>：如果合约需要依赖其他合约（比如依赖某个预先部署的合约地址），通常也会通过 <code>constructor</code> 来传入这些依赖项。如果没有 <code>constructor</code>，则可能需要其他方式来设置这些依赖。</p>
</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>虽然 <code>constructor</code> 是一个非常常见和有用的功能，用于在部署时初始化合约状态，但它并不是强制性的。智能合约可以没有 <code>constructor</code>，并且它的状态变量会被自动初始化为默认值。如果合约不需要初始化操作或部署时参数，可以省略构造函数。</p>
<h2 id="你的目标：创建无符号整数！"><a href="#你的目标：创建无符号整数！" class="headerlink" title="你的目标：创建无符号整数！"></a><strong>你的目标：创建无符号整数！</strong></h2><p>在我们的合约中创建三个公共存储的无符号整数：<code>a</code>、<code>b</code> 和 <code>sum</code>。</p>
<ul>
<li>将变量 <code>a</code> 定义为 <code>uint8</code> 类型，其初始值应在 0 到 255 之间。</li>
<li>将变量 <code>b</code> 定义为 <code>uint16</code> 类型，其值应至少为 256。</li>
<li>变量 <code>sum</code> 应该是 <code>uint256</code> 类型，表示 <code>a</code> 和 <code>b</code> 存储的值之和。</li>
</ul>
<p>答案：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-comment">// SPDX-License-Identifier: MIT</span><br>pragma solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.20</span>;<br><br>contract Contract &#123;<br>  <span class="hljs-built_in">uint8</span> <span class="hljs-keyword">public</span> a = <span class="hljs-number">254</span>;<br>  <span class="hljs-built_in">uint16</span> <span class="hljs-keyword">public</span> b = <span class="hljs-number">256</span>;<br>  <span class="hljs-built_in">uint</span>256 <span class="hljs-keyword">public</span> sum = a + b;  <br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="你的目标：创建带符号整数！"><a href="#你的目标：创建带符号整数！" class="headerlink" title="你的目标：创建带符号整数！"></a><strong>你的目标：创建带符号整数！</strong></h2><p>创建三个公共存储的整数：<code>a</code>、<code>b</code> 和 <code>difference</code>。</p>
<ul>
<li>将变量 <code>a</code> 和 <code>b</code> 定义为 <code>int8</code> 类型，其中一个值必须是正数，另一个值必须是负数。</li>
<li>将变量 <code>difference</code> 定义为 <code>int16</code> 类型，它表示 <code>a</code> 和 <code>b</code> 之间的绝对差值。</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-comment">// SPDX-License-Identifier: MIT</span><br>pragma solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.20</span>;<br><br>contract Contract &#123;<br>  <span class="hljs-built_in">int8</span> <span class="hljs-keyword">public</span> a = <span class="hljs-number">10</span>;<br>  <span class="hljs-built_in">int8</span> <span class="hljs-keyword">public</span> b = <span class="hljs-number">-10</span>;<br>  <span class="hljs-built_in">int16</span> <span class="hljs-keyword">public</span> difference = a - b;<br>&#125;<br></code></pre></div></td></tr></table></figure>


<h2 id="你的目标：Hello-World"><a href="#你的目标：Hello-World" class="headerlink" title="你的目标：Hello World"></a><strong>你的目标：Hello World</strong></h2><p>是时候在 Solidity 中实现 Hello World 了！</p>
<ul>
<li>创建一个公共的 <code>bytes32</code> 存储变量 <code>msg1</code>，它存储字符串字面量 <code>&quot;Hello World&quot;</code>。</li>
<li>创建一个公共的 <code>string</code> 存储变量 <code>msg2</code>，它存储一个需要超过 32 字节来存储的字符串字面量。</li>
</ul>
<p>答案：</p>
<figure class="highlight d"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: MIT</span><br><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.20</span>;<br><br>contract Contract &#123;<br>	bytes32 <span class="hljs-keyword">public</span> msg1 = <span class="hljs-string">&quot;Hello World&quot;</span>;<br>    <span class="hljs-built_in">string</span> <span class="hljs-keyword">public</span> msg2 = <span class="hljs-string">&quot;ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc&quot;</span>;<br>&#125;<br><br></code></pre></div></td></tr></table></figure>

<h2 id="你的目标：做一些食物！"><a href="#你的目标：做一些食物！" class="headerlink" title="你的目标：做一些食物！"></a><strong>你的目标：做一些食物！</strong></h2><p>在提供的 <code>enum</code> 中，你将看到四种类型的食物。</p>
<p>将这些值分别存储在 <code>food1</code>、<code>food2</code>、<code>food3</code> 和 <code>food4</code> 中。</p>
<figure class="highlight d"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: MIT</span><br><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.20</span>;<br><br>contract Contract &#123;<br>    <span class="hljs-keyword">enum</span> Foods &#123; Apple, Pizza, Bagel, Banana &#125;<br><br>	Foods <span class="hljs-keyword">public</span> food1 = Foods.Apple;<br>	Foods <span class="hljs-keyword">public</span> food2 = Foods.Pizza;<br>	Foods <span class="hljs-keyword">public</span> food3 = Foods.Bagel;<br>	Foods <span class="hljs-keyword">public</span> food4 = Foods.Banana;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="你的目标：无符号整数构造函数"><a href="#你的目标：无符号整数构造函数" class="headerlink" title="你的目标：无符号整数构造函数"></a><strong>你的目标：无符号整数构造函数</strong></h2><p>创建一个构造函数，该构造函数将一个 <code>uint</code> 作为参数传入。<br>将这个 <code>uint</code> 值存储在一个名为 <code>x</code> 的公共存储变量中。</p>
<p>答案：</p>
<figure class="highlight d"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: MIT</span><br><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.20</span>;<br><br>contract Contract &#123;<br>  <span class="hljs-built_in">uint</span> <span class="hljs-keyword">public</span> x;<br><br>  constructor(<span class="hljs-built_in">uint</span> _x) &#123;<br>    x = _x;  <span class="hljs-comment">// 直接修改状态变量 x</span><br>  &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure>

<h3 id="变量遮蔽"><a href="#变量遮蔽" class="headerlink" title="变量遮蔽"></a><strong>变量遮蔽</strong></h3><p>让我们来看一个变量遮蔽的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">string public name;<br><br>constructor(string name) &#123;<br>    // name 被遮蔽了！<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>在这种情况下，<strong>状态变量 <code>name</code> 被参数 <code>name</code> 遮蔽</strong>了！</p>
<p>编译器会在我们这样做时发出警告。编译器会提示：“警告：此声明遮蔽了一个已存在的声明。”，并且会显示被遮蔽的变量和已存在的声明。编译器的警告对于调试和避免常见错误非常有帮助。</p>
<p><strong>从技术上讲，有一种方法可以解决这个问题：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">contract MyContract &#123;<br>    string public name;<br><br>    constructor(string name) &#123;<br>        MyContract.name = name;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>现在我们使用对 <code>MyContract</code> 的引用来更新状态变量。这不是典型的做法。通常，你会看到参数前加上下划线（例如 <code>_variableName</code>），而不是其他方式。</p>
<p><strong>解释：</strong></p>
<ul>
<li>通过 <code>MyContract.name</code> 显式地引用合约的状态变量，可以避免与构造函数参数 <code>name</code> 的遮蔽。</li>
<li>然而，这种方法并不常见，通常开发者会使用带下划线的命名约定（如 <code>_name</code>）来区分参数和状态变量。</li>
</ul>
<p><strong>Solidity 参数</strong></p>
<p>我们首先要讨论的是构造函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">bool public isOpen;<br><br>constructor() &#123;<br>    isOpen = true;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>在这里，我们在合约部署时设置了一个存储变量的值。</p>
<p>Solidity 合约的构造函数与许多面向对象语言中的类的构造函数非常相似。构造函数仅在合约部署时调用一次，之后再也不会调用。它通常用于设置合约的初始值。</p>
<p><strong>如果我们想让合约的部署者决定 <code>isOpen</code> 的值呢？</strong></p>
<p>我们可以向构造函数传递一个参数！让我们看看如何实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">bool public isOpen;<br><br>constructor(bool _isOpen) &#123;<br>    isOpen = _isOpen;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>看看！现在合约的部署者可以决定 <code>isOpen</code> 的值了。</p>
<p>**注意：**参数名称（<code>_isOpen</code>）前面有一个下划线吗？这防止了变量与存储变量同名。当名字冲突时，这叫做“变量遮蔽（variable shadowing）”。在 Solidity 中，这种情况经常发生，因为我们可以在不使用 <code>this</code> 的情况下引用存储变量。让我们深入探讨一下这个问题。</p>
<h2 id="你的目标：添加一个无符号整数"><a href="#你的目标：添加一个无符号整数" class="headerlink" title="你的目标：添加一个无符号整数"></a><strong>你的目标：添加一个无符号整数</strong></h2><p>创建一个外部的 <code>view</code> 函数 <code>add</code>，该函数接收一个 <code>uint</code> 参数，并返回该参数与状态变量 <code>x</code> 的和。</p>
<p>答案：</p>
<figure class="highlight zephir"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs zephir"><span class="hljs-comment">// SPDX-License-Identifier: MIT</span><br>pragma solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.20</span>;<br><br>contract Contract &#123;<br>  <span class="hljs-keyword">uint</span> <span class="hljs-keyword">public</span> x;<br><br>  constructor(<span class="hljs-keyword">uint</span> _x) &#123;<br>    x = _x;  <span class="hljs-comment">// 直接修改状态变量 x</span><br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> <span class="hljs-title">external</span> </span>&#123;<br>    x+=<span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">uint</span> y)</span> <span class="hljs-title">external</span> <span class="hljs-title">view</span> <span class="hljs-title">returns</span><span class="hljs-params">(<span class="hljs-keyword">uint</span>)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> y+x;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="你的目标：返回秘密"><a href="#你的目标：返回秘密" class="headerlink" title="你的目标：返回秘密"></a><strong>你的目标：返回秘密</strong></h2><p>在 <code>winningNumber</code> 函数中传递给你一个消息。你可以使用 <code>console.log</code> 将这个消息显示到控制台。它会告诉你接下来该怎么做！</p>
<p>我们还没有讨论 <code>calldata</code> 关键字。我们将在接下来的关于引用类型的课程中介绍这个关键字。现在，请了解对于引用类型（如 <code>string</code>），<code>calldata</code> 指定了数据的位置，具体来说，它表示该值位于消息调用数据中！</p>
<h2 id="Your-Goal-Return-the-Secret"><a href="#Your-Goal-Return-the-Secret" class="headerlink" title="Your Goal: Return the Secret"></a>Your Goal: Return the Secret</h2><p>There is a message being passed to you in the winningNumber function. You can use console.log to display this message to the console. It will tell you what to do from there!</p>
<figure class="highlight arcade"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arcade"><span class="hljs-comment">// SPDX-License-Identifier: UNLICENSED</span><br>pragma solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.20</span>;<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;forge-std/console.sol&quot;</span>;<br><br>contract Contract &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">winningNumber</span>(<span class="hljs-params">string calldata secretMessage</span>) <span class="hljs-title function_">external</span> <span class="hljs-title function_">returns</span>(<span class="hljs-params">uint</span>) &#123;<br>       <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(secretMessage); <br>       <span class="hljs-keyword">return</span> <span class="hljs-number">794</span>;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure>

<h2 id="Your-Goal-Double-Uint"><a href="#Your-Goal-Double-Uint" class="headerlink" title="Your Goal: Double Uint"></a>Your Goal: Double Uint</h2><p>Create an external, pure function called double which takes a uint parameter and doubles it. It should return this doubled uint value.</p>
<figure class="highlight d"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: MIT</span><br><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.20</span>;<br><br>contract Contract &#123;<br>  <span class="hljs-built_in">function</span> <span class="hljs-built_in">double</span>(<span class="hljs-built_in">uint</span> x) external <span class="hljs-keyword">pure</span><br>  returns(<span class="hljs-built_in">uint</span> sum) &#123;<br>      sum = <span class="hljs-number">2</span>*x;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="你的目标：重载-Double"><a href="#你的目标：重载-Double" class="headerlink" title="你的目标：重载 Double"></a><strong>你的目标：重载 Double</strong></h2><p>创建另一个 <code>pure</code> 类型的外部函数 <code>double</code>，该函数接收两个 <code>uint</code> 参数。<br>将这两个参数分别乘以 2，并按传入函数的顺序返回这两个值。</p>
<figure class="highlight d"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: MIT</span><br><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.20</span>;<br><br>contract Contract &#123;<br>  <span class="hljs-built_in">function</span> <span class="hljs-built_in">double</span>(<span class="hljs-built_in">uint</span> x) external <span class="hljs-keyword">pure</span><br>  returns(<span class="hljs-built_in">uint</span> sum) &#123;<br>      sum = <span class="hljs-number">2</span>*x;<br>  &#125;<br>  <span class="hljs-built_in">function</span> <span class="hljs-built_in">double</span>(<span class="hljs-built_in">uint</span> x, <span class="hljs-built_in">uint</span> y) <span class="hljs-keyword">public</span> <span class="hljs-keyword">pure</span> returns (<span class="hljs-built_in">uint</span>, <span class="hljs-built_in">uint</span>) &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span> * x, <span class="hljs-number">2</span> * y);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="Message-Calls"><a href="#Message-Calls" class="headerlink" title="Message Calls"></a>Message Calls</h2><p><strong>Message Calls</strong> 是指在以太坊智能合约中通过 <strong>调用</strong> 来发送数据和执行函数的过程。这些调用可以携带 <strong>以太币（Ether）</strong> 和 <strong>数据</strong>，并且会触发智能合约内的特定函数执行。</p>
<p>在 Solidity 和以太坊中，<strong>message call</strong> 是一种由外部账户或合约发送到另一个合约的请求，可以包括：</p>
<ul>
<li><strong>数据</strong>（比如函数参数）</li>
<li><strong>价值</strong>（即转账一定数量的以太币）</li>
</ul>
<h3 id="主要特点："><a href="#主要特点：" class="headerlink" title="主要特点："></a>主要特点：</h3><ol>
<li><p><strong>传递数据和价值</strong>：</p>
<ul>
<li><strong>数据</strong>：通常是发送给合约函数的参数，或者是调用某个特定函数的指令。</li>
<li><strong>价值</strong>：可以携带一定数量的以太币（ETH）与消息一起发送，以太币的转账可以通过这种方式进行。</li>
</ul>
</li>
<li><p><strong>调用函数</strong>：</p>
<ul>
<li>当发送消息时，通常会触发目标合约中的某个函数，函数的执行逻辑就会根据传入的参数进行处理。</li>
</ul>
</li>
<li><p><strong>消息调用的发送方式</strong>：</p>
<ul>
<li><strong>外部账户（Externally Owned Accounts, EOAs）</strong> 可以直接发送消息（包括以太币）到智能合约。</li>
<li><strong>智能合约之间</strong> 也可以通过消息调用进行交互。</li>
</ul>
</li>
</ol>
<h3 id="两种主要的消息调用类型："><a href="#两种主要的消息调用类型：" class="headerlink" title="两种主要的消息调用类型："></a>两种主要的消息调用类型：</h3><ol>
<li><p><strong>普通调用（Call）</strong>：</p>
<ul>
<li><strong>无值（没有以太币）</strong>：如果你只是调用合约的函数而不发送任何以太币，那么这个调用就是普通的消息调用。</li>
<li><strong>返回值</strong>：这种调用通常有一个返回值（例如函数计算后的结果）。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">// 普通消息调用的例子<br>(bool success, bytes memory data) = address(myContract).call(abi.encodeWithSignature(&quot;functionName(uint256)&quot;, 123));<br></code></pre></div></td></tr></table></figure>
</li>
<li><p><strong>带值的调用（Transfer）</strong>：</p>
<ul>
<li><strong>发送以太币</strong>：这种调用不仅触发合约的函数执行，还可以将一定数量的以太币发送给目标合约。</li>
<li>这种调用通常使用 <code>transfer</code> 或 <code>send</code> 来发送 ETH。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">// 向合约发送 1 ether 的例子<br>address(myContract).transfer(1 ether);<br></code></pre></div></td></tr></table></figure></li>
</ol>
<h3 id="message-call-的常见用途："><a href="#message-call-的常见用途：" class="headerlink" title="message call 的常见用途："></a><code>message call</code> 的常见用途：</h3><ul>
<li><strong>合约间交互</strong>：一个合约可以调用另一个合约的函数并传递参数。</li>
<li><strong>合约与外部账户的交互</strong>：外部账户可以向合约发送以太币，同时触发合约中的函数。</li>
</ul>
<h3 id="示例：发送消息并调用函数"><a href="#示例：发送消息并调用函数" class="headerlink" title="示例：发送消息并调用函数"></a>示例：发送消息并调用函数</h3><p>假设你有一个合约 <code>MyContract</code>，其中有一个函数 <code>setNumber</code> 用来设置一个数值 <code>x</code>，并且这个函数能够接收 ETH：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">pragma solidity ^0.8.20;<br><br>contract MyContract &#123;<br>    uint public x;<br><br>    // 接收 ETH 的函数并设置 x<br>    function setNumber(uint _x) external payable &#123;<br>        require(msg.value == 1 ether, &quot;You need to send exactly 1 ether&quot;);<br>        x = _x;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>外部账户可以通过 <code>message call</code> 发送交易并传递数据，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">// 使用 web3.js 或 ethers.js 等库调用这个合约函数<br>myContract.setNumber(42, &#123; value: web3.utils.toWei(&quot;1&quot;, &quot;ether&quot;) &#125;);<br></code></pre></div></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li><code>setNumber</code> 是一个可以接收 ETH 和数据（<code>_x</code>）的函数。</li>
<li>外部账户调用 <code>setNumber</code> 时，发送了 <code>1 ether</code> 和 <code>42</code> 作为参数，触发了合约中的 <code>setNumber</code> 函数，并且 <code>x</code> 被设置为 42。</li>
</ul>
<h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><p><strong>Message calls</strong> 是智能合约之间或外部账户与智能合约之间的交互方式，通过这种方式，我们可以传递数据和以太币，并调用合约中的函数。这是以太坊生态系统中智能合约交互的核心机制之一。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Web3/">Web3</a>
                    
                  </div>
                
              </div>
              
                
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/12/11/30587.html">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">university.alchemy2</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/12/09/39221.html">
                        <span class="hidden-mobile">remix编译运行solidity13</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


            

                
                  <a id="scroll-top-button" href="#" role="button">
                    <i class="iconfont icon-arrowup" aria-hidden="true"></i>
                  </a>
                  

                    

                          
      </main>

      <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://whale3070.github.io/" target="_blank" rel="nofollow noopener"><span>Whale3070</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<link href="/pagefind/pagefind-ui.css" rel="stylesheet">
  <script src="/pagefind/pagefind-ui.js"></script>
  <style>
    /* 搜索框配色适配 */
    #search { margin-top: 2rem; }
    [data-user-color-scheme='dark'] .pagefind-ui {
      --pagefind-ui-primary: #eeeeee;
      --pagefind-ui-text: #eeeeee;
      --pagefind-ui-background: #151515;
      --pagefind-ui-border: #333;
    }
  </style>
    </body>

  </html>