

  <!DOCTYPE html>
  <html lang="en" data-default-color-scheme=&#34;dark&#34; >
  <style>
    .text1
    {
    text-shadow: 0px 0px 2px #f2f3f2;
    }
    </style>

  

<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/null">
  <link rel="icon" type="image/png" href="/null">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>cyfrin-updraft - whale3070&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.7","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


    <body>
      <header style="height: 70vh;">
        <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>InfoSec learning</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          
        
      </ul>
    </div>
  </div>
</nav>

          <div class="banner" id="banner" false
            style="background: url('/img/default.png') no-repeat center center;
              background-size: cover;">
              <div class="full-bg-img">
                <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
                  <div class="page-header text-center fade-in-up">
                    <span class="h2 text1" id="subtitle" title="cyfrin-updraft">
                      
                        cyfrin-updraft
                      
                    </span>
        
                    
                      <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2025-12-07 09:00" pubdate>
        December 7, 2025 am
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      5.9k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      68
       分钟
    </span>
  

  
  
</div>

                    
                  </div>
                    
                  </div>
                  
                </div>
              </div>
          </div>
      </header>

      <main>
        
          

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">cyfrin-updraft</h1>
            
            <div class="markdown-body">
              <p>在这一篇<a target="_blank" rel="noopener" href="https://whale3070.com/2025/12/04/174fda3b6dc3/">文章</a>中介绍过cyfrin-updraft，所以就不赘述了</p>
<p>学习资源： <a target="_blank" rel="noopener" href="https://updraft.cyfrin.io/courses/solidity/simple-storage/introduction">https://updraft.cyfrin.io/courses/solidity/simple-storage/introduction</a><br><a target="_blank" rel="noopener" href="https://github.com/Cyfrin/foundry-full-course-cu">https://github.com/Cyfrin/foundry-full-course-cu</a><br>Blockchain Developer, Smart Contract, &amp; Solidity Career Path - Powered By AI - Beginner to Expert Course<br>| Foundry Edition 2024 |</p>
<h1 id="英语学习笔记："><a href="#英语学习笔记：" class="headerlink" title="英语学习笔记："></a>英语学习笔记：</h1><h3 id="1-pace-yourself"><a href="#1-pace-yourself" class="headerlink" title="1. pace yourself"></a>1. pace yourself</h3><p><strong>核心翻译</strong>：调整节奏；量力而行（尤指避免因急于求成而过度消耗）<br><strong>场景与用法</strong>：  </p>
<ul>
<li>常用于提醒他人在工作、学习或体力活动中合理分配精力，避免疲劳或失误。<br>例：You’ve got a whole week to finish the project—<em>pace yourself</em> and don’t work all night.（你有一整周时间完成这个项目，调整好节奏，别熬通宵。）  </li>
<li>在运动场景中可译为“控制速度”，如：<em>Pace yourself</em> in the marathon, or you’ll burn out at the halfway mark.（马拉松比赛中要控制好速度，不然中途就会体力不支。）  </li>
</ul>
<h3 id="2-gets-ingrained"><a href="#2-gets-ingrained" class="headerlink" title="2. gets ingrained"></a>2. gets ingrained</h3><p><strong>核心翻译</strong>：变得根深蒂固；深入人心（尤指习惯、观念等逐渐固化，难以改变）<br><strong>语法说明</strong>：“get + 过去分词”表被动或状态变化，“ingrained”本义为“根深蒂固的”，此处强调“从无到有、逐渐固化”的过程。<br><strong>场景与用法</strong>：  </p>
<ul>
<li>描述习惯养成：Bad habits like procrastination <em>get ingrained</em> if you don’t make an effort to change them.（如果不刻意改变，拖延这类坏习惯会变得根深蒂固。）  </li>
<li>描述观念或文化认知：In some industries, the idea that “longer hours mean better work” <em>has gotten ingrained</em> over time.（在一些行业，“工作时间越长=工作越好”的观念逐渐深入人心。）  </li>
</ul>
<p>结合你正在学习Solidity的场景，可延伸例句：Consistent coding practice helps good programming habits <em>get ingrained</em> faster.（持续的编码练习能让良好的编程习惯更快根深蒂固。）</p>
<h3 id="3-get-our-hands-on"><a href="#3-get-our-hands-on" class="headerlink" title="3. get our hands on"></a>3. get our hands on</h3><p>“get our hands on” 是口语化表达，意为 “获取、得到”，翻译时用 “获取” 更符合技术文档的简洁性，若用于日常沟通，也可表述为 “拿到”</p>
<h1 id="错题分析1"><a href="#错题分析1" class="headerlink" title="错题分析1"></a>错题分析1</h1><p>What does compiling a contract mean?<br>为什么这个答案是错误的：It converts high-level Solidity functions into machine code that runs natively on any blockchain, eliminating the need for the EVM. 而这个答案是正确的：It converts the Solidity code into bytecode and ABI that can be understood and executed by the Ethereum Virtual Machine (EVM).</p>
<p>要理解两个答案的对错，核心在于<strong>Solidity合约编译的本质</strong>、<strong>区块链虚拟机（EVM）的核心作用</strong>，以及“机器码”和“字节码”的关键区别——我们拆解成3个核心要点讲清楚：</p>
<h3 id="一、错误答案的核心问题（3个致命偏差）"><a href="#一、错误答案的核心问题（3个致命偏差）" class="headerlink" title="一、错误答案的核心问题（3个致命偏差）"></a>一、错误答案的核心问题（3个致命偏差）</h3><p>错误答案：<em>It converts high-level Solidity functions into machine code that runs natively on any blockchain, eliminating the need for the EVM.</em></p>
<h4 id="1-“machine-code（机器码）”是完全错误的"><a href="#1-“machine-code（机器码）”是完全错误的" class="headerlink" title="1. “machine code（机器码）”是完全错误的"></a>1. “machine code（机器码）”是完全错误的</h4><ul>
<li>Solidity编译输出的不是“机器码”：机器码是直接能被CPU（如x86/ARM架构）执行的二进制指令，依赖具体的硬件架构；</li>
<li>而Solidity编译的产物是<strong>EVM字节码（EVM Bytecode）</strong> ——这是专门为以太坊虚拟机设计的“虚拟指令集”，不是硬件能直接执行的机器码，只能在EVM中运行。</li>
</ul>
<h4 id="2-“runs-natively-on-any-blockchain”（原生运行在任意区块链）违背事实"><a href="#2-“runs-natively-on-any-blockchain”（原生运行在任意区块链）违背事实" class="headerlink" title="2. “runs natively on any blockchain”（原生运行在任意区块链）违背事实"></a>2. “runs natively on any blockchain”（原生运行在任意区块链）违背事实</h4><ul>
<li>不同区块链有不同的虚拟机：比如以太坊用EVM，Solana用Sealevel，Avalanche C-Chain兼容EVM但本质还是依赖EVM，不存在“能原生运行在任意区块链”的编译产物；</li>
<li>Solidity是为EVM生态设计的语言，其编译产物仅适配EVM（或兼容EVM的链），无法直接在非EVM链上“原生运行”。</li>
</ul>
<h4 id="3-“eliminating-the-need-for-the-EVM”（无需EVM）完全颠倒逻辑"><a href="#3-“eliminating-the-need-for-the-EVM”（无需EVM）完全颠倒逻辑" class="headerlink" title="3. “eliminating the need for the EVM”（无需EVM）完全颠倒逻辑"></a>3. “eliminating the need for the EVM”（无需EVM）完全颠倒逻辑</h4><ul>
<li>EVM是以太坊智能合约的“执行环境”，也是Solidity设计的核心目标：Solidity代码必须先编译成EVM能识别的字节码，再部署到EVM中执行——<strong>EVM是Solidity合约运行的必要条件</strong>，而非可省略的环节。</li>
</ul>
<h3 id="二、正确答案的核心逻辑（精准匹配编译本质）"><a href="#二、正确答案的核心逻辑（精准匹配编译本质）" class="headerlink" title="二、正确答案的核心逻辑（精准匹配编译本质）"></a>二、正确答案的核心逻辑（精准匹配编译本质）</h3><p>正确答案：<em>It converts the Solidity code into bytecode and ABI that can be understood and executed by the Ethereum Virtual Machine (EVM).</em></p>
<h4 id="1-编译产物的准确性：Bytecode-ABI"><a href="#1-编译产物的准确性：Bytecode-ABI" class="headerlink" title="1. 编译产物的准确性：Bytecode + ABI"></a>1. 编译产物的准确性：Bytecode + ABI</h4><ul>
<li><strong>Bytecode（字节码）</strong>：Solidity代码编译后的核心产物，是一串十六进制的EVM指令（如<code>0x6080604052...</code>），部署到以太坊后，EVM会逐条执行这些指令；</li>
<li><strong>ABI（Application Binary Interface，应用二进制接口）</strong>：相当于“合约的说明书”，定义了合约的函数、参数、返回值等格式——外部程序（如前端、钱包）需要通过ABI才能调用合约的函数，这是错误答案完全遗漏的关键部分。</li>
</ul>
<h4 id="2-执行环境的准确性：EVM是唯一执行者"><a href="#2-执行环境的准确性：EVM是唯一执行者" class="headerlink" title="2. 执行环境的准确性：EVM是唯一执行者"></a>2. 执行环境的准确性：EVM是唯一执行者</h4><p>Solidity的设计初衷就是为EVM编写智能合约，其编译过程本质是“将人类可读的Solidity代码，转换成EVM专属的可执行指令”——正确答案精准点出“EVM能理解并执行”，符合以太坊的核心运行逻辑。</p>
<h3 id="总结：关键认知边界"><a href="#总结：关键认知边界" class="headerlink" title="总结：关键认知边界"></a>总结：关键认知边界</h3><table>
<thead>
<tr>
<th>错误答案的误区</th>
<th>正确的核心逻辑</th>
</tr>
</thead>
<tbody><tr>
<td>产物是“机器码”</td>
<td>产物是EVM专属“字节码”+ABI</td>
</tr>
<tr>
<td>可在任意区块链原生运行</td>
<td>仅适配EVM（或兼容EVM的链）</td>
</tr>
<tr>
<td>无需EVM</td>
<td>EVM是Solidity合约运行的必要环境</td>
</tr>
</tbody></table>
<p>简单来说：Solidity编译不是“跨硬件的机器码转换”，而是“针对EVM的指令转换”，且必须输出ABI才能让合约被外部调用——这也是以太坊智能合约开发的基础认知。</p>
<h1 id="错题分析2"><a href="#错题分析2" class="headerlink" title="错题分析2"></a>错题分析2</h1><p>Why can’t the storage location be used for new variables inside a function in Solidity? 答案：Because storage variables are meant to persist between function calls and are only declared at the contract level.我选的答案是：Because storage variables are reserved for constants only.</p>
<h3 id="1-核心概念澄清：Solidity-中-Storage-的本质"><a href="#1-核心概念澄清：Solidity-中-Storage-的本质" class="headerlink" title="1. 核心概念澄清：Solidity 中 Storage 的本质"></a>1. 核心概念澄清：Solidity 中 Storage 的本质</h3><p>Solidity 里的 <strong>Storage</strong> 是以太坊区块链上的<strong>持久化存储区域</strong>，属于合约账户的永久状态（对比 Memory 是函数执行时的临时内存）。其核心规则是：</p>
<ul>
<li>Storage 变量<strong>仅能在合约级别（全局）声明</strong>，生命周期与合约一致，跨函数调用持久化；</li>
<li>函数内部<strong>无法直接声明新的 Storage 变量</strong>（仅能引用已有的合约级 Storage 变量，或通过指针/引用操作）。</li>
</ul>
<h3 id="2-你的答案错误原因：“Storage-仅用于常量”是完全错误的"><a href="#2-你的答案错误原因：“Storage-仅用于常量”是完全错误的" class="headerlink" title="2. 你的答案错误原因：“Storage 仅用于常量”是完全错误的"></a>2. 你的答案错误原因：“Storage 仅用于常量”是完全错误的</h3><ul>
<li><strong>常量（constant/immutable）</strong> 并不存储在 Storage 中：<ul>
<li><code>constant</code> 变量的值编译期确定，直接嵌入字节码，不占用 Storage 插槽；</li>
<li><code>immutable</code> 变量部署时赋值，也不占用常规 Storage 插槽，存储在合约字节码的特殊区域；</li>
</ul>
</li>
<li>Storage 真正存储的是<strong>合约的可变状态变量</strong>（比如用户余额、代币持仓等），而非常量——这是你答案的核心错误。</li>
</ul>
<h3 id="3-正确答案的逻辑解析"><a href="#3-正确答案的逻辑解析" class="headerlink" title="3. 正确答案的逻辑解析"></a>3. 正确答案的逻辑解析</h3><p>“Because storage variables are meant to persist between function calls and are only declared at the contract level.”<br>（因为 Storage 变量旨在跨函数调用持久化，且仅能在合约级别声明）</p>
<ul>
<li><strong>跨函数持久化</strong>：Storage 是合约的“永久内存”，如果允许函数内声明新的 Storage 变量，会导致这些变量的生命周期与函数绑定（执行完就销毁），违背 Storage 的设计初衷；</li>
<li><strong>仅合约级声明</strong>：Solidity 语法强制 Storage 变量在合约全局作用域声明，函数内只能操作（读取/修改）已存在的 Storage 变量，无法新建——这是语言层面的硬性规则，也是函数内不能用 Storage 声明新变量的直接原因。</li>
</ul>
<h3 id="4-补充：函数内操作-Storage-的正确方式"><a href="#4-补充：函数内操作-Storage-的正确方式" class="headerlink" title="4. 补充：函数内操作 Storage 的正确方式"></a>4. 补充：函数内操作 Storage 的正确方式</h3><p>函数内虽不能<strong>声明</strong>新的 Storage 变量，但可以<strong>引用</strong>已有的合约级 Storage 变量，或通过 Storage 指针操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">contract Example &#123;<br>    // 合约级 Storage 变量（合法）<br>    uint256 public storageVar; <br><br>    function updateStorage() external &#123;<br>        // 函数内引用已有 Storage 变量（合法）<br>        storageVar = 100; <br><br>        // Storage 指针（操作已有 Storage 数据，非新建）<br>        uint256 storage ref = storageVar;<br>        ref = 200; // 等价于修改 storageVar<br>    &#125;<br><br>    // 函数内声明 Storage 变量（语法错误！）<br>    // function wrong() external &#123;<br>    //     uint256 storage newVar; // 编译报错<br>    // &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>你答案的核心错误是混淆了“Storage 的用途”（存储合约可变状态）和“常量的存储位置”（不占用 Storage）；而正确答案精准命中了 Storage 的两大核心特征：<strong>持久化生命周期</strong> + <strong>仅合约级声明</strong>，这也是函数内无法新建 Storage 变量的根本原因。</p>
<h1 id="错题分析3"><a href="#错题分析3" class="headerlink" title="错题分析3"></a>错题分析3</h1><p>Given the following mapping mapping(address-&gt;uint256), what is the default value returned when accessing a key that does not exist?答案是zero，我选的是null</p>
<h3 id="1-核心结论：Solidity-映射不存在“null”，未赋值键的默认值是零值（zero-value）"><a href="#1-核心结论：Solidity-映射不存在“null”，未赋值键的默认值是零值（zero-value）" class="headerlink" title="1. 核心结论：Solidity 映射不存在“null”，未赋值键的默认值是零值（zero value）"></a>1. 核心结论：Solidity 映射不存在“null”，未赋值键的默认值是<strong>零值（zero value）</strong></h3><p>在 Solidity 中，<code>mapping(address =&gt; uint256)</code> 这类映射的核心规则是：<strong>所有未显式赋值的键，都会返回对应值类型的“零值（zero value）”</strong>，而非编程中常见的 <code>null</code>/<code>nil</code>/<code>undefined</code>。</p>
<h3 id="2-你的答案错误原因：混淆了-Solidity-与其他语言的空值逻辑"><a href="#2-你的答案错误原因：混淆了-Solidity-与其他语言的空值逻辑" class="headerlink" title="2. 你的答案错误原因：混淆了 Solidity 与其他语言的空值逻辑"></a>2. 你的答案错误原因：混淆了 Solidity 与其他语言的空值逻辑</h3><ul>
<li><strong><code>null</code> 并非 Solidity 的合法值</strong>：Solidity 没有 <code>null</code> 关键字（也无 <code>undefined</code>），这是和 JavaScript、Java 等语言的关键区别——Solidity 不会用“空值”表示“未初始化/不存在”，而是为每种基础类型定义了固定的零值。</li>
<li>**<code>uint256</code> 类型的零值就是 <code>0</code>**：映射的值类型是 <code>uint256</code>（无符号整数），其零值为数字 <code>0</code>；即使访问从未赋值的 <code>address</code> 键，返回结果也必然是 <code>0</code>，而非“空”。</li>
</ul>
<h3 id="3-扩展验证：不同类型映射的零值"><a href="#3-扩展验证：不同类型映射的零值" class="headerlink" title="3. 扩展验证：不同类型映射的零值"></a>3. 扩展验证：不同类型映射的零值</h3><table>
<thead>
<tr>
<th>映射类型</th>
<th>访问不存在键的返回值（零值）</th>
</tr>
</thead>
<tbody><tr>
<td><code>mapping(address =&gt; uint256)</code></td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>mapping(address =&gt; bool)</code></td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>mapping(address =&gt; address)</code></td>
<td><code>0x0000000000000000000000000000000000000000</code>（空地址）</td>
</tr>
<tr>
<td><code>mapping(address =&gt; bytes)</code></td>
<td>空字节数组 <code>[]</code></td>
</tr>
</tbody></table>
<h3 id="4-代码示例验证"><a href="#4-代码示例验证" class="headerlink" title="4. 代码示例验证"></a>4. 代码示例验证</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">contract MappingTest &#123;<br>    mapping(address =&gt; uint256) public userBalances;<br><br>    function getNonExistentKey() external view returns (uint256) &#123;<br>        // 访问一个从未赋值的地址（比如随机地址）<br>        address randomAddr = 0x1234567890123456789012345678901234567890;<br>        return userBalances[randomAddr]; // 返回 0，而非 null<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>编译并调用 <code>getNonExistentKey()</code>，结果必然是 <code>0</code>，不存在“返回 null”的可能。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>你选 <code>null</code> 的核心错误是将其他语言的“空值逻辑”套用到 Solidity 上——Solidity 设计上<strong>无 null 概念</strong>，映射对不存在的键始终返回值类型的零值；对于 <code>uint256</code> 类型，零值就是 <code>0</code>（zero），这也是正确答案的依据。</p>
<h1 id="错误分析4"><a href="#错误分析4" class="headerlink" title="错误分析4"></a>错误分析4</h1><p>Which of the following code snippets is a valid way to declare a public function that accepts a uint256 parameter and sets a state variable to its value?<br>答案是： <code>function store(uint256 _favoriteNumber) public &#123; favoriteNumber = _favoriteNumber; &#125;</code><br>我选的是 <code>function store(uint256 _favoriteNumber) public &#123; _favoriteNumber = favoriteNumber; &#125;</code></p>
<h3 id="1-核心结论：赋值方向完全颠倒导致答案错误"><a href="#1-核心结论：赋值方向完全颠倒导致答案错误" class="headerlink" title="1. 核心结论：赋值方向完全颠倒导致答案错误"></a>1. 核心结论：赋值方向完全颠倒导致答案错误</h3><p>Solidity 中赋值语句的规则和绝大多数编程语言一致：<strong>等号（<code>=</code>）左侧是“被赋值的变量”，右侧是“赋值的来源”</strong>。<br>你选择的代码把赋值方向写反了，最终效果是“将状态变量的值覆盖传入的参数”（而非题目要求的“把参数值设置给状态变量”），因此不符合题意。</p>
<h3 id="2-逐行解析正确-错误代码"><a href="#2-逐行解析正确-错误代码" class="headerlink" title="2. 逐行解析正确/错误代码"></a>2. 逐行解析正确/错误代码</h3><h4 id="前提：合约中需先声明状态变量（题目隐含此前提）"><a href="#前提：合约中需先声明状态变量（题目隐含此前提）" class="headerlink" title="前提：合约中需先声明状态变量（题目隐含此前提）"></a>前提：合约中需先声明状态变量（题目隐含此前提）</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">contract NumberStorage &#123;<br>    uint256 favoriteNumber; // 合约级状态变量（Storage）<br></code></pre></div></td></tr></table></figure>

<h4 id="正确代码（答案）"><a href="#正确代码（答案）" class="headerlink" title="正确代码（答案）"></a>正确代码（答案）</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">function store(uint256 _favoriteNumber) public &#123; <br>    favoriteNumber = _favoriteNumber; <br>&#125;<br></code></pre></div></td></tr></table></figure>
<ul>
<li>左侧 <code>favoriteNumber</code>：合约的状态变量（需要被修改的目标）；</li>
<li>右侧 <code>_favoriteNumber</code>：函数传入的参数（赋值的来源）；</li>
<li>效果：把用户传入的参数值，赋值给合约的状态变量，完全匹配题目“sets a state variable to its value”（将状态变量设为参数值）的要求。</li>
</ul>
<h4 id="错误代码（你选的）"><a href="#错误代码（你选的）" class="headerlink" title="错误代码（你选的）"></a>错误代码（你选的）</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">function store(uint256 _favoriteNumber) public &#123; <br>    _favoriteNumber = favoriteNumber; <br>&#125;<br></code></pre></div></td></tr></table></figure>
<ul>
<li>左侧 <code>_favoriteNumber</code>：函数的局部参数（Memory 类型，临时变量）；</li>
<li>右侧 <code>favoriteNumber</code>：合约的状态变量（当前值，比如初始零值 <code>0</code>）；</li>
<li>效果：把状态变量的当前值覆盖到参数里——参数是函数内的临时变量，函数执行完就销毁，状态变量本身<strong>完全没被修改</strong>，违背题目核心要求。</li>
</ul>
<h3 id="3-关键补充：参数命名的下划线规范"><a href="#3-关键补充：参数命名的下划线规范" class="headerlink" title="3. 关键补充：参数命名的下划线规范"></a>3. 关键补充：参数命名的下划线规范</h3><p>Solidity 中常用下划线（<code>_</code>）前缀区分函数参数和状态变量（比如 <code>_favoriteNumber</code> 是参数，<code>favoriteNumber</code> 是状态变量），这个规范的目的就是避免赋值方向混淆——但核心规则还是“左目标、右来源”。</p>
<h3 id="4-验证：错误代码的实际执行效果"><a href="#4-验证：错误代码的实际执行效果" class="headerlink" title="4. 验证：错误代码的实际执行效果"></a>4. 验证：错误代码的实际执行效果</h3><p>假设状态变量 <code>favoriteNumber</code> 初始值为 <code>0</code>，调用 <code>store(100)</code>：</p>
<ul>
<li>正确代码：<code>favoriteNumber</code> 被设为 <code>100</code>（符合要求）；</li>
<li>错误代码：参数 <code>_favoriteNumber</code> 被改成 <code>0</code>，但 <code>favoriteNumber</code> 仍为 <code>0</code>（状态变量无变化，完全不符合题意）。</li>
</ul>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>你选错的核心原因是<strong>赋值语句的方向理解错误</strong>：题目要求“将状态变量设为参数值”，需要把参数放在等号右侧（作为值的来源），状态变量放在左侧（作为赋值目标）；而你选的代码恰好颠倒了这一逻辑，导致状态变量未被修改，因此不符合要求。</p>
<h1 id="错误分析5"><a href="#错误分析5" class="headerlink" title="错误分析5"></a>错误分析5</h1><p>What keyword can be used in a function declaration to specify that the function can only be accessed from within the same contract? 答案是private，我选的是internal</p>
<h3 id="1-核心结论：private-vs-internal-的访问权限边界是关键"><a href="#1-核心结论：private-vs-internal-的访问权限边界是关键" class="headerlink" title="1. 核心结论：private vs internal 的访问权限边界是关键"></a>1. 核心结论：<code>private</code> vs <code>internal</code> 的访问权限边界是关键</h3><p>Solidity 中函数/变量的访问权限关键字里，**<code>private</code> 严格限制“仅当前合约内部可访问”**，而 <code>internal</code> 允许“当前合约 + 继承它的子合约”访问——你选错的核心原因是混淆了两者的权限范围，题目明确要求“only be accessed from within the same contract（仅同一合约内访问）”，因此 <code>private</code> 是唯一正确答案。</p>
<h3 id="2-权限关键字对比表（函数-状态变量通用）"><a href="#2-权限关键字对比表（函数-状态变量通用）" class="headerlink" title="2. 权限关键字对比表（函数/状态变量通用）"></a>2. 权限关键字对比表（函数/状态变量通用）</h3><table>
<thead>
<tr>
<th>关键字</th>
<th>访问范围</th>
<th>核心特征</th>
</tr>
</thead>
<tbody><tr>
<td><code>private</code></td>
<td>仅<strong>定义该关键字的合约本身</strong>可访问</td>
<td>子合约也无法访问，最严格</td>
</tr>
<tr>
<td><code>internal</code></td>
<td>定义合约 + 所有<strong>继承该合约的子合约</strong>可访问</td>
<td>禁止外部账户调用，但允许继承</td>
</tr>
<tr>
<td><code>public</code></td>
<td>所有合约/外部账户均可访问</td>
<td>自动生成 getter 函数</td>
</tr>
<tr>
<td><code>external</code></td>
<td>仅外部账户/其他合约可访问，当前合约需用 <code>this.</code> 调用</td>
<td>禁止内部直接调用</td>
</tr>
</tbody></table>
<h3 id="3-代码示例验证：private-vs-internal"><a href="#3-代码示例验证：private-vs-internal" class="headerlink" title="3. 代码示例验证：private vs internal"></a>3. 代码示例验证：<code>private</code> vs <code>internal</code></h3><h4 id="场景1：private-函数——子合约无法访问"><a href="#场景1：private-函数——子合约无法访问" class="headerlink" title="场景1：private 函数——子合约无法访问"></a>场景1：<code>private</code> 函数——子合约无法访问</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">contract Parent &#123;<br>    // private 函数：仅 Parent 内部可调用<br>    function privateFunc() private pure returns (string memory) &#123;<br>        return &quot;Only Parent can call me&quot;;<br>    &#125;<br><br>    // 内部调用 private 函数（合法）<br>    function callPrivate() public pure returns (string memory) &#123;<br>        return privateFunc();<br>    &#125;<br>&#125;<br><br>contract Child is Parent &#123;<br>    // 子合约调用父合约的 private 函数（编译报错！）<br>    function tryCallPrivate() public pure returns (string memory) &#123;<br>        return privateFunc(); // Error: member &quot;privateFunc&quot; is private<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h4 id="场景2：internal-函数——子合约可访问"><a href="#场景2：internal-函数——子合约可访问" class="headerlink" title="场景2：internal 函数——子合约可访问"></a>场景2：<code>internal</code> 函数——子合约可访问</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">contract Parent &#123;<br>    // internal 函数：Parent + Child 均可调用<br>    function internalFunc() internal pure returns (string memory) &#123;<br>        return &quot;Parent and Child can call me&quot;;<br>    &#125;<br>&#125;<br><br>contract Child is Parent &#123;<br>    // 子合约调用父合约的 internal 函数（合法）<br>    function callInternal() public pure returns (string memory) &#123;<br>        return internalFunc(); // 无报错，正常执行<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="4-题目要求的精准匹配"><a href="#4-题目要求的精准匹配" class="headerlink" title="4. 题目要求的精准匹配"></a>4. 题目要求的精准匹配</h3><p>题目关键词是 <strong>“only be accessed from within the same contract（仅同一合约内访问）”</strong>：</p>
<ul>
<li><code>private</code>：完全符合“仅同一合约”，子合约都被排除；</li>
<li><code>internal</code>：超出了“同一合约”的范围（包含子合约），因此不符合要求。</li>
</ul>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>你选 <code>internal</code> 的核心错误是<strong>未区分“同一合约”和“继承合约”的边界</strong>：<code>internal</code> 的权限范围是“当前合约 + 子合约”，而题目严格限定“仅同一合约内访问”，只有 <code>private</code> 能满足这一条件。简单记：<br><code>private</code> = 仅本合约；<code>internal</code> = 本合约 + 子合约。</p>
<h1 id="phind是什么"><a href="#phind是什么" class="headerlink" title="phind是什么"></a>phind是什么</h1><p><a target="_blank" rel="noopener" href="https://www.phind.com/">https://www.phind.com/</a></p>
<p>Phind是一款专为开发者量身定制的<strong>AI驱动对话式搜索引擎</strong>，由美国旧金山的Hello Cognition, Inc.于2022年开发，隶属于Y Combinator S22批次，核心是结合生成式AI与网络搜索，为技术相关问题提供快速、精准的答案，大幅优化开发者的编码和调试效率。以下是其核心特点和功能的详细介绍：</p>
<ol>
<li><strong>主打开发者导向的精准技术响应</strong><ul>
<li>它基于Phind - 405B、Phind - 70B等专属模型，在编程领域表现突出，比如Phind - 70B模型在HumanEval基准测试中得分82.3%，优于GPT - 4 Turbo的81.1%。面对“Python如何处理JSON数据”这类编程问题，能直接给出可复用的代码片段和最佳实践，无需用户在海量搜索结果中筛选。</li>
<li>支持Python、Java、C++等多种主流编程语言，还能识别代码报错并提供调试方案，例如准确指出Python缩进错误位置并给出修正方式。</li>
</ul>
</li>
<li><strong>高效的代码相关核心功能</strong><ul>
<li>除基础代码生成外，Phind Pro用户可使用浏览器内代码测试功能；其Phind - 405B模型支持128K上下文窗口，能应对大型代码库分析这类复杂任务，而Phind Instant模型速度可达350令牌/秒，满足快速查询需求。</li>
<li>提供VS Code扩展插件，开发者无需切换界面，在编码环境中就能直接查询问题、获取代码建议，无缝融入开发流程。</li>
</ul>
</li>
<li><strong>灵活的交互与使用模式</strong><ul>
<li>支持连续对话和上下文理解，用户可针对复杂问题逐步追问，比如先问“HTML表单验证失败原因”，再进一步探讨具体报错的解决办法。同时提供简洁、详细等多种回答模式，还包含专家、创意等回复模型，适配不同用户需求。</li>
<li>无需注册即可使用，支持PWA功能，可添加到手机主屏幕实现原生应用般的使用体验；Phind Pro用户还能选择GPT - 4o、Claude 3.5 Sonnet等第三方模型，且支持图像分析，可上传错误截图获取针对性解决方案。</li>
</ul>
</li>
<li><strong>相比传统工具的独特优势</strong><ul>
<li>响应速度快，75%的首次回答准确，且通常15秒内就能生成答案，远超传统搜索引擎筛选信息的耗时；和ChatGPT等通用AI相比，它具备实时联网能力，能获取最新的技术文档、第三方库信息，避免了通用模型知识滞后的问题。</li>
<li>支持多查询搜索，可同时处理多个相关技术问题，适合多模块并行开发时的批量疑问解答。</li>
</ul>
</li>
</ol>
<h1 id="zksync是什么"><a href="#zksync是什么" class="headerlink" title="zksync是什么"></a>zksync是什么</h1><p>ZKsync是由德国团队Matter Labs开发的以太坊二层（Layer 2）扩容协议，核心基于零知识汇总（ZK - Rollup）技术，致力于解决以太坊主网交易速度慢、手续费高的问题，同时继承以太坊的高安全性，如今已发展为包含多条互联链的弹性网络，以下是其核心相关信息：</p>
<ol>
<li><strong>核心发展历程</strong><ul>
<li><strong>ZKsync 1.0（后更名ZKsync Lite）</strong>：2020年推出，虽能实现每秒3000笔交易的吞吐量，但存在功能局限，无法兼容以太坊虚拟机（EVM），仅支持转账、铸造NFT等简单操作，难以部署复杂DeFi协议，未能适配当时的生态需求。</li>
<li> <strong>ZKsync 2.0（后更名ZKsync Era）</strong>：2022年底对外开放，核心突破是推出zkEVM，实现了与EVM的兼容，让开发者可无缝迁移以太坊上的Solidity/Vyper智能合约。同时还带来zkPorter等技术，大幅降低交易费用，生态也开始快速发展，吸引众多知名项目入驻。</li>
<li> <strong>ZKsync 3.0（弹性链）</strong>：2024年6月通过v24升级推出，将ZKsync从单条ZK链升级为弹性链网络。该网络包含Rollup、Validium等多种类型的链，链之间可无缝互操作，还借助原生代币金库、共享路由器、ZK网关等组件，实现了生态的无限扩展和高效交互。</li>
</ul>
</li>
<li><strong>关键技术与核心优势</strong><ul>
<li> <strong>zkEVM</strong>：作为开创性技术，它实现零知识证明与EVM的结合，既保障交易隐私，又能高效运行智能合约，降低了以太坊开发者迁移项目到ZKsync的门槛，是ZKsync生态繁荣的重要基础。</li>
<li> <strong>zkPorter</strong>：链下数据存储方案，把二层账户状态拆分为链上zkRollup部分和链下PoS网络保护的zkPorter部分。采用zkPorter账户的交易费用极低，仅约0.001美元，且能与zkRollup账户无缝交互，大幅提升用户使用性价比。</li>
<li> <strong>高安全性与兼容性</strong>：所有交易的有效性证明都会在以太坊主网验证，用户资金安全和以太坊主网同等；同时支持MetaMask等主流以太坊钱包，开发者可使用Hardhat、Foundry等常用框架，Web3 API也保持兼容，使用和开发体验接近以太坊。</li>
</ul>
</li>
<li><strong>生态与经济体系</strong><ul>
<li> <strong>生态布局</strong>：生态内已聚集超200个项目，涵盖DeFi、NFT、钱包、基础设施等多个领域，1inch、Sushiswap、Uniswap等知名协议均已入驻，还在向社交、隐私保护等新方向拓展。此外，其ZK Stack框架支持开发者搭建定制化ZK区块链，Prividium平台则面向机构提供隐私合规的区块链服务。</li>
<li> <strong>原生代币ZK</strong>：2024年6月推出，总供应量210亿枚。代币持有者可参与协议升级投票等治理活动，也能通过原生账户抽象功能支付网络费用。上线时曾开展大规模空投，空投量占总供应量的17.5%，是业内较大规模的Layer2项目空投。</li>
</ul>
</li>
</ol>
<h1 id="zksync-bridge是什么"><a href="#zksync-bridge是什么" class="headerlink" title="zksync bridge是什么"></a>zksync bridge是什么</h1><p>ZKsync Bridge 并非单一款桥接工具，而是支撑ZKsync（以太坊Layer2扩展方案）生态的一系列<strong>跨链/跨层资产桥接工具集合</strong>。其核心作用是实现以太坊主网（L1）与ZKsync网络（L2），以及ZKsync与其他区块链网络、中心化交易所间的资产安全转移，核心依赖零知识证明（ZKP）技术保障交易安全性与高效性，主流桥接工具可分为官方原生桥和第三方桥两类，具体如下：</p>
<ol>
<li><strong>官方原生桥（Portal Bridge）</strong><br> 这是以太坊与ZKsync间资产转移的默认工具，也是安全性优先级最高的桥接方式。它通过在以太坊主网和ZKsync分别部署智能合约，借助L1-L2互操作性实现资产流转。当用户从以太坊向ZKsync转账时，资产会被锁定在L1的桥接合约中，同时触发L2合约铸造等额资产；提款时则反之，L2上的资产会被销毁，L1合约会解锁对应数量的资产释放给用户。该桥接无额外服务费，适合高价值交易，但提款存在3小时延迟以保障安全，且仅支持标准ERC20代币，不兼容再平衡代币等定制化代币。</li>
<li><strong>主流第三方桥接工具</strong><br> 这类工具主要弥补官方桥的局限性，比如拓展跨链范围、提升转账速度等，适配不同用户的需求，常见类型有：<ul>
<li><strong>Across</strong>：主打去中心化跨Rollup桥接，聚焦Layer2间的互操作性。它采用乐观预言机保障安全，通过流动性提供者预存资金的模式，实现近乎即时的资产转账，中位桥接费常低于0.04美元，适合追求高效转账的普通用户。</li>
<li><strong>LayerSwap</strong>：支持连接55种以上区块链网络，还能直接对接15家以上中心化交易所。除了跨链，它还可实现ZKsync Lite网络的快速提款，适合需要在链上与中心化交易所间灵活转移资产的场景。</li>
<li><strong>Orbiter Finance</strong>：是ZKsync生态中常用的第三方桥，以低费率和快速转账为特点，支持以太坊生态内多个Layer2与ZKsync间的资产流转，适配小额高频的转账需求。</li>
</ul>
</li>
</ol>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Web3/">Web3</a>
                    
                  </div>
                
              </div>
              
                
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/12/07/d07518db1896/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">我的生平（三十一）</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/12/06/3324949a0b94/">
                        <span class="hidden-mobile">cryptozombies14-Chainlink</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


            

                
                  <a id="scroll-top-button" href="#" role="button">
                    <i class="iconfont icon-arrowup" aria-hidden="true"></i>
                  </a>
                  

                    
                      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
                        

                          
      </main>

      <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://whale3070.github.io/" target="_blank" rel="nofollow noopener"><span>Whale3070</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>






  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



    </body>

  </html>