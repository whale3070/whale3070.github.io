

  <!DOCTYPE html>
  <html lang="zh-CN" data-default-color-scheme=&#34;dark&#34; >
  <style>
    .text1
    {
    text-shadow: 0px 0px 2px #f2f3f2;
    }
    </style>

  <script>
    // 强制内网 IP 识别为安全上下文
    if (window.location.hostname !== 'localhost' && window.location.protocol === 'http:') {
        // 尝试手动映射 crypto 属性
        if (!window.crypto.subtle && window.crypto.webkitSubtle) {
            window.crypto.subtle = window.crypto.webkitSubtle;
        }
    }
    
    // 终极补丁：如果还是没有 subtle，则创建一个占位符避免报错
    // 提示：这通常能解决加载报错，但如果插件强依赖原生加密，建议执行下面的“降级”预判
    if (!window.isSecureContext) {
        console.warn('当前环境非安全上下文，正在尝试兼容内网加密解密...');
    }
</script>


<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/null">
  <link rel="icon" type="image/png" href="/null">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>foundry - whale3070&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.4.0/styles/github-gist.min.css" />
    
  

  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"192.168.126.129","root":"/","version":"1.8.7","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":false,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 7.3.0"></head>


    <body>
      <header style="height: 70vh;">
        <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>InfoSec learning</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/search/">
                <i class="iconfont icon-search"></i>
                搜索
              </a>
            </li>
          
        
        
        
          
        
      </ul>
    </div>
  </div>
</nav>

          <div class="banner" id="banner" false
            style="background: url('/img/default.png') no-repeat center center;
              background-size: cover;">
              <div class="full-bg-img">
                <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
                  <div class="page-header text-center fade-in-up">
                    <span class="h2 text1" id="subtitle" title="foundry">
                      
                        foundry
                      
                    </span>
        
                    
                      <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2025-12-19 06:12" pubdate>
        2025年12月19日 早上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      3.7k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      41
       分钟
    </span>
  

  
  
</div>

                    
                  </div>
                    
                  </div>
                  
                </div>
              </div>
          </div>
      </header>

      <main>
        
          

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" data-pagefind-body>
            <!-- SEO header -->
            <h1 style="display: none">foundry</h1>
            
            <div class="markdown-body">
              <p>学习web3一个多月了，刚开始用remix，然后用hardhat，然后是truffle。<br>为了测试Damn Vulnerable DeFi的合约，我必须掌握foundry</p>
<h1 id="foundry的作弊码是什么"><a href="#foundry的作弊码是什么" class="headerlink" title="foundry的作弊码是什么"></a>foundry的作弊码是什么</h1><h3 id="核心需求理解"><a href="#核心需求理解" class="headerlink" title="核心需求理解"></a>核心需求理解</h3><p>你想了解 Foundry 中的「作弊码（Cheatcodes）」是什么，以及它们的核心用途、常用类型和使用方式，这能帮助你理解之前测试失败时涉及的 <code>vm.prank</code>、<code>vm.expectEmit</code> 等代码的本质。</p>
<h3 id="Foundry-作弊码（Cheatcodes）详解"><a href="#Foundry-作弊码（Cheatcodes）详解" class="headerlink" title="Foundry 作弊码（Cheatcodes）详解"></a>Foundry 作弊码（Cheatcodes）详解</h3><h4 id="1-作弊码的核心定义"><a href="#1-作弊码的核心定义" class="headerlink" title="1. 作弊码的核心定义"></a>1. 作弊码的核心定义</h4><p>Foundry 的作弊码（Cheatcodes）是通过 <code>Vm</code> 合约（<code>forge-std/Vm.sol</code>）提供的一系列特殊函数，允许你在测试中<strong>操控区块链环境、模拟账户行为、修改状态、捕获事件</strong>等——这些操作在真实链上无法实现，但对测试智能合约至关重要（比如模拟任意地址发起交易、修改区块时间、断言事件是否触发）。</p>
<p>简单来说：作弊码是 Foundry 为测试量身打造的「上帝模式」，让你能灵活控制测试环境，覆盖各种边界场景。</p>
<h4 id="2-作弊码的使用前提"><a href="#2-作弊码的使用前提" class="headerlink" title="2. 作弊码的使用前提"></a>2. 作弊码的使用前提</h4><p>使用作弊码前，需在测试合约中引入 <code>Vm</code> 合约，并声明一个 <code>vm</code> 实例（Foundry 会自动注入，无需手动部署）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">// 引入标准库（包含 Vm 合约）<br>import &quot;forge-std/Test.sol&quot;;<br><br>contract MyTest is Test &#123;<br>    // 内置的 vm 实例，直接使用即可<br>    // Vm public vm = Vm(HEVM_ADDRESS); // 底层原理，无需手动写<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h4 id="3-常用作弊码分类及核心示例"><a href="#3-常用作弊码分类及核心示例" class="headerlink" title="3. 常用作弊码分类及核心示例"></a>3. 常用作弊码分类及核心示例</h4><p>按用途可分为以下几类，结合你之前的测试日志，重点解释相关作弊码：</p>
<p>| 分类         | 常用作弊码                | 核心用途                                                                 |<br>| 账户模拟     | <code>prank(address)</code>          | 让接下来的<strong>一次调用</strong>以指定地址（如 attacker&#x2F;player）的身份执行         |<br>|              | <code>startPrank(address)</code>     | 让接下来的<strong>所有调用</strong>以指定地址执行（直到 <code>stopPrank()</code>）               |<br>|              | <code>stopPrank()</code>             | 结束 <code>startPrank</code> 的身份模拟                                             |<br>| 事件断言     | <code>expectEmit()</code>            | 声明「预期接下来会触发某个事件」，需配合事件发射代码使用                 |<br>|              | <code>expectRevert()</code>          | 断言接下来的调用会触发回滚（可指定回滚原因）                             |<br>| 环境操控     | <code>warp(uint256)</code>           | 修改当前区块时间（模拟时间推移，测试锁仓&#x2F;过期逻辑）                      |<br>|              | <code>roll(uint256)</code>           | 修改当前区块高度                                                         |<br>|              | <code>deal(address, uint256)</code>  | 直接给指定地址分配 ETH（绕过转账，快速测试余额相关逻辑）                 |<br>|              | <code>deal(address, address, uint256)</code> | 给指定地址分配 ERC20 代币（比如快速给测试账户转 DVT 代币）          |<br>| 状态修改     | <code>mockCall()</code>              | 模拟合约调用的返回值（比如伪造某个合约的 <code>balanceOf</code> 结果）             |<br>|              | <code>hoax(address)</code>           | 等价于 <code>deal(address, 100 ether) + prank(address)</code>（快速给地址转 ETH+模拟身份） |</p>
<h4 id="4-你之前测试中涉及的作弊码详解"><a href="#4-你之前测试中涉及的作弊码详解" class="headerlink" title="4. 你之前测试中涉及的作弊码详解"></a>4. 你之前测试中涉及的作弊码详解</h4><p>结合你失败的测试日志，重点解释两个核心作弊码：</p>
<h5 id="（1）vm-prank-address-vm-startPrank"><a href="#（1）vm-prank-address-vm-startPrank" class="headerlink" title="（1）vm.prank(address) &#x2F; vm.startPrank()"></a>（1）<code>vm.prank(address)</code> &#x2F; <code>vm.startPrank()</code></h5><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">// 示例：模拟 deployer 地址执行后续操作<br>vm.prank(deployer); <br>monitor.checkFlashLoan(100 ether); // 这次调用的 msg.sender = deployer<br><br>// 示例：模拟 player 地址执行多步操作<br>vm.startPrank(player);<br>token.transfer(vault, 1 ether); // msg.sender = player<br>token.approve(vault, 10 ether); // msg.sender = player<br>vm.stopPrank(); // 结束模拟<br></code></pre></div></td></tr></table></figure>
<p>你日志中的 <code>VM::prank(deployer)</code> 就是测试代码中用 <code>vm.prank(deployer)</code> 让 <code>checkFlashLoan</code> 以部署者身份执行。</p>
<h5 id="（2）vm-expectEmit"><a href="#（2）vm-expectEmit" class="headerlink" title="（2）vm.expectEmit()"></a>（2）<code>vm.expectEmit()</code></h5><p>这是你测试失败的核心关联作弊码，用于断言「某个事件会被触发，且参数匹配」。<br><strong>正确使用流程</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">// 1. 声明要监听事件（参数：是否监听 index 字段，通常全设为 true）<br>vm.expectEmit(true, true, true, true);<br>// 2. 发射「预期的事件」（仅用于对比参数，不会实际触发）<br>emit FlashLoanStatus(false); <br>// 3. 执行会触发事件的操作<br>monitor.checkFlashLoan(100 ether); <br>// 4. Foundry 会对比：实际触发的事件 vs 预期的事件，参数不一致则失败<br></code></pre></div></td></tr></table></figure>
<p>你测试失败的原因是：实际触发的 <code>FlashLoanStatus(true)</code> 与你预期的 <code>FlashLoanStatus(false)</code> 参数不匹配。</p>
<h4 id="5-其他高频作弊码示例"><a href="#5-其他高频作弊码示例" class="headerlink" title="5. 其他高频作弊码示例"></a>5. 其他高频作弊码示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">// 给地址转 ETH<br>vm.deal(attacker, 10 ether); <br>// 给地址转 ERC20 代币（地址：代币合约，接收者，数量）<br>vm.deal(address(token), attacker, 1000e18); <br>// 断言调用会回滚，并指定回滚原因<br>vm.expectRevert(&quot;Invalid balance&quot;);<br>vault.flashLoan(receiver, amount); <br>// 修改区块时间（推进 1 天）<br>vm.warp(block.timestamp + 86400); <br></code></pre></div></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li><strong>核心定义</strong>：Foundry 作弊码是 <code>Vm</code> 合约提供的测试工具，用于操控区块链环境、模拟行为、断言事件&#x2F;回滚等，是测试智能合约的核心能力。</li>
<li><strong>关键用途</strong>：模拟任意地址调用（<code>prank</code>）、断言事件触发（<code>expectEmit</code>）、修改环境状态（<code>warp</code>&#x2F;<code>deal</code>）、验证回滚（<code>expectRevert</code>）。</li>
<li><strong>你的测试关联</strong>：失败源于 <code>expectEmit</code> 断言的 <code>FlashLoanStatus(false)</code> 与实际触发的 <code>true</code> 参数不匹配，需检查业务逻辑为何闪电贷未失败。</li>
</ol>
<p>掌握这些作弊码能帮你精准调试 Unstoppable 挑战的测试用例，比如用 <code>vm.deal</code> 快速给测试账户转代币，用 <code>vm.expectRevert</code> 断言闪电贷触发回滚，用 <code>vm.prank</code> 模拟攻击者操作等。</p>
<h1 id="什么是foundry中的vm合约"><a href="#什么是foundry中的vm合约" class="headerlink" title="什么是foundry中的vm合约?"></a>什么是foundry中的vm合约?</h1><p>你想了解 Foundry 中核心的 <code>vm</code> 合约（也常叫 <code>Cheatcode</code> 合约），这是 Foundry 测试&#x2F;开发中最关键的工具之一，我会用通俗易懂的方式帮你讲清楚。</p>
<h3 id="核心需求理解-1"><a href="#核心需求理解-1" class="headerlink" title="核心需求理解"></a>核心需求理解</h3><p>你想知道 Foundry 里的 <code>vm</code> 合约到底是什么、有什么用、以及怎么用——本质上是想理解这个核心工具的定位和核心能力，帮你更好地解读之前的测试失败日志，也能在自己的测试中用好它。</p>
<h3 id="vm-合约的完整解读"><a href="#vm-合约的完整解读" class="headerlink" title="vm 合约的完整解读"></a>vm 合约的完整解读</h3><h4 id="1-先给一个通俗定义"><a href="#1-先给一个通俗定义" class="headerlink" title="1. 先给一个通俗定义"></a>1. 先给一个通俗定义</h4><p><code>vm</code> 是 Foundry 内置的<strong>作弊码合约（Cheatcode Contract）</strong>，它不是以太坊主网&#x2F;测试网上真实存在的合约，而是 Foundry 为了方便开发者测试智能合约，在本地模拟环境中提供的“超级工具”。</p>
<p>你可以把它理解成：在测试智能合约时，你拥有了一个“上帝视角”的控制台，通过调用 <code>vm</code> 的函数，你可以随意修改区块链的状态、模拟各种特殊场景（比如修改区块高度、模拟不同地址调用、伪造事件预期等），而这些操作在真实链上是完全做不到的。</p>
<h4 id="2-vm-合约的核心作用"><a href="#2-vm-合约的核心作用" class="headerlink" title="2. vm 合约的核心作用"></a>2. vm 合约的核心作用</h4><p>它的核心价值是<strong>降低智能合约测试的复杂度</strong>，让你能精准模拟各种边界场景、异常场景，比如：</p>
<ul>
<li>模拟不同地址发起交易（比如你之前日志里的 <code>vm.prank()</code>&#x2F;<code>vm.startPrank()</code>）</li>
<li>预期某个事件会被触发（比如你之前日志里的 <code>vm.expectEmit()</code>）</li>
<li>修改区块高度、时间、gas 价格</li>
<li>模拟合约调用失败、回滚</li>
<li>读取&#x2F;修改合约的私有变量</li>
<li>伪造签名、模拟链上余额变动等</li>
</ul>
<h4 id="3-核心常用方法（结合你之前的日志举例）"><a href="#3-核心常用方法（结合你之前的日志举例）" class="headerlink" title="3. 核心常用方法（结合你之前的日志举例）"></a>3. 核心常用方法（结合你之前的日志举例）</h4><p>先看你测试日志里出现的几个 <code>vm</code> 方法，再扩展核心常用方法：</p>
<p>| 方法名                | 作用（通俗解释）                                                                 | 你日志中的场景                                                                 |<br>| <code>vm.prank(address)</code>   | 临时切换调用者身份，让接下来的<strong>一次</strong>合约调用看起来是由 <code>address</code> 发起的         | <code>vm.prank(deployer)</code>：让后续调用以部署者地址执行                                |<br>| <code>vm.startPrank(address)</code> | 永久切换调用者身份，直到调用 <code>vm.stopPrank()</code> 为止（批量模拟某地址调用）         | <code>vm.startPrank(player)</code>：模拟玩家地址执行一系列操作，之后用 <code>stopPrank()</code> 恢复  |<br>| <code>vm.stopPrank()</code>      | 结束 <code>startPrank</code> 的身份模拟，恢复默认调用者                                     | 日志中结束玩家身份模拟                                                         |<br>| <code>vm.expectEmit()</code>     | 预期接下来的操作会触发某个事件，若没触发&#x2F;参数不匹配，测试直接失败                 | 你测试中预期触发 <code>FlashLoanStatus(false)</code>，但实际触发 <code>true</code>，导致测试失败      |</p>
<p>其他高频使用的 <code>vm</code> 方法：</p>
<ul>
<li><code>vm.warp(uint256 timestamp)</code>：修改当前区块的时间（比如模拟几天&#x2F;几个月后的场景）</li>
<li><code>vm.roll(uint256 blockNumber)</code>：修改当前区块高度</li>
<li><code>vm.deal(address, uint256 amount)</code>：给指定地址设置 ETH 余额</li>
<li><code>vm.expectRevert(bytes)</code>：预期接下来的调用会回滚，并验证回滚的原因（比如特定错误信息）</li>
<li><code>vm.load(address, bytes32 slot)</code>：读取合约指定存储槽的值（即使是私有变量）</li>
</ul>
<h4 id="4-基础使用示例（新手友好）"><a href="#4-基础使用示例（新手友好）" class="headerlink" title="4. 基础使用示例（新手友好）"></a>4. 基础使用示例（新手友好）</h4><p>下面是一个简单的 Foundry 测试示例，展示 <code>vm</code> 合约的核心用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">// SPDX-License-Identifier: UNLICENSED<br>pragma solidity ^0.8.25;<br><br>import &quot;forge-std/Test.sol&quot;; // 必须导入 Test.sol，才能使用 vm 合约<br><br>contract MyTest is Test &#123; // 继承 Test 合约，获得 vm 实例<br>    address alice = address(0x123);<br>    address bob = address(0x456);<br><br>    function testVmExamples() public &#123;<br>        // 1. 模拟 Alice 给 Bob 转 ETH（先给 Alice 加余额）<br>        vm.deal(alice, 10 ether); // 给 Alice 10 ETH<br>        assertEq(alice.balance, 10 ether); // 验证余额<br><br>        // 2. 模拟 Alice 发起转账（用 prank 切换身份）<br>        vm.prank(alice);<br>        (bool success,) = bob.call&#123;value: 5 ether&#125;(&quot;&quot;);<br>        assert(success);<br>        assertEq(alice.balance, 5 ether); // Alice 剩余 5 ETH<br>        assertEq(bob.balance, 5 ether);   // Bob 收到 5 ETH<br><br>        // 3. 预期触发事件（举例）<br>        vm.expectEmit(true, true, false, false); // 配置监听的索引参数<br>        emit Transfer(alice, bob, 5 ether); // 预期触发这个事件<br>        // 执行会触发事件的操作...<br>    &#125;<br><br>    // 示例事件<br>    event Transfer(address indexed from, address indexed to, uint256 amount);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h4 id="5-关键注意事项"><a href="#5-关键注意事项" class="headerlink" title="5. 关键注意事项"></a>5. 关键注意事项</h4><ul>
<li><code>vm</code> 合约<strong>仅在测试环境生效</strong>：部署到真实链上的合约无法调用 <code>vm</code> 的任何方法，它是 Foundry 本地模拟环境的专属工具。</li>
<li>必须继承 <code>forge-std/Test.sol</code>：只有继承这个合约，你的测试合约才能使用 <code>vm</code> 实例（<code>Test.sol</code> 内部已经封装了 <code>vm</code>）。</li>
<li>方法调用是“即时生效”的：比如 <code>vm.prank()</code> 调用后，下一次合约交互就会以指定地址执行，无需额外配置。</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol>
<li><code>vm</code> 是 Foundry 内置的<strong>作弊码合约</strong>，仅用于本地测试，能模拟各种链上无法实现的操作；</li>
<li>核心作用是切换调用者身份、预期事件&#x2F;回滚、修改链状态（时间&#x2F;余额&#x2F;区块）等，大幅提升测试灵活性；</li>
<li>你之前测试失败的 <code>vm.expectEmit()</code> 就是 <code>vm</code> 合约的核心方法，用于验证事件触发是否符合预期。</li>
</ol>
<p>理解 <code>vm</code> 合约是用好 Foundry 做智能合约测试的关键，它能让你精准复现各种场景，包括你之前 Unstoppable 挑战中需要模拟的“让闪电贷失败”的场景。</p>
<h1 id="vm合约类似于vmware，虚拟机操作系统，为智能合约提供了虚拟以太坊环境，方便了安全审计人员对contract-sol进行测试"><a href="#vm合约类似于vmware，虚拟机操作系统，为智能合约提供了虚拟以太坊环境，方便了安全审计人员对contract-sol进行测试" class="headerlink" title="vm合约类似于vmware，虚拟机操作系统，为智能合约提供了虚拟以太坊环境，方便了安全审计人员对contract.sol进行测试"></a>vm合约类似于vmware，虚拟机操作系统，为智能合约提供了虚拟以太坊环境，方便了安全审计人员对contract.sol进行测试</h1><p>你的这个类比很有想象力，核心方向是对的，但我会帮你把这个理解校准得更精准，避免混淆概念～</p>
<h3 id="核心需求理解-2"><a href="#核心需求理解-2" class="headerlink" title="核心需求理解"></a>核心需求理解</h3><p>你想确认 <code>vm</code> 合约是否可以类比为 VMware 这类虚拟机，以及它在智能合约测试&#x2F;安全审计中的核心价值，我会先肯定你的核心认知，再补充关键差异和精准定位。</p>
<h3 id="类比的精准解读"><a href="#类比的精准解读" class="headerlink" title="类比的精准解读"></a>类比的精准解读</h3><h4 id="1-你的类比「对的部分」"><a href="#1-你的类比「对的部分」" class="headerlink" title="1. 你的类比「对的部分」"></a>1. 你的类比「对的部分」</h4><p>你把 <code>vm</code> 合约类比为 VMware 虚拟机，核心抓准了**“虚拟环境”** 这个关键：</p>
<ul>
<li>VMware 是在物理操作系统上模拟出独立的操作系统环境，隔离且可随意操作（比如重启、装软件、测试漏洞）；</li>
<li>Foundry 的 <code>vm</code> 合约（作弊码）是在本地计算机上模拟出<strong>以太坊区块链的虚拟环境</strong>，同样隔离且可随意操作（比如修改地址余额、切换调用者、篡改区块时间）。</li>
</ul>
<p>对安全审计人员来说，<code>vm</code> 合约确实像给 <code>contract.sol</code> 搭建了一个“可任意调试的以太坊虚拟机（EVM）沙箱”，不用连接真实测试网&#x2F;主网，就能低成本、高灵活度地测试合约的各种场景（包括攻击场景）。</p>
<h4 id="2-类比「需要修正的部分」（避免概念混淆）"><a href="#2-类比「需要修正的部分」（避免概念混淆）" class="headerlink" title="2. 类比「需要修正的部分」（避免概念混淆）"></a>2. 类比「需要修正的部分」（避免概念混淆）</h4><p>⚠️ 注意：<code>vm</code> 合约**≠** 以太坊虚拟机（EVM），而是<strong>运行在 EVM 模拟环境之上的“超级控制工具”</strong>：</p>
<ul>
<li>VMware 本身是“完整的虚拟机”，包含操作系统内核、硬件模拟等；</li>
<li>Foundry 的 <code>vm</code> 合约不是“虚拟机”，而是 Foundry 给 EVM 模拟环境（Foundry 内置的 EVM 实现）提供的<strong>控制接口&#x2F;作弊工具</strong>。</li>
</ul>
<p>用更精准的类比：</p>
<p>| 组件                | 类比对象                          | 核心角色                     |<br>| Foundry 内置的 EVM  | VMware 虚拟机（硬件+系统层）      | 提供智能合约运行的基础环境   |<br>| <code>vm</code> 合约（作弊码） | VMware 的“虚拟机设置面板”+“作弊器” | 控制&#x2F;修改 EVM 环境的各种参数 |</p>
<p>简单说：</p>
<ul>
<li>EVM 是“虚拟的以太坊操作系统”，负责执行智能合约代码；</li>
<li><code>vm</code> 合约是“操作系统的超级管理员权限”，让你能修改这个虚拟系统的规则（比如给任意地址加钱、让A地址冒充B地址发交易）。</li>
</ul>
<h4 id="3-安全审计视角下的价值（补充你的认知）"><a href="#3-安全审计视角下的价值（补充你的认知）" class="headerlink" title="3. 安全审计视角下的价值（补充你的认知）"></a>3. 安全审计视角下的价值（补充你的认知）</h4><p>对安全审计人员来说，<code>vm</code> 合约的核心价值体现在：</p>
<ol>
<li><strong>低成本复现攻击场景</strong>：比如你之前的 Unstoppable 挑战，审计人员可以用 <code>vm.prank()</code> 模拟攻击者地址、<code>vm.deal()</code> 给攻击者加代币，快速验证合约是否存在漏洞；</li>
<li><strong>精准验证异常场景</strong>：用 <code>vm.expectRevert()</code> 验证合约是否能正确拦截恶意操作，用 <code>vm.expectEmit()</code> 验证关键事件是否按预期触发；</li>
<li><strong>隔离测试环境</strong>：每个测试用例的环境都是独立的，不会互相干扰，审计人员可以并行测试多个漏洞点，不用清理“测试残留”；</li>
<li><strong>突破真实链的限制</strong>：真实链上无法修改区块时间、无法读取私有变量，但 <code>vm.warp()</code>&#x2F;<code>vm.load()</code> 能轻松做到，方便审计人员测试时间锁、私有变量逻辑等边界场景。</li>
</ol>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ol>
<li>你的核心认知是对的：<code>vm</code> 合约和 VMware 类似，都是通过“虚拟环境”让测试&#x2F;审计更灵活，且不影响真实系统；</li>
<li>精准定位：<code>vm</code> 不是“虚拟机本身”，而是 Foundry 给 EVM 虚拟环境提供的<strong>超级控制工具</strong>；</li>
<li>对安全审计来说，<code>vm</code> 是测试智能合约漏洞的核心利器，能模拟各种攻击场景、验证合约的异常处理逻辑。</li>
</ol>
<p>这个类比能帮你快速理解核心，但记住“EVM 是虚拟机，vm 是控制虚拟机的工具”这个细节，能让你对 Foundry 的测试逻辑理解更透彻～</p>
<h1 id="为了掌握foundry，第一步是用foundry测试我之前一个月写过的各种sol智能合约"><a href="#为了掌握foundry，第一步是用foundry测试我之前一个月写过的各种sol智能合约" class="headerlink" title="为了掌握foundry，第一步是用foundry测试我之前一个月写过的各种sol智能合约"></a>为了掌握foundry，第一步是用foundry测试我之前一个月写过的各种sol智能合约</h1>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Web3/">Web3</a>
                    
                      <a class="hover-with-bg" href="/tags/foundry/">foundry</a>
                    
                  </div>
                
              </div>
              
                
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/12/19/54914.html">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">香港RWA审计</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/12/19/39328.html">
                        <span class="hidden-mobile">Damn Vulnerable DeFi（八）</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


            

                
                  <a id="scroll-top-button" href="#" role="button">
                    <i class="iconfont icon-arrowup" aria-hidden="true"></i>
                  </a>
                  

                    

                          
      </main>

      <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://whale3070.github.io/" target="_blank" rel="nofollow noopener"><span>Whale3070</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->




  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>





  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<link href="/pagefind/pagefind-ui.css" rel="stylesheet">
  <script src="/pagefind/pagefind-ui.js"></script>
  <style>
    /* 搜索框配色适配 */
    #search { margin-top: 2rem; }
    [data-user-color-scheme='dark'] .pagefind-ui {
      --pagefind-ui-primary: #eeeeee;
      --pagefind-ui-text: #eeeeee;
      --pagefind-ui-background: #151515;
      --pagefind-ui-border: #333;
    }
  </style>
    </body>

  </html>