

  <!DOCTYPE html>
  <html lang="zh-CN" data-default-color-scheme=&#34;dark&#34; >
  <style>
    .text1
    {
    text-shadow: 0px 0px 2px #f2f3f2;
    }
    </style>

  <script>
    // 强制内网 IP 识别为安全上下文
    if (window.location.hostname !== 'localhost' && window.location.protocol === 'http:') {
        // 尝试手动映射 crypto 属性
        if (!window.crypto.subtle && window.crypto.webkitSubtle) {
            window.crypto.subtle = window.crypto.webkitSubtle;
        }
    }
    
    // 终极补丁：如果还是没有 subtle，则创建一个占位符避免报错
    // 提示：这通常能解决加载报错，但如果插件强依赖原生加密，建议执行下面的“降级”预判
    if (!window.isSecureContext) {
        console.warn('当前环境非安全上下文，正在尝试兼容内网加密解密...');
    }
</script>


<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/null">
  <link rel="icon" type="image/png" href="/null">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>javascript - whale3070&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"192.168.126.129","root":"/","version":"1.8.7","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":false,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 7.3.0"></head>


    <body>
      <header style="height: 70vh;">
        <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>InfoSec learning</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/search/">
                <i class="iconfont icon-search"></i>
                搜索
              </a>
            </li>
          
        
        
        
          
        
      </ul>
    </div>
  </div>
</nav>

          <div class="banner" id="banner" false
            style="background: url('/img/default.png') no-repeat center center;
              background-size: cover;">
              <div class="full-bg-img">
                <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
                  <div class="page-header text-center fade-in-up">
                    <span class="h2 text1" id="subtitle" title="javascript">
                      
                        javascript
                      
                    </span>
        
                    
                      <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2025-12-02 13:45" pubdate>
        2025年12月2日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      8.6k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      99
       分钟
    </span>
  

  
  
</div>

                    
                  </div>
                    
                  </div>
                  
                </div>
              </div>
          </div>
      </header>

      <main>
        
          

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" data-pagefind-body>
            <!-- SEO header -->
            <h1 style="display: none">javascript</h1>
            
            <div class="markdown-body">
              <h1 id="我想要在香港找一个defi行业AMM相关的solidity开发的初级岗位，现在我需要如何学习，才能找2年之内找到工作"><a href="#我想要在香港找一个defi行业AMM相关的solidity开发的初级岗位，现在我需要如何学习，才能找2年之内找到工作" class="headerlink" title="我想要在香港找一个defi行业AMM相关的solidity开发的初级岗位，现在我需要如何学习，才能找2年之内找到工作"></a>我想要在香港找一个defi行业AMM相关的solidity开发的初级岗位，现在我需要如何学习，才能找2年之内找到工作</h1><p>结合你的背景（网安+985+INTP研究型性格）、目标（香港DeFi-AMM方向Solidity初级开发）和2年时间线，学习计划核心是**“基础打底→AMM深度聚焦→实战项目落地→香港本地化适配→求职冲刺”**，既利用你的网安优势形成差异化，又精准匹配岗位核心需求，具体可分为4个阶段，每个阶段有明确目标和可落地的学习动作：</p>
<h3 id="一、第一阶段：基础打底（3-4个月）——-搞定“能写合约”的核心能力"><a href="#一、第一阶段：基础打底（3-4个月）——-搞定“能写合约”的核心能力" class="headerlink" title="一、第一阶段：基础打底（3-4个月）—— 搞定“能写合约”的核心能力"></a>一、第一阶段：基础打底（3-4个月）—— 搞定“能写合约”的核心能力</h3><p>目标：从“网安思维”切换到“开发思维”，掌握Solidity开发的底层基础，能独立写简单合约（如ERC20、简单swap功能）</p>
<h4 id="核心学习内容："><a href="#核心学习内容：" class="headerlink" title="核心学习内容："></a>核心学习内容：</h4><ol>
<li><strong>前置编程基础（1个月）</strong>  <ul>
<li>补JavaScript&#x2F;TypeScript：Solidity开发依赖JS&#x2F;TS做测试、部署、交互，重点学ES6+语法、异步编程（async&#x2F;await）、数组&#x2F;对象操作，推荐看《JavaScript高级程序设计》+ 免费课程《JavaScript.info》  </li>
<li>熟悉Node.js：掌握npm&#x2F;yarn使用、模块导入导出，能跑简单脚本（后续部署合约要用）</li>
</ul>
</li>
<li><strong>区块链核心概念（2周）</strong>  <ul>
<li>搞懂DeFi底层逻辑：公链（以太坊为主，兼顾Polygon&#x2F;BSC，香港DeFi项目多部署在这些链）、智能合约、Gas费、区块确认、钱包（MetaMask）使用  </li>
<li>重点理解AMM的“底层逻辑雏形”：什么是流动性池、恒定乘积公式（x*y&#x3D;k）的基本含义、swap交易的流程（不用深算数学，先懂“交换”的核心逻辑）</li>
</ul>
</li>
<li><strong>Solidity入门到熟练（2-3个月）</strong>  <ul>
<li>核心语法：变量类型（uint256、address、mapping）、函数（view&#x2F;pure&#x2F;payable）、修饰符（modifier）、事件（event）、继承、接口（interface）、库（library，如SafeMath）  </li>
<li>重点攻克：合约安全（溢出&#x2F;下溢、重入攻击、权限控制）—— 这是你的网安优势！要比普通开发更懂“怎么写安全的合约”，比如用OpenZeppelin库的安全合约（ERC20、Ownable）  </li>
<li>学习资源：<br>✅ 官方文档：Solidity Docs（最新0.8.x版本，0.8+已内置溢出检查，不用手动加SafeMath）<br>✅ 实战课程：Patrick Collins的《FreeCodeCamp Solidity &amp; Blockchain Developer》（全免费，从入门到实战，DeFi方向首选）<br>✅ 练习平台：Remix IDE（在线写合约、编译、测试，适合入门）、Etherscan合约源码（找简单ERC20合约跟读，比如USDT的合约）</li>
</ul>
</li>
</ol>
<h4 id="阶段产出："><a href="#阶段产出：" class="headerlink" title="阶段产出："></a>阶段产出：</h4><ul>
<li>独立用Solidity写3个基础合约：ERC20代币合约（含转账、授权）、简单的“一对一swap合约”（固定汇率交换两个ERC20代币）、带权限控制的合约（只有Owner能修改参数）</li>
<li>能在Remix中部署合约，用MetaMask测试交互（转账、swap）</li>
</ul>
<h3 id="二、第二阶段：AMM深度聚焦（4-5个月）——-从“会写合约”到“懂AMM合约”"><a href="#二、第二阶段：AMM深度聚焦（4-5个月）——-从“会写合约”到“懂AMM合约”" class="headerlink" title="二、第二阶段：AMM深度聚焦（4-5个月）—— 从“会写合约”到“懂AMM合约”"></a>二、第二阶段：AMM深度聚焦（4-5个月）—— 从“会写合约”到“懂AMM合约”</h3><p>目标：吃透AMM的核心逻辑（以Uniswap V2为标杆，香港初级岗最常考），能复现AMM核心功能，理解流动性添加&#x2F;移除、swap、无常损失等关键流程</p>
<h4 id="核心学习内容：-1"><a href="#核心学习内容：-1" class="headerlink" title="核心学习内容："></a>核心学习内容：</h4><ol>
<li><p><strong>AMM核心理论（1个月）</strong>  </p>
<ul>
<li>深入拆解Uniswap V2：恒定乘积公式（x*y&#x3D;k）的数学逻辑、流动性池的创建（Pair合约）、添加&#x2F;移除流动性的计算（LP代币 mint&#x2F;burn）、swap的滑点计算、无常损失的成因（不用复杂数学，懂“价格波动导致LP资产缩水”的逻辑即可）  </li>
<li>扩展学习：Uniswap V3的核心改进（集中流动性、费率层级）—— 不用写V3合约，但要懂概念（面试会问）  </li>
<li>资源：Uniswap V2官方文档、《Uniswap V2白皮书》（简单易懂，重点看“核心机制”章节）</li>
</ul>
</li>
<li><p><strong>复现AMM核心合约（2-3个月）</strong>  </p>
<ul>
<li>第一步：复现Uniswap V2的核心合约（Pair合约+Factory合约）<br>✅ Pair合约：实现x*y&#x3D;k逻辑、添加流动性（addLiquidity）、移除流动性（removeLiquidity）、swap函数（代币交换）<br>✅ Factory合约：创建Pair池、查询Pair地址、管理Fee（简化版，不用复杂逻辑）  </li>
<li>第二步：集成OpenZeppelin库，优化安全（比如用SafeTransferFrom处理代币转账，避免重入攻击）  </li>
<li>工具：用Hardhat&#x2F;Truffle替代Remix（实战开发必备，支持本地测试网、部署脚本、测试用例编写）</li>
</ul>
</li>
<li><p><strong>AMM安全与漏洞分析（1个月）</strong>  </p>
<ul>
<li>重点分析AMM常见漏洞：重入攻击（比如早年DAO攻击）、价格操纵、闪电贷攻击、LP代币盗窃  </li>
<li>结合你的网安背景：用“攻防思维”审查自己写的AMM合约，比如添加重入锁（ReentrancyGuard）、校验代币转账返回值、限制单次swap金额上限  </li>
<li>资源：Rekt.news（看DeFi项目黑客事件复盘，重点看AMM相关案例）、OpenZeppelin Security Docs</li>
</ul>
</li>
</ol>
<h4 id="阶段产出：-1"><a href="#阶段产出：-1" class="headerlink" title="阶段产出："></a>阶段产出：</h4><ul>
<li>完整的“简化版Uniswap V2”项目：包含Factory合约、Pair合约、前端简单交互页面（用React&#x2F;Vue写个简单界面，能连接钱包、添加流动性、swap，不用复杂UI，能展示功能即可）  </li>
<li>项目部署到测试网（Sepolia&#x2F;Goerli），能公开访问、演示功能  </li>
<li>一篇技术博客&#x2F;项目README：拆解自己的AMM合约逻辑、安全优化点（面试时给面试官看，体现思考深度）</li>
</ul>
<h3 id="三、第三阶段：DeFi生态-香港本地化适配（3-4个月）——-让简历“适配香港岗位”"><a href="#三、第三阶段：DeFi生态-香港本地化适配（3-4个月）——-让简历“适配香港岗位”" class="headerlink" title="三、第三阶段：DeFi生态+香港本地化适配（3-4个月）—— 让简历“适配香港岗位”"></a>三、第三阶段：DeFi生态+香港本地化适配（3-4个月）—— 让简历“适配香港岗位”</h3><p>目标：熟悉香港DeFi行业生态、合规要求，补充实战工具链，打造“香港雇主需要的简历亮点”</p>
<h4 id="核心学习内容：-2"><a href="#核心学习内容：-2" class="headerlink" title="核心学习内容："></a>核心学习内容：</h4><ol>
<li><p><strong>DeFi生态工具链（1个月）</strong>  </p>
<ul>
<li>必备工具：Hardhat&#x2F;Truffle（部署测试）、Ethers.js&#x2F;Web3.js（合约交互）、Chai&#x2F;Mocha（写测试用例，初级岗也会要求基本测试能力）、Foundry（进阶测试工具，可选，加分项）  </li>
<li>数据查询：The Graph（查询链上数据，比如AMM池的流动性、交易记录，香港DeFi项目常用）、Etherscan API  </li>
<li>安全工具：Slither（静态代码分析，你的网安优势！会用Slither审计自己的AMM合约，面试时能聊“如何用工具检测漏洞”）</li>
</ul>
</li>
<li><p><strong>香港DeFi行业与合规（1个月）</strong>  </p>
<ul>
<li>生态了解：香港主流DeFi项目（如HashKey Exchange的DeFi板块、BC科技集团的相关业务）、香港Web3政策（VASP牌照、反洗钱AML要求）—— 初级岗不用懂太深，但要知道“香港DeFi强调合规”，比如合约要支持KYC验证、交易限额等合规逻辑  </li>
<li>合规编程：学习如何在合约中加入基础合规功能（比如只有通过KYC的地址才能交易、限制单笔交易金额）—— 这是香港岗位的差异化需求，比内地项目更看重</li>
</ul>
</li>
<li><p><strong>项目优化与作品集打造（1-2个月）</strong>  </p>
<ul>
<li>优化第二阶段的AMM项目：添加合规功能、完善测试用例（覆盖率≥70%）、优化代码结构（符合行业规范）  </li>
<li>额外加分项目：<br>✅ 参与开源AMM项目的Issue&#x2F;PR（比如Uniswap的开源仓库，哪怕是修复文档错误、简单bug，也能体现协作能力）<br>✅ 做一个“AMM漏洞复现demo”（比如复现一个简单的闪电贷攻击，体现你的网安+开发复合优势）  </li>
<li>作品集整理：GitHub仓库（代码规范、README详细）、测试网演示链接、技术博客（发布在Medium&#x2F;知乎，英文更佳，香港雇主常看）</li>
</ul>
</li>
</ol>
<h4 id="阶段产出：-2"><a href="#阶段产出：-2" class="headerlink" title="阶段产出："></a>阶段产出：</h4><ul>
<li>优化后的AMM项目（含合规功能、测试用例、前端交互）  </li>
<li>GitHub个人主页（整洁、重点突出AMM项目和技术栈）  </li>
<li>1-2篇英文技术博客（比如《How to Build a Simplified Uniswap V2 Clone》《Common Security Risks in AMM Contracts》）</li>
</ul>
<h3 id="四、第四阶段：求职冲刺（2-3个月）——-精准对接香港岗位"><a href="#四、第四阶段：求职冲刺（2-3个月）——-精准对接香港岗位" class="headerlink" title="四、第四阶段：求职冲刺（2-3个月）—— 精准对接香港岗位"></a>四、第四阶段：求职冲刺（2-3个月）—— 精准对接香港岗位</h3><p>目标：打磨简历、积累面试经验、拓展香港本地人脉，拿下初级Solidity开发offer</p>
<h4 id="核心动作："><a href="#核心动作：" class="headerlink" title="核心动作："></a>核心动作：</h4><ol>
<li><p><strong>简历与作品集优化（2周）</strong>  </p>
<ul>
<li>简历重点：突出“网安背景+AMM开发+香港适配”，比如：<br>✅ 技能栏：Solidity、JavaScript&#x2F;TypeScript、Hardhat、AMM协议（Uniswap V2&#x2F;V3）、区块链安全审计（Slither）、香港Web3合规基础<br>✅ 项目经历：详细写AMM项目（技术栈、核心功能、安全优化、合规设计、测试网部署）、网安相关经历（攻防工程师经验，强调“能写出更安全的合约”）  </li>
<li>格式：英文简历（香港公司优先看英文）、控制在1页内、附GitHub&#x2F;技术博客链接</li>
</ul>
</li>
<li><p><strong>面试准备（1-1.5个月）</strong>  </p>
<ul>
<li>技术面试：<br>✅ 刷Solidity基础题（变量类型、函数修饰符、合约安全）<br>✅ 刷AMM核心题（恒定乘积公式、流动性计算、swap流程、无常损失）<br>✅ 模拟编程题：现场写简单的AMM功能（比如添加流动性函数）、修复合约漏洞（比如重入攻击）  </li>
<li>行业认知：了解香港DeFi最新动态（比如香港金融管理局的Web3政策、主流项目的招聘需求）、准备“为什么选择香港DeFi”“为什么聚焦AMM”的回答  </li>
<li>资源：Glassdoor（看香港Solidity开发面试经验）、GitHub《Solidity Interview Questions》</li>
</ul>
</li>
<li><p><strong>香港本地人脉与投递（1-1.5个月）</strong>  </p>
<ul>
<li>线上 Networking：<br>✅ 加入香港Web3社群：Hong Kong Blockchain Association、Discord上的Hong Kong Web3、Twitter（X）关注香港DeFi项目官方账号（如HashKey、BC Technology），参与讨论、转发技术内容<br>✅ 加入招聘社群：LinkedIn搜索“Hong Kong Solidity Developer”，关注招聘账号，主动私信HR（附简历+作品集）  </li>
<li>线下活动：参加香港Web3 Meetup（如Hong Kong Web3 Wednesday）、区块链展会（比如香港Web3 Festival），现场交流递简历（香港小圈子，内推比海投有效10倍）  </li>
<li>投递渠道：LinkedIn（香港主流）、Indeed、项目官网招聘页、内推（重点！通过社群认识的行业人士内推，命中率翻倍）</li>
</ul>
</li>
</ol>
<h4 id="阶段产出：-3"><a href="#阶段产出：-3" class="headerlink" title="阶段产出："></a>阶段产出：</h4><ul>
<li>英文简历+作品集（GitHub+技术博客）  </li>
<li>10+场面试经验（逐步优化回答）  </li>
<li>拿到香港DeFi-AMM方向Solidity初级开发offer</li>
</ul>
<h3 id="关键优势放大-避坑提醒"><a href="#关键优势放大-避坑提醒" class="headerlink" title="关键优势放大+避坑提醒"></a>关键优势放大+避坑提醒</h3><h4 id="1-放大你的核心优势（网安-INTP）："><a href="#1-放大你的核心优势（网安-INTP）：" class="headerlink" title="1. 放大你的核心优势（网安+INTP）："></a>1. 放大你的核心优势（网安+INTP）：</h4><ul>
<li>面试时反复强调：“我有3年网安攻防经验，懂区块链漏洞原理，能写出更安全的AMM合约，这是普通开发没有的优势”  </li>
<li>INTP的研究型性格：面试时聊“我拆解过Uniswap V2的全部源码，发现XX安全细节”“我复现过XX AMM漏洞，总结了防范方法”，体现你的深挖能力</li>
</ul>
<h4 id="2-避坑提醒："><a href="#2-避坑提醒：" class="headerlink" title="2. 避坑提醒："></a>2. 避坑提醒：</h4><ul>
<li>不要只学语法不做项目：香港雇主极度看重实战，“能展示的AMM项目”比10个证书有用  </li>
<li>不要忽视合规：香港DeFi项目比内地更看重合规，简历和项目中一定要体现“合规意识”  </li>
<li>不要盲目海投：聚焦“AMM相关”岗位，不要投所有Solidity开发（比如NFT、GameFi），精准匹配才高效  </li>
<li>不要等“学完再投”：第二阶段结束后（有简化版AMM项目），就可以尝试投递初级岗&#x2F;实习岗，边面边学</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>2年时间完全足够实现目标——你的网安背景是差异化王牌，AMM是香港DeFi的核心赛道，再加上高才通身份（香港雇主优先考虑），只要按“基础→AMM聚焦→本地化适配→求职”的节奏推进，每阶段产出可落地的项目&#x2F;成果，面试时突出“安全+AMM+香港适配”的复合优势，拿下初级岗位的概率极高。</p>
<p>现在最该做的：从JavaScript和Solidity语法开始，1个月内完成前置基础，然后立刻切入AMM理论学习——不用纠结“学完所有知识再动手”，边学边写合约，实战中进步最快！</p>
<h1 id="solidity开发岗位要做测试的工作吗？"><a href="#solidity开发岗位要做测试的工作吗？" class="headerlink" title="solidity开发岗位要做测试的工作吗？"></a>solidity开发岗位要做测试的工作吗？</h1><p>我学了<a target="_blank" rel="noopener" href="https://cryptozombies.io/zh/course/%EF%BC%8C%E9%87%8C%E9%9D%A2%E6%8F%90%E5%88%B0%E4%BA%86%E7%94%A8javascript%E5%8E%BB%E6%B5%8B%E8%AF%95%E5%90%88%E7%BA%A6%EF%BC%8C%E7%94%A8truffles%E6%B5%8B%E8%AF%95%E3%80%82%E5%9C%A8%E4%BB%A5%E5%89%8D%E5%B7%A5%E4%BD%9C%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9A%84%E6%B5%8B%E8%AF%95%E5%BA%94%E8%AF%A5%E6%98%AF%E5%88%86%E5%BC%80%E6%9D%A5%E7%9A%84%E6%89%8D%E5%AF%B9%E5%90%A7">https://cryptozombies.io/zh/course/，里面提到了用javascript去测试合约，用truffles测试。在以前工作的时候，软件开发的测试应该是分开来的才对吧</a></p>
<p>在 Solidity 开发岗位中，<strong>测试是核心工作之一，开发者必须深度参与，甚至是测试工作的主要负责人</strong>——这和你之前接触的“开发与测试完全分开”的传统软件开发模式有明显区别，核心原因是区块链和智能合约的特殊性，具体可以从这几点详细说明：</p>
<h3 id="一、为什么-Solidity-开发不能“甩锅”给专门测试岗？"><a href="#一、为什么-Solidity-开发不能“甩锅”给专门测试岗？" class="headerlink" title="一、为什么 Solidity 开发不能“甩锅”给专门测试岗？"></a>一、为什么 Solidity 开发不能“甩锅”给专门测试岗？</h3><p>传统软件开发（比如Web、App）中，测试和开发分离的前提是：<strong>代码上线后可快速迭代修复、bug 造成的损失相对可控</strong>（比如一个按钮失效，紧急发版就能修复）。但智能合约完全不同：</p>
<ol>
<li><strong>合约部署后不可逆</strong>：一旦部署到以太坊、BSC等公链，合约代码无法修改（除非设计了升级机制，但升级也有严格限制），如果带bug上线，可能直接导致用户资产被盗、资金锁死（比如The DAO事件，因重入漏洞被盗5000万美元ETH，最终只能硬分叉修复）；</li>
<li><strong>测试环境需深度匹配链上逻辑</strong>：智能合约的测试不仅要验证“功能对不对”，还要模拟链上的特殊场景（比如gas限制、区块高度、重入攻击、权限控制），这些场景只有合约开发者最清楚逻辑边界（比如某个函数的权限是否只允许管理员调用、转账时是否会触发重入）；</li>
<li><strong>安全优先级远高于普通软件</strong>：智能合约直接处理资金，“没有测试到位”&#x3D;“直接暴露安全风险”，没有哪个测试岗能比开发者更懂自己写的合约逻辑细节（比如条件分支、异常处理、数据存储规则），所以开发者必须自己做“第一关测试”。</li>
</ol>
<h3 id="二、Solidity-开发者具体要做哪些测试？"><a href="#二、Solidity-开发者具体要做哪些测试？" class="headerlink" title="二、Solidity 开发者具体要做哪些测试？"></a>二、Solidity 开发者具体要做哪些测试？</h3><p>你在 Cryptozombies 里学的「JavaScript + Truffle 测试」是基础，但实际工作中测试覆盖的范围更广，核心分为3类：</p>
<h4 id="1-功能测试（最基础，必须掌握）"><a href="#1-功能测试（最基础，必须掌握）" class="headerlink" title="1. 功能测试（最基础，必须掌握）"></a>1. 功能测试（最基础，必须掌握）</h4><ul>
<li>目的：验证合约的核心逻辑是否符合预期（比如转账、铸造NFT、权限控制）；</li>
<li>工具：Truffle（你学的）、Hardhat（现在更主流，支持JS&#x2F;TS测试脚本）、Waffle（配合Hardhat的测试库）；</li>
<li>示例：比如测试“只有管理员能暂停合约”，你需要写测试脚本：① 用普通用户账号调用暂停函数，预期失败；② 用管理员账号调用，预期成功。</li>
</ul>
<h4 id="2-安全测试（核心重点，区别于传统开发）"><a href="#2-安全测试（核心重点，区别于传统开发）" class="headerlink" title="2. 安全测试（核心重点，区别于传统开发）"></a>2. 安全测试（核心重点，区别于传统开发）</h4><ul>
<li>目的：防御区块链特有的攻击（重入、溢出&#x2F;下溢、权限漏洞、_front_running等）；</li>
<li>工具：除了手动写测试脚本，还会用专门的安全工具辅助：<ul>
<li>Mythril、Slither（静态分析工具，自动检测常见漏洞）；</li>
<li>Foundry（用Solidity写测试脚本，更贴近合约逻辑，适合深度安全测试）；</li>
<li>模糊测试（比如Echidna）：随机生成大量输入，测试合约是否有隐藏漏洞；</li>
</ul>
</li>
<li>要求：开发者必须懂常见的智能合约漏洞原理，才能针对性写测试用例（比如测试重入漏洞，需要模拟“恶意合约回调窃取资金”的场景）。</li>
</ul>
<h4 id="3-边界测试-兼容性测试"><a href="#3-边界测试-兼容性测试" class="headerlink" title="3. 边界测试 &amp; 兼容性测试"></a>3. 边界测试 &amp; 兼容性测试</h4><ul>
<li>边界测试：验证极端场景（比如gas耗尽、输入最大值&#x2F;最小值、合约余额为0时的操作）；</li>
<li>兼容性测试：如果合约依赖其他协议（比如Uniswap、OpenZeppelin库），需要测试不同版本的兼容性。</li>
</ul>
<h3 id="三、实际工作中，测试分工是怎样的？（不是“开发者一个人扛”，但核心责任在你）"><a href="#三、实际工作中，测试分工是怎样的？（不是“开发者一个人扛”，但核心责任在你）" class="headerlink" title="三、实际工作中，测试分工是怎样的？（不是“开发者一个人扛”，但核心责任在你）"></a>三、实际工作中，测试分工是怎样的？（不是“开发者一个人扛”，但核心责任在你）</h3><p>虽然开发者要做测试，但不是完全没有分工，通常是“<strong>开发者主导测试，专业团队补充验证</strong>”：</p>
<ol>
<li><p>开发者的核心责任：</p>
<ul>
<li>编写单元测试（覆盖每个函数、每个条件分支）；</li>
<li>编写集成测试（验证合约之间的交互，或与其他协议的交互）；</li>
<li>手动进行核心场景的安全测试（比如模拟重入、权限越权）；</li>
<li>用工具（Slither&#x2F;Mythril）做初步漏洞扫描。</li>
</ul>
</li>
<li><p>补充测试角色（大型项目才有，小型项目可能由开发者兼任）：</p>
<ul>
<li>安全审计团队：第三方专业团队做深度审计（形式化验证、漏洞挖掘），出具审计报告（这是项目上线前的“必备环节”，但审计是“验证”，不是“替代开发者测试”）；</li>
<li>测试工程师：协助编写部分功能测试脚本，或做兼容性、性能测试（比如测试合约在高并发下的gas消耗）；</li>
<li>社区白帽测试：项目上线前开启漏洞赏金计划，让全球白帽黑客找漏洞。</li>
</ul>
</li>
</ol>
<p>简单说：<strong>开发者必须保证“自己的代码在已知场景下绝对安全”，审计和白帽测试是“查漏补缺”，不能指望别人帮你发现基础逻辑漏洞</strong>。</p>
<h3 id="四、对你的学习建议（结合你已经学了-Cryptozombies）"><a href="#四、对你的学习建议（结合你已经学了-Cryptozombies）" class="headerlink" title="四、对你的学习建议（结合你已经学了 Cryptozombies）"></a>四、对你的学习建议（结合你已经学了 Cryptozombies）</h3><p>你已经掌握了“JS + Truffle 测试”的基础，接下来可以重点补充：</p>
<ol>
<li>学习 Hardhat（现在行业主流，比Truffle更灵活，测试生态更完善），用JS&#x2F;TS写更复杂的测试用例（比如测试重入、权限控制）；</li>
<li>学习 OpenZeppelin Test Helpers（专门用于测试的工具库，简化权限、转账等测试场景）；</li>
<li>了解 Foundry（用Solidity写测试，适合深度安全测试，现在很多大厂都在⽤）；</li>
<li>学习智能合约常见漏洞（比如重入、溢出、权限漏洞），针对性写测试用例（比如用Hardhat模拟重入攻击）；</li>
<li>尝试用 Slither 扫描自己写的合约，看能否检测出漏洞，再完善测试。</li>
</ol>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>Solidity 开发岗位不是“要不要做测试”，而是“<strong>必须精通测试</strong>”——测试是智能合约安全的第一道防线，也是开发者的核心职责。和传统开发的分工差异，本质是区块链“不可逆、高风险”的特性决定的。你在 Cryptozombies 里学到的测试内容，是入门的基础，实际工作中需要覆盖更全面的功能和安全场景，测试能力直接决定你能否成为一名合格的 Solidity 开发者（面试时一定会问测试方法、工具使用、漏洞防御相关的问题）。</p>
<h1 id="看起来solidity开发岗位必须要精通javascript"><a href="#看起来solidity开发岗位必须要精通javascript" class="headerlink" title="看起来solidity开发岗位必须要精通javascript"></a>看起来solidity开发岗位必须要精通javascript</h1><p>其实不用“精通JavaScript”——<strong>Solidity开发对JS的要求是“够用就好”，核心是掌握“与合约交互相关的JS工具和场景”，而非前端&#x2F;全栈级别的JS精通</strong>。很多Solidity开发者甚至不擅长前端JS（比如Vue&#x2F;React），但能熟练用JS写测试、部署合约，完全不影响工作。</p>
<h3 id="先明确核心结论："><a href="#先明确核心结论：" class="headerlink" title="先明确核心结论："></a>先明确核心结论：</h3><ul>
<li>「推荐掌握JS&#x2F;TS」：因为目前行业主流的合约开发工具（Hardhat、Truffle）、测试框架（Mocha&#x2F;Chai）、合约交互库（Ethers.js、Web3.js）都基于JS&#x2F;TS生态，用起来最高效，面试和工作中最常用；</li>
<li>「不是必须精通」：不需要学JS的高级特性（比如闭包深度应用、设计模式、Node.js底层），也不用会前端框架（React&#x2F;Vue），重点是“能用JS完成合约相关的核心操作”；</li>
<li>「有替代方案」：如果实在不想用JS，也可以用Foundry（用Solidity写测试、部署），但Foundry更偏向“深度安全测试”，生态工具不如JS&#x2F;TS完善，很多项目还是会混合使用。</li>
</ul>
<h3 id="一、Solidity开发到底需要哪些JS能力？（划重点，不用多学）"><a href="#一、Solidity开发到底需要哪些JS能力？（划重点，不用多学）" class="headerlink" title="一、Solidity开发到底需要哪些JS能力？（划重点，不用多学）"></a>一、Solidity开发到底需要哪些JS能力？（划重点，不用多学）</h3><p>你只需要聚焦“<strong>合约开发相关的JS场景</strong>”，核心能力就3类，难度都不高：</p>
<h4 id="1-基础语法（够用就行）"><a href="#1-基础语法（够用就行）" class="headerlink" title="1. 基础语法（够用就行）"></a>1. 基础语法（够用就行）</h4><ul>
<li>变量、循环、条件判断、函数、Promise&#x2F;async&#x2F;await（处理异步交互，比如调用合约函数是异步操作）；</li>
<li>不用学原型链、继承、闭包这些复杂特性，能写简单的逻辑脚本就够。</li>
</ul>
<h4 id="2-合约交互库（核心重点）"><a href="#2-合约交互库（核心重点）" class="headerlink" title="2. 合约交互库（核心重点）"></a>2. 合约交互库（核心重点）</h4><ul>
<li>主要用 <strong>Ethers.js</strong>（现在行业主流，比Web3.js简洁），少数项目用Web3.js；</li>
<li>核心需求：用JS连接区块链（本地节点、测试网）、加载合约ABI、调用合约函数（读&#x2F;写）、发送交易（指定gas、签名）、处理交易回执；</li>
<li>示例（Ethers.js调用合约铸造NFT）：<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; ethers &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;hardhat&quot;</span>);<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">mintNFT</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 1. 连接合约（ABI + 合约地址）</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-title class_">NFTContract</span> = <span class="hljs-keyword">await</span> ethers.<span class="hljs-title function_">getContractAt</span>(<span class="hljs-string">&quot;MyNFT&quot;</span>, <span class="hljs-string">&quot;0x123...&quot;</span>);<br>  <span class="hljs-comment">// 2. 调用铸造函数（写操作，需要发送交易）</span><br>  <span class="hljs-keyword">const</span> tx = <span class="hljs-keyword">await</span> <span class="hljs-title class_">NFTContract</span>.<span class="hljs-title function_">mint</span>(<span class="hljs-string">&quot;ipfs://xxx&quot;</span>);<br>  <span class="hljs-comment">// 3. 等待交易上链</span><br>  <span class="hljs-keyword">await</span> tx.<span class="hljs-title function_">wait</span>();<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;NFT铸造成功&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>
这类代码逻辑固定，多写几次就熟练，不需要复杂JS技巧。</li>
</ul>
<h4 id="3-测试框架（核心重点）"><a href="#3-测试框架（核心重点）" class="headerlink" title="3. 测试框架（核心重点）"></a>3. 测试框架（核心重点）</h4><ul>
<li>用 <strong>Mocha + Chai</strong>（Hardhat&#x2F;Truffle默认集成），写合约的单元测试、集成测试；</li>
<li>核心需求：断言结果（比如判断函数返回值是否正确、交易是否失败）、模拟不同账号（管理员&#x2F;普通用户）、处理异常（比如预期某操作会revert）；</li>
<li>示例（测试合约权限）：<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; expect &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;chai&quot;</span>);<br><br><span class="hljs-title function_">describe</span>(<span class="hljs-string">&quot;MyContract&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">it</span>(<span class="hljs-string">&quot;普通用户不能暂停合约&quot;</span>, <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> [owner, user] = <span class="hljs-keyword">await</span> ethers.<span class="hljs-title function_">getSigners</span>();<br>    <span class="hljs-keyword">const</span> <span class="hljs-title class_">MyContract</span> = <span class="hljs-keyword">await</span> ethers.<span class="hljs-title function_">getContractFactory</span>(<span class="hljs-string">&quot;MyContract&quot;</span>);<br>    <span class="hljs-keyword">const</span> contract = <span class="hljs-keyword">await</span> <span class="hljs-title class_">MyContract</span>.<span class="hljs-title function_">deploy</span>();<br><br>    <span class="hljs-comment">// 预期普通用户调用pause会revert</span><br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">expect</span>(contract.<span class="hljs-title function_">connect</span>(user).<span class="hljs-title function_">pause</span>())<br>      .<span class="hljs-property">to</span>.<span class="hljs-property">be</span>.<span class="hljs-title function_">revertedWith</span>(<span class="hljs-string">&quot;Only admin allowed&quot;</span>);<br>  &#125;);<br>&#125;);<br></code></pre></div></td></tr></table></figure>
测试脚本的逻辑和合约逻辑强相关，你懂Solidity的话，写JS测试只是“用JS语法翻译合约的预期行为”，难度远低于前端开发。</li>
</ul>
<h3 id="二、为什么不用“精通JS”？（和前端JS的区别）"><a href="#二、为什么不用“精通JS”？（和前端JS的区别）" class="headerlink" title="二、为什么不用“精通JS”？（和前端JS的区别）"></a>二、为什么不用“精通JS”？（和前端JS的区别）</h3><p>Solidity开发用到的JS，和前端&#x2F;全栈JS完全是两个“应用场景”：</p>
<ul>
<li>前端JS：需要懂DOM操作、框架（React&#x2F;Vue）、状态管理、性能优化、浏览器兼容性，甚至TS的高级类型；</li>
<li>Solidity开发的JS：只需要懂“Node.js环境下的脚本编写”，核心是和区块链、合约交互，不用碰浏览器、前端UI，语法要求也简单。</li>
</ul>
<p>简单说：你不需要成为“JS高手”，只要能看懂、写得出上面这类“合约相关的JS脚本”，就完全满足工作需求。</p>
<h3 id="三、如果实在不想用JS，怎么办？"><a href="#三、如果实在不想用JS，怎么办？" class="headerlink" title="三、如果实在不想用JS，怎么办？"></a>三、如果实在不想用JS，怎么办？</h3><p>可以学 <strong>Foundry</strong>——一个用Solidity写测试、部署合约的工具，完全不用JS：</p>
<ul>
<li>测试脚本用Solidity写（比如判断交易是否revert、返回值是否正确），更贴近合约逻辑，不用切换语言思维；</li>
<li>部署、交互也可以用Solidity脚本或命令行完成；</li>
<li>缺点：生态比JS&#x2F;TS弱（比如部分第三方工具、兼容性测试工具只支持JS），很多项目会“Foundry做安全测试 + JS&#x2F;TS做功能测试&#x2F;部署”，混合使用。</li>
</ul>
<p>所以，Foundry是“补充方案”，不是“替代方案”，建议还是先掌握JS&#x2F;TS，再按需学Foundry。</p>
<h3 id="四、对你的学习建议（结合你已学的Cryptozombies）"><a href="#四、对你的学习建议（结合你已学的Cryptozombies）" class="headerlink" title="四、对你的学习建议（结合你已学的Cryptozombies）"></a>四、对你的学习建议（结合你已学的Cryptozombies）</h3><p>你已经学了“JS + Truffle”的基础，接下来不用深钻JS，重点聚焦“合约相关的JS应用”：</p>
<ol>
<li>优先学 <strong>Ethers.js + Hardhat</strong>（替代Truffle，现在行业主流）：<ul>
<li>跟着Hardhat官方文档，写几个合约的测试脚本（覆盖功能测试、权限测试、异常处理）；</li>
<li>重点练“用Ethers.js调用合约、发送交易、处理回执”，这是工作中最常用的；</li>
</ul>
</li>
<li>不用学JS的高级特性：比如原型链、闭包、设计模式、Node.js底层，够用就好；</li>
<li>按需学Foundry：如果觉得JS写测试别扭，或者想做深度安全测试，可以补充Foundry，不用一开始就啃；</li>
<li>目标：能独立用JS完成“合约测试 + 部署 + 简单交互”，就够应对面试和入门工作了。</li>
</ol>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>Solidity开发岗位「不需要精通JavaScript」，但「需要掌握合约相关的JS工具和场景」（Ethers.js、Hardhat、Mocha），这部分能力门槛不高，重点是“实用”而非“深入”。</p>
<p>JS&#x2F;TS是目前最高效的合约开发生态，掌握它能让你更快找到工作、适配大部分项目；如果实在不想用JS，也可以用Foundry补充，但不建议完全放弃JS&#x2F;TS。对你来说，最性价比的路径是：基于已学的JS基础，聚焦Hardhat + Ethers.js，练熟测试和部署脚本，不用在JS本身上花过多精力，把核心放在合约逻辑和安全上。</p>
<h1 id="如何快速掌握Solidity开发所需的JavaScript知识？"><a href="#如何快速掌握Solidity开发所需的JavaScript知识？" class="headerlink" title="如何快速掌握Solidity开发所需的JavaScript知识？"></a>如何快速掌握Solidity开发所需的JavaScript知识？</h1><p>要快速掌握 Solidity 开发所需的 JS 知识，核心逻辑是「<strong>聚焦核心场景、跳过冗余内容、边练边学</strong>」—— 只学“合约测试、部署、交互”相关的 JS 技能，不碰前端、Node.js 底层等无关内容，7-10 天就能达到“满足工作需求”的水平。以下是具体可落地的步骤和资源：</p>
<h3 id="一、先明确：只学这些，其余全跳过（节省-80-时间）"><a href="#一、先明确：只学这些，其余全跳过（节省-80-时间）" class="headerlink" title="一、先明确：只学这些，其余全跳过（节省 80% 时间）"></a>一、先明确：只学这些，其余全跳过（节省 80% 时间）</h3><h4 id="必学的-3-个核心场景（Solidity-开发唯一用到-JS-的地方）"><a href="#必学的-3-个核心场景（Solidity-开发唯一用到-JS-的地方）" class="headerlink" title="必学的 3 个核心场景（Solidity 开发唯一用到 JS 的地方）"></a>必学的 3 个核心场景（Solidity 开发唯一用到 JS 的地方）</h4><ol>
<li>合约测试（Mocha + Chai + Ethers.js）</li>
<li>合约部署脚本（Hardhat 环境）</li>
<li>合约交互（调用函数、发送交易、处理回执）</li>
</ol>
<h4 id="完全不用学的-JS-内容（直接放弃）"><a href="#完全不用学的-JS-内容（直接放弃）" class="headerlink" title="完全不用学的 JS 内容（直接放弃）"></a>完全不用学的 JS 内容（直接放弃）</h4><ul>
<li>前端相关：DOM 操作、React&#x2F;Vue、浏览器兼容性、CSS&#x2F;HTML 结合</li>
<li>JS 高级特性：原型链、闭包、继承、设计模式、Generator、Proxy</li>
<li>Node.js 底层：Event Loop 原理、流（Stream）、文件系统深度操作</li>
<li>TS 高级：泛型复杂用法、类型体操、装饰器</li>
</ul>
<p>简单说：<strong>只要能写“Node.js 环境下的简单脚本，能调用 Ethers.js 与合约交互”，就够了</strong>。</p>
<h3 id="二、快速学习路径（7-天版，每天-2-3-小时）"><a href="#二、快速学习路径（7-天版，每天-2-3-小时）" class="headerlink" title="二、快速学习路径（7 天版，每天 2-3 小时）"></a>二、快速学习路径（7 天版，每天 2-3 小时）</h3><h4 id="Day-1：JS-基础（只学“够用的最小集”）"><a href="#Day-1：JS-基础（只学“够用的最小集”）" class="headerlink" title="Day 1：JS 基础（只学“够用的最小集”）"></a>Day 1：JS 基础（只学“够用的最小集”）</h4><p>不用看厚重教程，聚焦“能写测试&#x2F;部署脚本”的基础语法：</p>
<ol>
<li>变量&#x2F;数据类型：<code>let/const</code>、字符串、数字、对象（重点）、数组</li>
<li>流程控制：<code>if-else</code>、<code>for</code> 循环（遍历测试用例）、<code>try/catch</code>（捕获合约异常）</li>
<li>函数：普通函数、箭头函数（写测试回调）</li>
<li>异步编程（核心中的核心）：<code>Promise</code> 基础、<code>async/await</code>（合约交互全是异步，必须掌握）</li>
</ol>
<p>✅ 学习资源（1-2 小时搞定）：</p>
<ul>
<li>菜鸟教程 JS 异步部分：<a target="_blank" rel="noopener" href="https://www.runoob.com/js/js-promise.html">https://www.runoob.com/js/js-promise.html</a></li>
<li>直接看这篇短文：《JS async&#x2F;await 入门到够用》（百度搜索，10 分钟看懂）</li>
</ul>
<p>✅ 小练习（巩固异步）：<br>写一个简单的 async 函数，模拟“调用合约→等待结果”的流程：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 模拟合约调用（异步操作）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fakeContractCall</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;合约调用成功&quot;</span>), <span class="hljs-number">1000</span>);<br>  &#125;);<br>&#125;<br><br><span class="hljs-comment">// 用 async/await 处理异步</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;开始调用合约&quot;</span>);<br>  <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fakeContractCall</span>(); <span class="hljs-comment">// 等待异步结果</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// 输出：合约调用成功</span><br>&#125;<br><br><span class="hljs-title function_">test</span>();<br></code></pre></div></td></tr></table></figure>


<h4 id="Day-2-3：Hardhat-Ethers-js（核心工具，Solidity-开发的-JS-核心）"><a href="#Day-2-3：Hardhat-Ethers-js（核心工具，Solidity-开发的-JS-核心）" class="headerlink" title="Day 2-3：Hardhat + Ethers.js（核心工具，Solidity 开发的 JS 核心）"></a>Day 2-3：Hardhat + Ethers.js（核心工具，Solidity 开发的 JS 核心）</h4><p>Hardhat 是现在行业主流的合约开发工具，内置了 Ethers.js、Mocha&#x2F;Chai，不用单独配置，直接聚焦“用工具做事”。</p>
<h5 id="第一步：搭建环境（30-分钟）"><a href="#第一步：搭建环境（30-分钟）" class="headerlink" title="第一步：搭建环境（30 分钟）"></a>第一步：搭建环境（30 分钟）</h5><ol>
<li>安装 Node.js（v16+，官网下载：<a target="_blank" rel="noopener" href="https://nodejs.org/%EF%BC%89">https://nodejs.org/）</a></li>
<li>初始化 Hardhat 项目：<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> solidity-js-test &amp;&amp; <span class="hljs-built_in">cd</span> solidity-js-test<br>npm init -y<br>npm install --save-dev hardhat @nomiclabs/hardhat-ethers ethers chai @nomiclabs/hardhat-waffle<br>npx hardhat init <span class="hljs-comment"># 选 Create a JavaScript project，一路回车</span><br></code></pre></div></td></tr></table></figure></li>
<li>熟悉项目结构：重点关注 <code>test/</code>（测试脚本）、<code>scripts/</code>（部署脚本）、<code>contracts/</code>（合约文件）</li>
</ol>
<h5 id="第二步：Ethers-js-核心-API（1-天，只学常用的，不用全记）"><a href="#第二步：Ethers-js-核心-API（1-天，只学常用的，不用全记）" class="headerlink" title="第二步：Ethers.js 核心 API（1 天，只学常用的，不用全记）"></a>第二步：Ethers.js 核心 API（1 天，只学常用的，不用全记）</h5><p>Ethers.js 是和合约交互的库，只需要掌握以下 5 个高频操作，其余用到再查文档：</p>
<ol>
<li>连接区块链（本地节点&#x2F;Hardhat 内置节点）</li>
<li>获取账号（<code>ethers.getSigners()</code>）</li>
<li>加载合约（<code>getContractFactory</code> 部署时用，<code>getContractAt</code> 已部署合约用）</li>
<li>调用合约函数（读操作：直接调用；写操作：<code>await</code> 发送交易 + <code>tx.wait()</code> 等上链）</li>
<li>处理交易回执（<code>tx.hash</code>、<code>tx.gasUsed</code>）</li>
</ol>
<p>✅ 官方极简教程（直接抄代码练）：<a target="_blank" rel="noopener" href="https://docs.ethers.org/v5/getting-started/">https://docs.ethers.org/v5/getting-started/</a><br>✅ 常用 API 示例（直接复制到 Hardhat 脚本中运行）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 1. 获取账号（测试/部署时用）</span><br><span class="hljs-keyword">const</span> [owner, user1, user2] = <span class="hljs-keyword">await</span> ethers.<span class="hljs-title function_">getSigners</span>(); <span class="hljs-comment">// owner 是部署者</span><br><br><span class="hljs-comment">// 2. 部署合约（scripts/deploy.js 中）</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyContract</span> = <span class="hljs-keyword">await</span> ethers.<span class="hljs-title function_">getContractFactory</span>(<span class="hljs-string">&quot;MyContract&quot;</span>); <span class="hljs-comment">// 加载合约工厂</span><br><span class="hljs-keyword">const</span> contract = <span class="hljs-keyword">await</span> <span class="hljs-title class_">MyContract</span>.<span class="hljs-title function_">deploy</span>(); <span class="hljs-comment">// 部署</span><br><span class="hljs-keyword">await</span> contract.<span class="hljs-title function_">deployed</span>(); <span class="hljs-comment">// 等待部署完成</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;合约地址：&quot;</span>, contract.<span class="hljs-property">address</span>);<br><br><span class="hljs-comment">// 3. 调用合约读函数（不需要交易）</span><br><span class="hljs-keyword">const</span> balance = <span class="hljs-keyword">await</span> contract.<span class="hljs-title function_">balanceOf</span>(owner.<span class="hljs-property">address</span>); <span class="hljs-comment">// 读余额</span><br><br><span class="hljs-comment">// 4. 调用合约写函数（需要发送交易）</span><br><span class="hljs-keyword">const</span> tx = <span class="hljs-keyword">await</span> contract.<span class="hljs-title function_">transfer</span>(user1.<span class="hljs-property">address</span>, <span class="hljs-number">100</span>); <span class="hljs-comment">// 转账</span><br><span class="hljs-keyword">await</span> tx.<span class="hljs-title function_">wait</span>(); <span class="hljs-comment">// 等待上链</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;交易哈希：&quot;</span>, tx.<span class="hljs-property">hash</span>);<br><br><span class="hljs-comment">// 5. 模拟不同账号调用（测试权限用）</span><br><span class="hljs-keyword">await</span> contract.<span class="hljs-title function_">connect</span>(user1).<span class="hljs-title function_">transfer</span>(user2.<span class="hljs-property">address</span>, <span class="hljs-number">50</span>); <span class="hljs-comment">// 用 user1 调用</span><br></code></pre></div></td></tr></table></figure>

<h5 id="第三步：Mocha-Chai-测试语法（1-天，够用就好）"><a href="#第三步：Mocha-Chai-测试语法（1-天，够用就好）" class="headerlink" title="第三步：Mocha + Chai 测试语法（1 天，够用就好）"></a>第三步：Mocha + Chai 测试语法（1 天，够用就好）</h5><p>Hardhat 内置了 Mocha（测试框架）和 Chai（断言库），只需要掌握 3 个核心用法：</p>
<ol>
<li>测试结构：<code>describe()</code>（测试套件）、<code>it()</code>（测试用例）</li>
<li>断言：<code>expect(结果).to.equal(预期)</code>（判断值相等）、<code>expect(操作).to.be.revertedWith(&quot;错误信息&quot;)</code>（判断合约 revert）</li>
<li>测试前置&#x2F;后置：<code>beforeEach()</code>（每个用例前部署合约，避免重复代码）</li>
</ol>
<p>✅ 测试脚本示例（test&#x2F;MyContract.test.js）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; expect &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;chai&quot;</span>);<br><br><span class="hljs-comment">// 测试套件（对应一个合约）</span><br><span class="hljs-title function_">describe</span>(<span class="hljs-string">&quot;MyContract&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-title class_">MyContract</span>;<br>  <span class="hljs-keyword">let</span> contract;<br>  <span class="hljs-keyword">let</span> owner, user1;<br><br>  <span class="hljs-comment">// 每个测试用例前执行（部署合约，获取账号）</span><br>  <span class="hljs-title function_">beforeEach</span>(<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    [owner, user1] = <span class="hljs-keyword">await</span> ethers.<span class="hljs-title function_">getSigners</span>();<br>    <span class="hljs-title class_">MyContract</span> = <span class="hljs-keyword">await</span> ethers.<span class="hljs-title function_">getContractFactory</span>(<span class="hljs-string">&quot;MyContract&quot;</span>);<br>    contract = <span class="hljs-keyword">await</span> <span class="hljs-title class_">MyContract</span>.<span class="hljs-title function_">deploy</span>();<br>    <span class="hljs-keyword">await</span> contract.<span class="hljs-title function_">deployed</span>();<br>  &#125;);<br><br>  <span class="hljs-comment">// 测试用例 1：部署后 owner 余额正确</span><br>  <span class="hljs-title function_">it</span>(<span class="hljs-string">&quot;should set the right owner balance&quot;</span>, <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> balance = <span class="hljs-keyword">await</span> contract.<span class="hljs-title function_">balanceOf</span>(owner.<span class="hljs-property">address</span>);<br>    <span class="hljs-title function_">expect</span>(balance).<span class="hljs-property">to</span>.<span class="hljs-title function_">equal</span>(ethers.<span class="hljs-property">utils</span>.<span class="hljs-title function_">parseEther</span>(<span class="hljs-string">&quot;1000&quot;</span>)); <span class="hljs-comment">// 预期初始余额 1000</span><br>  &#125;);<br><br>  <span class="hljs-comment">// 测试用例 2：普通用户不能调用管理员函数</span><br>  <span class="hljs-title function_">it</span>(<span class="hljs-string">&quot;should reject non-owner calls to admin function&quot;</span>, <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 预期 user1 调用 adminFunction 会 revert，错误信息是 &quot;Only owner&quot;</span><br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">expect</span>(contract.<span class="hljs-title function_">connect</span>(user1).<span class="hljs-title function_">adminFunction</span>())<br>      .<span class="hljs-property">to</span>.<span class="hljs-property">be</span>.<span class="hljs-title function_">revertedWith</span>(<span class="hljs-string">&quot;Only owner&quot;</span>);<br>  &#125;);<br>&#125;);<br></code></pre></div></td></tr></table></figure>

<p>✅ 运行测试：<code>npx hardhat test</code>，看是否全部通过，学会根据报错修改脚本。</p>
<h4 id="Day-4-5：实战小项目（把-JS-技能串起来）"><a href="#Day-4-5：实战小项目（把-JS-技能串起来）" class="headerlink" title="Day 4-5：实战小项目（把 JS 技能串起来）"></a>Day 4-5：实战小项目（把 JS 技能串起来）</h4><p>光看没用，必须动手练！用一个简单合约（比如“可转账的代币合约”），完成“写合约→JS 测试→JS 部署→JS 交互”全流程：</p>
<h5 id="步骤-1：写一个简单合约（contracts-MyToken-sol）"><a href="#步骤-1：写一个简单合约（contracts-MyToken-sol）" class="headerlink" title="步骤 1：写一个简单合约（contracts&#x2F;MyToken.sol）"></a>步骤 1：写一个简单合约（contracts&#x2F;MyToken.sol）</h5><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.17;<br><br>contract MyToken &#123;<br>  string public name = &quot;MyToken&quot;;<br>  mapping(address =&gt; uint256) public balanceOf;<br><br>  constructor() &#123;<br>    balanceOf[msg.sender] = 1000; // 部署者初始 1000 代币<br>  &#125;<br><br>  function transfer(address to, uint256 amount) public &#123;<br>    require(balanceOf[msg.sender] &gt;= amount, &quot;Insufficient balance&quot;);<br>    balanceOf[msg.sender] -= amount;<br>    balanceOf[to] += amount;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h5 id="步骤-2：写-JS-测试脚本（test-MyToken-test-js）"><a href="#步骤-2：写-JS-测试脚本（test-MyToken-test-js）" class="headerlink" title="步骤 2：写 JS 测试脚本（test&#x2F;MyToken.test.js）"></a>步骤 2：写 JS 测试脚本（test&#x2F;MyToken.test.js）</h5><p>覆盖 3 个核心场景：</p>
<ol>
<li>部署后部署者余额是 1000；</li>
<li>转账功能正常（A 转 B 后余额变化正确）；</li>
<li>余额不足时转账会 revert。</li>
</ol>
<h5 id="步骤-3：写-JS-部署脚本（scripts-deploy-js）"><a href="#步骤-3：写-JS-部署脚本（scripts-deploy-js）" class="headerlink" title="步骤 3：写 JS 部署脚本（scripts&#x2F;deploy.js）"></a>步骤 3：写 JS 部署脚本（scripts&#x2F;deploy.js）</h5><p>部署到 Hardhat 本地测试网，输出合约地址。</p>
<h5 id="步骤-4：写-JS-交互脚本（scripts-interact-js）"><a href="#步骤-4：写-JS-交互脚本（scripts-interact-js）" class="headerlink" title="步骤 4：写 JS 交互脚本（scripts&#x2F;interact.js）"></a>步骤 4：写 JS 交互脚本（scripts&#x2F;interact.js）</h5><p>加载已部署的合约，调用 <code>transfer</code> 函数，查询余额。</p>
<p>✅ 运行命令练手：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">npx hardhat node <span class="hljs-comment"># 启动本地测试网</span><br>npx hardhat <span class="hljs-built_in">test</span> <span class="hljs-comment"># 运行测试（验证 JS 测试脚本）</span><br>npx hardhat run scripts/deploy.js --network localhost <span class="hljs-comment"># 部署到本地网</span><br>npx hardhat run scripts/interact.js --network localhost <span class="hljs-comment"># 交互测试</span><br></code></pre></div></td></tr></table></figure>

<p>通过这个小项目，你会发现“JS 与合约交互”的逻辑非常固定，练 2-3 遍就形成肌肉记忆了。</p>
<h4 id="Day-6-7：补充工具和避坑指南（提升效率）"><a href="#Day-6-7：补充工具和避坑指南（提升效率）" class="headerlink" title="Day 6-7：补充工具和避坑指南（提升效率）"></a>Day 6-7：补充工具和避坑指南（提升效率）</h4><h5 id="1-OpenZeppelin-Test-Helpers（简化测试）"><a href="#1-OpenZeppelin-Test-Helpers（简化测试）" class="headerlink" title="1. OpenZeppelin Test Helpers（简化测试）"></a>1. OpenZeppelin Test Helpers（简化测试）</h5><p>很多测试场景（比如判断权限、时间锁定）不用自己写 JS 逻辑，直接用现成工具：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">npm install --save-dev @openzeppelin/test-helpers<br></code></pre></div></td></tr></table></figure>
<p>示例（测试权限）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; expectRevert &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@openzeppelin/test-helpers&quot;</span>);<br><span class="hljs-comment">// 替代之前的 revert 断言，更简洁</span><br><span class="hljs-keyword">await</span> <span class="hljs-title function_">expectRevert</span>(<br>  contract.<span class="hljs-title function_">connect</span>(user1).<span class="hljs-title function_">adminFunction</span>(),<br>  <span class="hljs-string">&quot;Only owner&quot;</span><br>);<br></code></pre></div></td></tr></table></figure>

<h5 id="2-常见坑和解决方案（避免踩雷）"><a href="#2-常见坑和解决方案（避免踩雷）" class="headerlink" title="2. 常见坑和解决方案（避免踩雷）"></a>2. 常见坑和解决方案（避免踩雷）</h5><ul>
<li>坑 1：忘记 <code>await</code> 异步操作（比如 <code>const tx = contract.transfer(...)</code> 没加 <code>await</code>，导致 tx 是 Promise 对象）→ 解决方案：所有合约调用、交易都加 <code>await</code>；</li>
<li>坑 2：数值单位问题（Solidity 中是 wei，JS 中直接传数字会出错）→ 解决方案：用 <code>ethers.utils.parseEther(&quot;1.0&quot;)</code> 转 wei，<code>ethers.utils.formatEther(balance)</code> 转 ETH；</li>
<li>坑 3：测试时合约状态污染（一个用例影响另一个）→ 解决方案：用 <code>beforeEach()</code> 每个用例前重新部署合约；</li>
<li>坑 4：不知道如何模拟链上场景（比如区块高度、gas 限制）→ 解决方案：Hardhat 内置 <code>evm_increaseTime</code> 等方法，查官方文档即可。</li>
</ul>
<h5 id="3-查文档的正确姿势（不用死记硬背）"><a href="#3-查文档的正确姿势（不用死记硬背）" class="headerlink" title="3. 查文档的正确姿势（不用死记硬背）"></a>3. 查文档的正确姿势（不用死记硬背）</h5><p>遇到不懂的 API 不用慌，直接查以下文档（不用通读，按需搜索）：</p>
<ul>
<li>Ethers.js 文档（优先查）：<a target="_blank" rel="noopener" href="https://docs.ethers.org/v5/api/">https://docs.ethers.org/v5/api/</a></li>
<li>Hardhat 文档（测试&#x2F;部署相关）：<a target="_blank" rel="noopener" href="https://hardhat.org/docs">https://hardhat.org/docs</a></li>
<li>Chai 断言文档：<a target="_blank" rel="noopener" href="https://www.chaijs.com/api/bdd/">https://www.chaijs.com/api/bdd/</a></li>
</ul>
<h3 id="三、判断是否“达标”的-3-个标准（能做到就够面试-工作了）"><a href="#三、判断是否“达标”的-3-个标准（能做到就够面试-工作了）" class="headerlink" title="三、判断是否“达标”的 3 个标准（能做到就够面试&#x2F;工作了）"></a>三、判断是否“达标”的 3 个标准（能做到就够面试&#x2F;工作了）</h3><ol>
<li>能独立用 JS 写测试脚本：覆盖合约所有函数，包括正常流程、异常场景（revert）、权限控制；</li>
<li>能独立用 JS 写部署脚本：部署合约到测试网（比如 Goerli），处理部署后的初始化（比如设置管理员）；</li>
<li>能独立用 JS 写交互脚本：调用已部署合约的读&#x2F;写函数，处理交易回执，查询结果。</li>
</ol>
<h3 id="四、推荐轻量资源（拒绝厚重教程）"><a href="#四、推荐轻量资源（拒绝厚重教程）" class="headerlink" title="四、推荐轻量资源（拒绝厚重教程）"></a>四、推荐轻量资源（拒绝厚重教程）</h3><ol>
<li>Hardhat 官方入门教程（必看）：<a target="_blank" rel="noopener" href="https://hardhat.org/tutorial">https://hardhat.org/tutorial</a></li>
<li>Ethers.js 快速入门：<a target="_blank" rel="noopener" href="https://docs.ethers.org/v5/getting-started/">https://docs.ethers.org/v5/getting-started/</a></li>
<li>测试脚本示例（直接抄）：<a target="_blank" rel="noopener" href="https://github.com/NomicFoundation/hardhat-examples/tree/main/testing-with-ethers">https://github.com/NomicFoundation/hardhat-examples/tree/main/testing-with-ethers</a></li>
<li>视频教程（可选，适合喜欢看视频的）：B站“Hardhat + Ethers.js 智能合约开发”（搜关键词，找 1-2 小时的短教程，不用看长系列）</li>
</ol>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>快速掌握的关键是「<strong>不贪多、不深钻、重实战</strong>」—— 跳过所有和“合约交互、测试、部署”无关的 JS 内容，聚焦 Hardhat + Ethers.js + Mocha&#x2F;Chai，用一个小项目把所有技能串起来，7 天就能达到“满足 Solidity 开发需求”的水平。</p>
<p>你已经有 Cryptozombies 的 JS 基础，现在只需要把“Truffle 换成 Hardhat”，重点练测试和部署脚本，不用在 JS 本身上花过多时间，核心还是要回归 Solidity 合约逻辑和安全，但 JS 作为工具，练熟这些就足够支撑你开展工作了。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Web3/">Web3</a>
                    
                  </div>
                
              </div>
              
                
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/12/03/59853.html">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">javascript2</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/11/27/30704.html">
                        <span class="hidden-mobile">cryptozombies12-NEO、zkSync</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


            

                
                  <a id="scroll-top-button" href="#" role="button">
                    <i class="iconfont icon-arrowup" aria-hidden="true"></i>
                  </a>
                  

                    

                          
      </main>

      <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://whale3070.github.io/" target="_blank" rel="nofollow noopener"><span>Whale3070</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->




  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<link href="/pagefind/pagefind-ui.css" rel="stylesheet">
  <script src="/pagefind/pagefind-ui.js"></script>
  <style>
    /* 搜索框配色适配 */
    #search { margin-top: 2rem; }
    [data-user-color-scheme='dark'] .pagefind-ui {
      --pagefind-ui-primary: #eeeeee;
      --pagefind-ui-text: #eeeeee;
      --pagefind-ui-background: #151515;
      --pagefind-ui-border: #333;
    }
  </style>
    </body>

  </html>