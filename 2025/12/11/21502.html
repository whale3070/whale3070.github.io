

  <!DOCTYPE html>
  <html lang="zh-CN" data-default-color-scheme=&#34;dark&#34; >
  <style>
    .text1
    {
    text-shadow: 0px 0px 2px #f2f3f2;
    }
    </style>

  <script>
    // 强制内网 IP 识别为安全上下文
    if (window.location.hostname !== 'localhost' && window.location.protocol === 'http:') {
        // 尝试手动映射 crypto 属性
        if (!window.crypto.subtle && window.crypto.webkitSubtle) {
            window.crypto.subtle = window.crypto.webkitSubtle;
        }
    }
    
    // 终极补丁：如果还是没有 subtle，则创建一个占位符避免报错
    // 提示：这通常能解决加载报错，但如果插件强依赖原生加密，建议执行下面的“降级”预判
    if (!window.isSecureContext) {
        console.warn('当前环境非安全上下文，正在尝试兼容内网加密解密...');
    }
</script>


<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/null">
  <link rel="icon" type="image/png" href="/null">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>university.alchemy3 - whale3070&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.4.0/styles/github-gist.min.css" />
    
  

  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"whale3070.github.io","root":"/","version":"1.8.7","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":false,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 7.3.0"></head>


    <body>
      <header style="height: 70vh;">
        <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>InfoSec learning</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/search/">
                <i class="iconfont icon-search"></i>
                搜索
              </a>
            </li>
          
        
        
        
          
        
      </ul>
    </div>
  </div>
</nav>

          <div class="banner" id="banner" false
            style="background: url('/img/default.png') no-repeat center center;
              background-size: cover;">
              <div class="full-bg-img">
                <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
                  <div class="page-header text-center fade-in-up">
                    <span class="h2 text1" id="subtitle" title="university.alchemy3">
                      
                        university.alchemy3
                      
                    </span>
        
                    
                      <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2025-12-11 09:21" pubdate>
        2025年12月11日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6.2k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      72
       分钟
    </span>
  

  
  
</div>

                    
                  </div>
                    
                  </div>
                  
                </div>
              </div>
          </div>
      </header>

      <main>
        
          

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" data-pagefind-body>
            <!-- SEO header -->
            <h1 style="display: none">university.alchemy3</h1>
            
            <div class="markdown-body">
              <p>你会注意到，<code>receive</code> 不使用 <code>function</code> 关键字。这是因为它是一个特殊函数（类似 <code>constructor</code> 构造函数）。当合约在未接收任何调用数据（calldata）的情况下收到以太币（ether），或者当调用数据与合约上的任何函数签名都不匹配时，<code>receive</code> 函数就会执行。</p>
<p><code>receive</code> 函数必须满足以下要求：</p>
<ul>
<li>可见性为 <code>external</code>（外部可见）</li>
<li>包含 <code>payable</code> 修饰符（支持接收以太币）</li>
<li>不能接收参数</li>
<li>不能返回任何值</li>
</ul>
<h3 id="补充说明（针对Solidity语境）："><a href="#补充说明（针对Solidity语境）：" class="headerlink" title="补充说明（针对Solidity语境）："></a>补充说明（针对Solidity语境）：</h3><ul>
<li><strong>calldata</strong>：指外部调用合约时传入的数据，主要用于指定调用的函数及参数，是Solidity中常见的特殊数据位置。</li>
<li><strong>function signature</strong>：函数签名，由函数名和参数类型组成（如 <code>transfer(address,uint256)</code>），合约通过匹配签名确定要执行的函数，若无法匹配则触发 <code>receive</code> 函数（若未定义则交易会失败）。</li>
<li>该函数是Solidity中处理“无明确函数调用的以太币转账”的核心机制，常见于接收普通转账、处理合约间默认交互等场景。</li>
</ul>
<h1 id="外部可见性"><a href="#外部可见性" class="headerlink" title="外部可见性"></a>外部可见性</h1><p>我们已经讨论了公共可见性和私有可见性。那么什么是外部可见性呢？为什么接收函数需要外部可见性？<br>外部函数只能通过来自另一个合约或外部账户（EOA）的消息调用进行调用。相比之下，内部函数调用直接从合约的当前执行上下文中访问变量，无需像调用数据（calldata）这样的外部输入。<br>接收函数需要外部可见性，因为它的设计目的是通过消息调用接收以太币。其主要作用是为开发者提供一个函数体，在其中可以定义处理合约接收以太币的逻辑。<br>与此非常相似，回退函数也需要外部可见性。你可能会问，什么是回退函数？朋友，继续往下读吧！</p>
<h1 id="回退函数"><a href="#回退函数" class="headerlink" title="回退函数"></a>回退函数</h1><p>回退函数就好比是当其他所有函数都“不接电话”时，你会调用的那个函数！</p>
<p>不开玩笑了，它其实真就这么简单。<br>当智能合约收到的调用数据与它的任何函数签名都不匹配，或者调用数据为空时，回退函数就会被触发。这可能由多种原因导致，比如函数名拼写错误、参数类型不正确，甚至是为了有意存储调用数据以备将来使用（例如在后续的消息调用中）。如果合约不知道如何响应用户发送给它的数据，它就会调用回退函数。<br>回退函数也是一个特殊的函数，其形式如下：<br>contract Contract {<br>    fallback() external {<br>        &#x2F;&#x2F; 做些事情<br>    }<br>}</p>
<p>和接收函数一样，回退函数必须是外部的，它不能接受任何参数，也不能返回任何值。但与接收函数不同的是，回退函数不需要是可支付的（payable）。<br>通过一个可支付的回退函数，你基本上可以替代接收函数，但在大多数情况下，这不太可取。这两个函数有着不同的用途！<br>当你创建接收函数时，很明显你是在接受没有数据的交易中的以太币。<br>而当你创建回退函数时，通常是为了处理函数签名错误的情况。</p>
<h1 id="Your-Goal-Receive-Ether"><a href="#Your-Goal-Receive-Ether" class="headerlink" title="Your Goal: Receive Ether"></a>Your Goal: Receive Ether</h1><p>Add a function to the contract that will allow it to receive ether on a transaction without any calldata.</p>
<figure class="highlight delphi"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs delphi"><span class="hljs-comment">// SPDX-License-Identifier: MIT</span><br>pragma solidity ^<span class="hljs-number">0.8</span>.<span class="hljs-number">20</span>;<br><br>contract Contract <span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    address public owner;</span><br><span class="hljs-comment">    receive() external payable &#123;       </span><br><span class="hljs-comment">        &#125;</span><br>    <span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">()</span> <span class="hljs-comment">&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">        owner = msg.sender;</span></span><br><span class="hljs-comment"><span class="hljs-function">    &#125;</span></span><br><span class="hljs-function">&#125;</span><br></code></pre></div></td></tr></table></figure>

<h1 id="资金转账"><a href="#资金转账" class="headerlink" title="资金转账"></a>资金转账</h1><p>我们可以将任意常规函数设置为 payable（可接收以太币）。这样一来，我们就能区分转入智能合约的以太币所对应的不同用途。<br>举例来说，假设某合约中存储了两个地址，而我们希望能够分别向这两个地址进行转账：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">contract Contract &#123;<br>    address <span class="hljs-keyword">public</span> a;<br>    address <span class="hljs-keyword">public</span> b;<br>    <br>    constructor(address _a, address _b) &#123;<br>        a = _a;<br>        b = _b;<br>    &#125;<br><br>    <span class="hljs-function">function <span class="hljs-title">payA</span>() <span class="hljs-keyword">public</span> payable</span> &#123;<br>        (<span class="hljs-built_in">bool</span> s, ) = a.call&#123; <span class="hljs-keyword">value</span>: msg.<span class="hljs-keyword">value</span> &#125;(<span class="hljs-string">&quot;&quot;</span>);<br>        require(s);<br>    &#125;<br><br>    <span class="hljs-function">function <span class="hljs-title">payB</span>() <span class="hljs-keyword">public</span> payable</span> &#123;<br>        (<span class="hljs-built_in">bool</span> s, ) = b.call&#123; <span class="hljs-keyword">value</span>: msg.<span class="hljs-keyword">value</span> &#125;(<span class="hljs-string">&quot;&quot;</span>);<br>        require(s);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>我们有两个支付方法 payA 和 payB，它们会将以太币划转至对应的地址。该方法接收一个以Wei为单位的无符号整数（uint）金额，并将这笔资金从合约账户划转至目标地址。</p>
<h1 id="你的目标：划转小费"><a href="#你的目标：划转小费" class="headerlink" title="你的目标：划转小费"></a>你的目标：划转小费</h1><p>让我们创建一种向合约所有者支付小费的方式！<br>创建一个公共的（public）可接收以太币（payable）函数 tip，该函数需将其接收到的所有以太币划转至合约所有者地址。</p>
<p>答案：</p>
<figure class="highlight delphi"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs delphi"><span class="hljs-comment">// SPDX-License-Identifier: MIT</span><br>pragma solidity ^<span class="hljs-number">0.8</span>.<span class="hljs-number">20</span>;<br><br>contract Contract <span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    address public owner;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    // Event to log tips (optional, for tracking tips sent)</span><br><span class="hljs-comment">    event TipReceived(address sender, uint256 amount);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    // Receive function to accept Ether</span><br><span class="hljs-comment">    receive() external payable &#123;       </span><br><span class="hljs-comment">    &#125;</span><br><br>    <span class="hljs-comment">// Constructor to set the contract owner</span><br>    <span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">()</span> <span class="hljs-comment">&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">        owner = msg.sender;</span></span><br><span class="hljs-comment"><span class="hljs-function">    &#125;</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-comment">// Public payable function that sends received ether to the owner</span></span><br><span class="hljs-function">    <span class="hljs-title">function</span> <span class="hljs-title">tip</span><span class="hljs-params">()</span> <span class="hljs-title">public</span> <span class="hljs-title">payable</span> <span class="hljs-comment">&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">        // Emit the event for logging purposes (optional)</span></span><br><span class="hljs-comment"><span class="hljs-function">        emit TipReceived(msg.sender, msg.value);</span></span><br><span class="hljs-comment"><span class="hljs-function"></span></span><br><span class="hljs-comment"><span class="hljs-function">        // Transfer the received ether to the owner</span></span><br><span class="hljs-comment"><span class="hljs-function">        payable(owner).transfer(msg.value);</span></span><br><span class="hljs-comment"><span class="hljs-function">    &#125;</span></span><br><span class="hljs-function">&#125;</span><br></code></pre></div></td></tr></table></figure>

<h1 id="你的目标：慈善捐赠"><a href="#你的目标：慈善捐赠" class="headerlink" title="你的目标：慈善捐赠"></a>你的目标：慈善捐赠</h1><p>让我们把所有传递给receive函数的资金都捐赠给慈善机构。我们将分两步来做。</p>
<ol>
<li>首先，修改构造函数以接受一个新参数：慈善机构地址。</li>
<li>接下来，添加一个名为donate的新函数。当调用此函数时，将合约中所有剩余资金转移到慈善机构地址。</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: MIT</span><br>pragma solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.20</span>;<br><br>contract Contract &#123;<br>    address <span class="hljs-keyword">public</span> owner;  <span class="hljs-comment">// 合约所有者地址</span><br>    address <span class="hljs-keyword">public</span> charity; <span class="hljs-comment">// 慈善机构地址</span><br><br>    <span class="hljs-comment">// 用于记录捐赠事件的事件（可选，用于追踪）</span><br>    <span class="hljs-function"><span class="hljs-keyword">event</span> <span class="hljs-title">DonationSent</span>(<span class="hljs-params">address charity, uint256 amount</span>)</span>;<br><br>    <span class="hljs-comment">// 接收Ether的函数</span><br>    receive() external payable &#123;       <br>    &#125;<br><br>    <span class="hljs-comment">// 构造函数，接受慈善机构地址并初始化所有者和慈善机构地址</span><br>    constructor(address _charity) &#123;<br>        owner = msg.sender;  <span class="hljs-comment">// 设置合约的所有者为部署合约的地址</span><br>        charity = _charity;  <span class="hljs-comment">// 设置慈善机构地址</span><br>    &#125;<br><br>    <span class="hljs-comment">// 公共的可支付函数，将接收到的Ether发送给合约所有者</span><br>    <span class="hljs-function">function <span class="hljs-title">tip</span>() <span class="hljs-keyword">public</span> payable</span> &#123;<br>        <span class="hljs-comment">// 将接收到的Ether转账给所有者</span><br>        payable(owner).transfer(msg.<span class="hljs-keyword">value</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 捐赠函数，将合约中的所有剩余资金转账给慈善机构</span><br>    <span class="hljs-function">function <span class="hljs-title">donate</span>() <span class="hljs-keyword">public</span></span> &#123;<br>        uint256 balance = address(<span class="hljs-keyword">this</span>).balance;  <span class="hljs-comment">// 获取合约当前的余额</span><br>        require(balance &gt; <span class="hljs-number">0</span>, <span class="hljs-string">&quot;No funds to donate&quot;</span>);  <span class="hljs-comment">// 如果合约余额为0，则抛出异常</span><br><br>        <span class="hljs-comment">// 将余额转账给慈善机构</span><br>        payable(charity).transfer(balance);<br><br>        <span class="hljs-comment">// 触发捐赠事件，用于记录捐赠信息</span><br>        <span class="hljs-function">emit <span class="hljs-title">DonationSent</span>(<span class="hljs-params">charity, balance</span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="自毁的影响"><a href="#自毁的影响" class="headerlink" title="自毁的影响"></a>自毁的影响</h1><p>当你对合约账户调用selfdestruct（自毁）时，字节码会被清除。该合约将无法再对以太币转账做出响应。</p>
<p>如果你打算使用selfdestruct，你需要确保未来不会有人意外地向你的合约发送以太币。如果真的发生这种情况，可能没有办法收回那些以太币。未来发送到这个地址的资金可能会被永远锁定！</p>
<p>你可能会认为，一旦合约代码从某个地址中被清除，事情就结束了。然而，随着后来CREATE2操作码的引入，你现在能够将相同的代码重新部署到同一个地址。与依赖发送者地址和账户随机数的传统方法不同，CREATE2使用一个salt（盐值）和合约创建代码来确定合约地址。感兴趣吗？可以查看本教程了解更多内容。</p>
<p>你可以考虑设置存储变量，使任何人都无法调用函数，而不是让合约自毁。这样一来，如果未来有人尝试调用函数或发送以太币，交易就会被回滚！这可能是最安全的做法。</p>
<p>我们在讨论回滚时，会讲到如何实现这一点！</p>
<h1 id="解析这段代码的意思"><a href="#解析这段代码的意思" class="headerlink" title="解析这段代码的意思"></a>解析这段代码的意思</h1><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">contract Contract &#123;<br>    <span class="hljs-built_in">uint</span> _countdown = <span class="hljs-number">10</span>;<br><br>    constructor() payable &#123; &#125;<br><br>    <span class="hljs-function">function <span class="hljs-title">tick</span>() <span class="hljs-keyword">public</span></span> &#123;<br>        _countdown--;<br>        <span class="hljs-keyword">if</span>(_countdown == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> we must cast to address payable here</span><br>            <span class="hljs-comment">// some solidity methods protect </span><br>            <span class="hljs-comment">// against accidentally sending ether</span><br>            selfdestruct(payable(msg.sender));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>这段 Solidity 合约代码定义了一个名为 <code>Contract</code> 的智能合约，其主要功能是实现一个倒计时器，并在倒计时结束时销毁合约并将合约余额转移给合约调用者（销毁的对象是 <code>msg.sender</code>）。下面是对这段代码的详细解析：</p>
<h3 id="1-定义倒计时变量"><a href="#1-定义倒计时变量" class="headerlink" title="1. 定义倒计时变量"></a>1. <strong>定义倒计时变量</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">uint _countdown = 10;<br></code></pre></div></td></tr></table></figure>

<p>这行代码定义了一个名为 <code>_countdown</code> 的无符号整数（<code>uint</code>），初始值设定为 10。这个变量表示倒计时的初始时间，从 10 开始。</p>
<h3 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2. 构造函数"></a>2. <strong>构造函数</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">constructor() payable &#123; &#125;<br></code></pre></div></td></tr></table></figure>

<p>构造函数是合约创建时自动执行的函数。在此代码中，构造函数是 <code>payable</code>，这意味着该合约在部署时可以接收以太币（Ether）。但在这里，构造函数本身并没有执行任何操作，除非用户向合约发送以太币。</p>
<h3 id="3-tick-函数"><a href="#3-tick-函数" class="headerlink" title="3. tick() 函数"></a>3. <strong><code>tick()</code> 函数</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">function tick() public &#123;<br>    _countdown--; // 每次调用时倒计时减一<br>    if(_countdown == 0) &#123;<br>        // NOTE: we must cast to address payable here<br>        // some solidity methods protect <br>        // against accidentally sending ether<br>        selfdestruct(payable(msg.sender)); // 销毁合约并将余额发送给调用者<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><code>tick()</code> 函数是合约的主要功能所在，它是一个公共的函数，任何人都可以调用。以下是该函数的执行逻辑：</p>
<ul>
<li><p><strong><code>_countdown--;</code></strong>: 每次调用 <code>tick()</code> 函数时，倒计时变量 <code>_countdown</code> 会减少 1。即每调用一次 <code>tick()</code>，倒计时就会减少 1。</p>
</li>
<li><p><strong><code>if (_countdown == 0)</code></strong>: 当 <code>_countdown</code> 变量减到 0 时，进入条件判断。此时合约会执行以下操作：</p>
<ul>
<li><p><strong><code>selfdestruct(payable(msg.sender));</code></strong>:</p>
<ul>
<li><code>selfdestruct</code> 是 Solidity 中的内置函数，用来销毁当前合约，并将合约的剩余以太币余额转移到指定的地址。</li>
<li><code>msg.sender</code> 是调用 <code>tick()</code> 函数的地址。由于 <code>selfdestruct</code> 需要接受一个 <code>address payable</code> 类型的地址，因此需要将 <code>msg.sender</code> 强制转换为 <code>payable</code> 类型（通过 <code>payable(msg.sender)</code>）。</li>
<li>一旦合约销毁，合约内的所有以太币余额都会被发送给调用 <code>tick()</code> 函数的地址（即 <code>msg.sender</code>）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. <strong>总结</strong></h3><ul>
<li><p><strong>倒计时机制</strong>：每次调用 <code>tick()</code> 函数，<code>_countdown</code> 会减 1。当 <code>_countdown</code> 达到 0 时，合约会执行 <code>selfdestruct</code>，销毁合约，并将合约的余额转账给调用者。</p>
</li>
<li><p><strong><code>selfdestruct</code> 作用</strong>：<code>selfdestruct</code> 不仅销毁合约，还会将合约剩余的以太币转移到指定的地址。该地址是 <code>msg.sender</code>，即调用 <code>tick()</code> 函数的地址。</p>
</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a><strong>使用场景</strong></h3><ul>
<li>这个合约的设计可能用于某些特定的时间敏感操作，比如设定一个倒计时，直到倒计时结束后，合约会自动销毁并将剩余的以太币发送给触发此操作的用户。</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><ul>
<li><code>selfdestruct</code> 是一种危险操作，可能会导致合约的永久删除，因此它必须谨慎使用。</li>
</ul>
<h1 id="你的目标：自毁"><a href="#你的目标：自毁" class="headerlink" title="你的目标：自毁"></a>你的目标：自毁</h1><p>当调用donate函数时，触发合约中的自毁操作！</p>
<p>自毁操作会将所有剩余资金发送到传入的地址，因此或许可以用它来替代donate函数中现有的功能，将资金发送给慈善机构！只需确保像上面的示例那样，将地址转换为可支付地址即可。</p>
<p>答案：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><br><span class="hljs-comment">// SPDX-License-Identifier: MIT</span><br>pragma solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.20</span>;<br><br>contract Contract &#123;<br>    address <span class="hljs-keyword">public</span> owner;<br>    address <span class="hljs-keyword">public</span> charity;<br><br>    <span class="hljs-comment">// Event to log donations (optional, for tracking)</span><br>    <span class="hljs-function"><span class="hljs-keyword">event</span> <span class="hljs-title">DonationSent</span>(<span class="hljs-params">address charity, uint256 amount</span>)</span>;<br><br>    <span class="hljs-comment">// Receive function to accept Ether</span><br>    receive() external payable &#123;       <br>    &#125;<br><br>    <span class="hljs-comment">// Constructor to set the owner and charity address</span><br>    constructor(address _charity) &#123;<br>        owner = msg.sender;<br>        charity = _charity; <span class="hljs-comment">// Set the charity address from constructor argument</span><br>    &#125;<br><br>    <span class="hljs-comment">// Public payable function that sends received ether to the owner</span><br>    <span class="hljs-function">function <span class="hljs-title">tip</span>() <span class="hljs-keyword">public</span> payable</span> &#123;<br>        <span class="hljs-comment">// Send the received ether to the owner</span><br>        payable(owner).transfer(msg.<span class="hljs-keyword">value</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Function to donate all funds in the contract to the charity</span><br>    <span class="hljs-function">function <span class="hljs-title">donate</span>() <span class="hljs-keyword">public</span></span> &#123;<br>        uint256 balance = address(<span class="hljs-keyword">this</span>).balance; <span class="hljs-comment">// Get the contract&#x27;s balance</span><br>        require(balance &gt; <span class="hljs-number">0</span>, <span class="hljs-string">&quot;No funds to donate&quot;</span>);<br><br>        <span class="hljs-comment">// Transfer the balance to the charity</span><br>        payable(charity).transfer(balance);<br><br>        <span class="hljs-comment">// Emit event for tracking the donation</span><br>        <span class="hljs-function">emit <span class="hljs-title">DonationSent</span>(<span class="hljs-params">charity, balance</span>)</span>;<br>        selfdestruct(payable(msg.sender));<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure>

<h1 id="Your-Goal-Require-1-Ether"><a href="#Your-Goal-Require-1-Ether" class="headerlink" title="Your Goal: Require 1 Ether"></a>Your Goal: Require 1 Ether</h1><p>Add a payable constructor method that requires a 1 ether deposit.</p>
<p>If at least 1 ether is not sent to the constructor, revert the transaction.</p>
<figure class="highlight scss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scss"><span class="hljs-comment">// SPDX-License-Identifier: MIT</span><br>pragma solidity ^<span class="hljs-number">0.8</span><span class="hljs-selector-class">.20</span>;<br><br>contract Contract &#123;<br>    <span class="hljs-built_in">constructor</span>() payable &#123;<br>      <span class="hljs-built_in">require</span>(msg.value &gt;= <span class="hljs-number">1</span> ether);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="Your-Goal-Owner-Withdrawal"><a href="#Your-Goal-Owner-Withdrawal" class="headerlink" title="Your Goal: Owner Withdrawal"></a>Your Goal: Owner Withdrawal</h1><p>Create a public function withdraw that will withdraw all funds from the contract and send them to the deployer of the contract.<br>Require that only the deployer of the contract be allowed to call this function. For all other addresses, this function should revert.</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><br><span class="hljs-comment">// 指定许可证类型为MIT（开源许可）</span><br><span class="hljs-comment">// SPDX-License-Identifier: MIT</span><br><span class="hljs-comment">// 声明Solidity编译器版本，兼容0.8.20及以上但低于0.9.0的版本</span><br>pragma solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.20</span>;<br><br><span class="hljs-comment">// 定义合约名称为Contract</span><br>contract <span class="hljs-title class_">Contract</span> &#123;<br>    <span class="hljs-comment">// 声明一个公共的地址类型变量，用于存储合约部署者的地址</span><br>    address public deployer;<br><br>    <span class="hljs-comment">// 构造函数：合约部署时执行，且支持接收ETH（payable关键字）</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) payable &#123;<br>        <span class="hljs-comment">// 要求部署合约时必须转入至少1个ETH，否则部署失败</span><br>        <span class="hljs-built_in">require</span>(msg.<span class="hljs-property">value</span> &gt;= <span class="hljs-number">1</span> ether, <span class="hljs-string">&quot;部署时需转入至少1ETH&quot;</span>);<br>        <span class="hljs-comment">// 将合约部署者的地址（msg.sender）赋值给deployer变量永久存储</span><br>        <span class="hljs-comment">// 部署时msg.sender就是发起部署交易的账户（即合约部署者）</span><br>        deployer = msg.<span class="hljs-property">sender</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 定义公共的外部函数withdraw（外部函数只能由外部账户/合约调用，不能内部调用）</span><br>    <span class="hljs-comment">// 函数功能：提取合约中所有资金并发送给部署者，且仅允许部署者调用</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">withdraw</span>(<span class="hljs-params"></span>) external &#123;<br>        <span class="hljs-comment">// 核心权限校验：要求调用该函数的地址必须是合约部署者，否则回滚交易</span><br>        <span class="hljs-comment">// msg.sender此处是调用withdraw函数的地址，对比预先存储的deployer</span><br>        <span class="hljs-built_in">require</span>(msg.<span class="hljs-property">sender</span> == deployer, <span class="hljs-string">&quot;仅合约部署者可调用&quot;</span>);<br><br>        <span class="hljs-comment">// 1. 获取合约当前的所有余额（address(this)是合约自身地址，balance是其ETH余额）</span><br>        uint256 allFunds = <span class="hljs-title function_">address</span>(<span class="hljs-variable language_">this</span>).<span class="hljs-property">balance</span>;<br>        <span class="hljs-comment">// 2. 将合约地址转为可接收/发送ETH的payable类型（0.8+版本必须显式转换）</span><br>        address payable contractAddress = <span class="hljs-title function_">payable</span>(<span class="hljs-title function_">address</span>(<span class="hljs-variable language_">this</span>));<br>        <span class="hljs-comment">// 3. 将合约所有余额转账给部署者（deployer转为payable类型才能接收ETH）</span><br>        <span class="hljs-comment">// transfer是Solidity内置的转账函数，会自动处理ETH转账，失败则回滚</span><br>        <span class="hljs-title function_">payable</span>(deployer).<span class="hljs-title function_">transfer</span>(allFunds);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="Your-Goal-Require-Owner"><a href="#Your-Goal-Require-Owner" class="headerlink" title="Your Goal: Require Owner"></a>Your Goal: Require Owner</h1><p>You’ll notice that the onlyOwner modifier has been added to each of the configuration functions in this contract. Only problem is, it doesn’t currently do anything!</p>
<p>Update the onlyOwner modifier to require that only the owner address can call these functions without reverting.</p>
<figure class="highlight d"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: MIT</span><br><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.20</span>;<br><br>contract Contract &#123;<br>	<span class="hljs-built_in">uint</span> configA;<br>	<span class="hljs-built_in">uint</span> configB;<br>	<span class="hljs-built_in">uint</span> configC;<br>	address owner;<br><br>	constructor() &#123;<br>		owner = msg.sender;<br>	&#125;<br><br>	<span class="hljs-built_in">function</span> setA(<span class="hljs-built_in">uint</span> _configA) <span class="hljs-keyword">public</span> onlyOwner &#123;<br>		configA = _configA;<br>	&#125;<br><br>	<span class="hljs-built_in">function</span> setB(<span class="hljs-built_in">uint</span> _configB) <span class="hljs-keyword">public</span> onlyOwner &#123;<br>		configB = _configB;<br>	&#125;<br><br>	<span class="hljs-built_in">function</span> setC(<span class="hljs-built_in">uint</span> _configC) <span class="hljs-keyword">public</span> onlyOwner &#123;<br>		configC = _configC;<br>	&#125;<br><br>	modifier onlyOwner &#123;<br>		<span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> require only the owner access</span><br>        require(msg.sender == owner);<br>		_;<br>		<span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> run the rest of the function body</span><br><br>	&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="为什么solidity安全审计不用ai代替人类去审计？"><a href="#为什么solidity安全审计不用ai代替人类去审计？" class="headerlink" title="为什么solidity安全审计不用ai代替人类去审计？"></a>为什么solidity安全审计不用ai代替人类去审计？</h1><p>核心结论：当前AI无法替代人类做Solidity安全审计，根源在于AI缺乏复杂逻辑推理、跨合约上下文理解、新型漏洞预判与合规责任判定能力，而这些正是DeFi等高风险场景审计的核心，AI更适合做人工审计的前置扫描与辅助工具。</p>
<h3 id="一、AI的核心能力短板（导致无法独立审计）"><a href="#一、AI的核心能力短板（导致无法独立审计）" class="headerlink" title="一、AI的核心能力短板（导致无法独立审计）"></a>一、AI的核心能力短板（导致无法独立审计）</h3><ol>
<li><p><strong>复杂逻辑与跨合约推理不足</strong></p>
<ul>
<li>难以识别跨函数&#x2F;跨合约重入、代理合约委托调用上下文、MEV相关执行顺序漏洞等非局部性风险，GPT - 4等模型对这类关系的推理仍有明显缺陷。</li>
<li>面对大型合约（如MonoX、Popsicle协议）时，因上下文窗口限制，易丢失关键逻辑关联，无法完成完整链路审计。</li>
<li>无法理解DeFi协议的经济模型设计漏洞（如套利攻击、闪电贷攻击路径），这类漏洞往往不源于代码语法，而源于业务逻辑与激励机制的缺陷。</li>
</ul>
</li>
<li><p><strong>新型漏洞与未知攻击向量盲区</strong><br>AI依赖训练数据中的已知漏洞模式，对零日漏洞、组合式攻击（多合约联动触发）等无标注样本的威胁基本无法自主识别，而这类漏洞恰恰是黑客攻击的重灾区。人类审计可通过经验与创造性思维预判这类未知风险。</p>
</li>
<li><p><strong>可靠性与解释性缺陷</strong></p>
<ul>
<li>存在“幻觉”问题，可能生成不存在的漏洞报告或误判风险等级，对高敏感的区块链场景而言，错误结论的代价极高。</li>
<li>无法像人类一样提供可追责、可解释的审计结论，尤其在涉及合规、法律追责时，人工审计的签字与论证更具公信力。</li>
</ul>
</li>
<li><p><strong>治理与权限类漏洞识别乏力</strong><br>合约所有权、权限控制、升级机制等高层级设计缺陷，需要结合链上生态与业务规则综合判断，AI难以理解这类非代码层面的安全边界。</p>
</li>
</ol>
<h3 id="二、人类审计的不可替代性（核心价值所在）"><a href="#二、人类审计的不可替代性（核心价值所在）" class="headerlink" title="二、人类审计的不可替代性（核心价值所在）"></a>二、人类审计的不可替代性（核心价值所在）</h3><p>|能力维度|人类审计优势|AI局限|<br>|业务逻辑穿透|能结合DeFi、NFT等场景的行业规则，理解合约的商业目标与安全边界|仅能基于代码语法与标注漏洞做匹配，无行业常识与业务上下文理解|<br>|新型威胁预判|可通过漏洞机理推导、攻防演练，预判训练数据外的攻击路径|只能识别已知漏洞，对零样本新威胁无自主发现能力|<br>|风险优先级判定|能结合项目资金规模、用户基数、攻击成本，权衡漏洞修复优先级|按预设规则标注风险，无法做动态的商业风险 - 成本权衡|<br>|合规与责任背书|审计报告具备法律与行业认可度，可作为项目合规的重要凭证|AI结论无法律追责主体，无法用于正式审计背书|<br>|漏洞修复指导|能提供符合业务需求的修复方案，避免“为修漏洞而破坏功能”|多给出通用修复建议，无法适配定制化合约的特殊逻辑|</p>
<h3 id="三、人机协作才是当前最优解"><a href="#三、人机协作才是当前最优解" class="headerlink" title="三、人机协作才是当前最优解"></a>三、人机协作才是当前最优解</h3><ol>
<li><p>AI的定位：<strong>前置自动化扫描工具</strong></p>
<ul>
<li>快速检出整数溢出、tx.origin钓鱼、未检查外部调用等基础漏洞，降低人工审计的重复工作量。</li>
<li>集成到CI&#x2F;CD流程，实现代码提交时的实时安全检查，提前过滤低危问题。</li>
<li>辅助生成审计报告初稿，提升文档效率。</li>
</ul>
</li>
<li><p>人类的核心职责：<strong>深度审查与决策</strong></p>
<ul>
<li>聚焦复杂业务逻辑、经济模型、权限治理等高风险模块的审计。</li>
<li>验证AI检出结果，排除误报，评估漏洞实际影响。</li>
<li>制定修复方案、签署审计报告，承担最终安全责任。</li>
</ul>
</li>
</ol>
<h3 id="四、未来趋势"><a href="#四、未来趋势" class="headerlink" title="四、未来趋势"></a>四、未来趋势</h3><p>随着ZKML、符号执行与大模型结合，AI的审计能力会持续提升，但只要区块链合约涉及经济价值与合规责任，人类审计的决策与背书价值就不可替代。短期内，“AI前置扫描 + 人类深度审计 + 形式化验证补充”将是Solidity安全审计的标准范式。</p>
<p>需要我给你整理一份<strong>Solidity审计人机协作清单</strong>（AI前置扫描工具推荐、人工重点审查模块、漏洞分级判定标准），可直接用于项目审计落地吗？</p>
<h1 id="Solidity审计人机协作清单"><a href="#Solidity审计人机协作清单" class="headerlink" title="Solidity审计人机协作清单"></a>Solidity审计人机协作清单</h1><p>这份Solidity审计人机协作清单，按“AI前置扫描→人工深度审查→验证闭环→报告交付”的全流程设计，明确分工、可直接落地，兼顾效率与安全性。</p>
<h3 id="一、协作流程总览（核心逻辑：AI扫基础，人类抓核心）"><a href="#一、协作流程总览（核心逻辑：AI扫基础，人类抓核心）" class="headerlink" title="一、协作流程总览（核心逻辑：AI扫基础，人类抓核心）"></a>一、协作流程总览（核心逻辑：AI扫基础，人类抓核心）</h3><ol>
<li>AI前置自动化扫描（过滤低危、解放人力）</li>
<li>人工深度审查（聚焦高风险、复杂逻辑与业务边界）</li>
<li>交叉验证与漏洞复现（人机结果互证，排除误报&#x2F;漏报）</li>
<li>修复验证与报告输出（责任背书，形成可追溯闭环）</li>
</ol>
<h3 id="二、AI前置扫描模块（工具选型-检测范围-操作规范）"><a href="#二、AI前置扫描模块（工具选型-检测范围-操作规范）" class="headerlink" title="二、AI前置扫描模块（工具选型+检测范围+操作规范）"></a>二、AI前置扫描模块（工具选型+检测范围+操作规范）</h3><p>|工具类型|推荐工具|核心检测能力|使用规范|<br>|静态分析|Slither、Aderyn|整数溢出、重入、未初始化变量、权限控制基础漏洞|必扫SWC全库，输出漏洞清单与风险等级初判|<br>|符号执行|Mythril、MythX|路径可达性、边界条件触发漏洞|针对核心函数（转账、提现、权限变更）单独扫描|<br>|AI辅助审计|Solidity Sentinel、LightChaser|已知漏洞模式匹配、代码异味检测|结合静态结果交叉验证，标注AI疑似“幻觉”点|<br>|模糊测试|Foundry fuzz、Echidna|极端输入下的逻辑崩溃、数据溢出|覆盖90%+代码路径，设置合理gas上限|</p>
<p><strong>AI扫描执行步骤</strong></p>
<ol>
<li>环境准备：接入项目Hardhat&#x2F;Foundry工程，配置编译器版本（优先0.8.0+）。</li>
<li>批量扫描：执行Slither + Mythril联合扫描，生成JSON格式漏洞报告。</li>
<li>初步过滤：剔除重复告警，标记明确误报（如SafeMath已覆盖的溢出）。</li>
<li>结果标注：将可疑漏洞按模块归类，供人工快速定位。</li>
</ol>
<h3 id="三、人类深度审查模块（重点清单-审查方法-判定标准）"><a href="#三、人类深度审查模块（重点清单-审查方法-判定标准）" class="headerlink" title="三、人类深度审查模块（重点清单+审查方法+判定标准）"></a>三、人类深度审查模块（重点清单+审查方法+判定标准）</h3><p>人类聚焦AI无法覆盖的高风险维度，按优先级排序执行：</p>
<h4 id="1-核心业务逻辑与经济模型（最高优先级）"><a href="#1-核心业务逻辑与经济模型（最高优先级）" class="headerlink" title="1. 核心业务逻辑与经济模型（最高优先级）"></a>1. 核心业务逻辑与经济模型（最高优先级）</h4><ul>
<li>审查DeFi协议的激励机制、套利路径、闪电贷攻击面，验证数学模型正确性（如AMM滑点、LP收益计算）。</li>
<li>检查跨合约交互逻辑（如代理合约委托调用、ERC - 4626资金流），确认遵循Checks - Effects - Interactions范式。</li>
<li>评估经济参数（如手续费、清算阈值）是否存在设计缺陷，可被恶意利用。</li>
</ul>
<h4 id="2-权限与治理漏洞（高层级设计）"><a href="#2-权限与治理漏洞（高层级设计）" class="headerlink" title="2. 权限与治理漏洞（高层级设计）"></a>2. 权限与治理漏洞（高层级设计）</h4><ul>
<li>检查合约所有权、升级权限、 pausable 控制等，避免单点故障。</li>
<li>验证角色权限隔离（如minter、admin、user），杜绝越权操作路径。</li>
<li>评估升级机制安全性（如Timelock、多签校验），防止恶意合约替换。</li>
</ul>
<h4 id="3-新型-组合式漏洞预判（人类核心价值）"><a href="#3-新型-组合式漏洞预判（人类核心价值）" class="headerlink" title="3. 新型&#x2F;组合式漏洞预判（人类核心价值）"></a>3. 新型&#x2F;组合式漏洞预判（人类核心价值）</h4><ul>
<li>基于行业漏洞库与实战经验，预判零日漏洞、多合约联动攻击路径。</li>
<li>分析MEV相关风险（如交易排序、三明治攻击），评估合约抗MEV能力。</li>
<li>审查链上生态依赖（如Oracle数据准确性、外部合约安全性）。</li>
</ul>
<h4 id="4-AI结果复核与漏洞定级"><a href="#4-AI结果复核与漏洞定级" class="headerlink" title="4. AI结果复核与漏洞定级"></a>4. AI结果复核与漏洞定级</h4><p>|漏洞类型|风险等级判定标准|修复优先级|<br>|高危（如重入、权限失控）|可直接导致资金损失，攻击成本低|立即修复，暂停上线|<br>|中危（如逻辑漏洞、数据泄露）|需特定条件触发，影响范围有限|上线前修复|<br>|低危（如代码冗余、gas优化）|不影响安全，仅影响效率|可延后修复|</p>
<p><strong>人工审查操作规范</strong></p>
<ol>
<li>对照AI漏洞清单，逐点复现并验证（编写PoC合约测试高危漏洞）。</li>
<li>绘制合约交互流程图，标记关键安全边界（如资金转入&#x2F;转出点）。</li>
<li>针对治理模块，模拟攻击场景（如权限被盗后如何止损）。</li>
<li>记录审查结论，提供可解释的漏洞成因与修复方案。</li>
</ol>
<h3 id="四、交叉验证与修复闭环（确保审计有效性）"><a href="#四、交叉验证与修复闭环（确保审计有效性）" class="headerlink" title="四、交叉验证与修复闭环（确保审计有效性）"></a>四、交叉验证与修复闭环（确保审计有效性）</h3><ol>
<li>漏洞复现：对所有高危&#x2F;中危漏洞，人工编写攻击合约验证可利用性。</li>
<li>修复验证：开发者修复后，AI重新扫描+人工二次审查，确认漏洞彻底消除。</li>
<li>形式化验证（可选，高资金项目必做）：使用Certora Prover验证核心不变量（如总供应量守恒、权限隔离）。</li>
<li>链上模拟：通过Tenderly等工具模拟主网部署，测试极端条件下的合约行为。</li>
</ol>
<h3 id="五、报告交付与责任背书（合规-可追溯）"><a href="#五、报告交付与责任背书（合规-可追溯）" class="headerlink" title="五、报告交付与责任背书（合规+可追溯）"></a>五、报告交付与责任背书（合规+可追溯）</h3><ol>
<li>报告结构：包含AI扫描摘要、人工审查结论、漏洞详情、修复建议、风险声明。</li>
<li>责任标注：明确人工审计师签字，区分AI与人工发现的漏洞，避免法律风险。</li>
<li>交付物：提供PDF报告+漏洞跟踪表（记录修复状态与验证结果）。</li>
</ol>
<h3 id="六、协作效率提升Tips"><a href="#六、协作效率提升Tips" class="headerlink" title="六、协作效率提升Tips"></a>六、协作效率提升Tips</h3><ol>
<li>集成CI&#x2F;CD：将AI扫描嵌入代码提交流程，提前拦截基础漏洞。</li>
<li>建立知识库：沉淀团队审计经验，用于AI模型微调与人工审查参考。</li>
<li>定期复盘：分析历史漏洞，优化AI扫描规则与人工审查重点。</li>
</ol>
<p>需要我把这份清单转化为可直接复制的<strong>Foundry&#x2F;Hardhat自动化脚本</strong>，包含Slither+Mythril联合扫描命令与漏洞过滤规则吗？</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Web3/">Web3</a>
                    
                  </div>
                
              </div>
              
                
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/12/11/32228.html">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">一文读懂香港 VASP 合约安全：强制审计、权限管控与合规嵌入的实操指南</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/12/11/30587.html">
                        <span class="hidden-mobile">university.alchemy2</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


            

                
                  <a id="scroll-top-button" href="#" role="button">
                    <i class="iconfont icon-arrowup" aria-hidden="true"></i>
                  </a>
                  

                    

                          
      </main>

      <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://whale3070.github.io/" target="_blank" rel="nofollow noopener"><span>Whale3070</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->




  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>





  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<link href="/pagefind/pagefind-ui.css" rel="stylesheet">
  <script src="/pagefind/pagefind-ui.js"></script>
  <style>
    /* 搜索框配色适配 */
    #search { margin-top: 2rem; }
    [data-user-color-scheme='dark'] .pagefind-ui {
      --pagefind-ui-primary: #eeeeee;
      --pagefind-ui-text: #eeeeee;
      --pagefind-ui-background: #151515;
      --pagefind-ui-border: #333;
    }
  </style>
    </body>

  </html>