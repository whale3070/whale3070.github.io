

  <!DOCTYPE html>
  <html lang="zh-CN" data-default-color-scheme=&#34;dark&#34; >
  <style>
    .text1
    {
    text-shadow: 0px 0px 2px #f2f3f2;
    }
    </style>

  <script>
    // 强制内网 IP 识别为安全上下文
    if (window.location.hostname !== 'localhost' && window.location.protocol === 'http:') {
        // 尝试手动映射 crypto 属性
        if (!window.crypto.subtle && window.crypto.webkitSubtle) {
            window.crypto.subtle = window.crypto.webkitSubtle;
        }
    }
    
    // 终极补丁：如果还是没有 subtle，则创建一个占位符避免报错
    // 提示：这通常能解决加载报错，但如果插件强依赖原生加密，建议执行下面的“降级”预判
    if (!window.isSecureContext) {
        console.warn('当前环境非安全上下文，正在尝试兼容内网加密解密...');
    }
</script>


<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/null">
  <link rel="icon" type="image/png" href="/null">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>university.alchemy2 - whale3070&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.4.0/styles/github-gist.min.css" />
    
  

  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"192.168.126.129","root":"/","version":"1.8.7","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":false,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 7.3.0"></head>


    <body>
      <header style="height: 70vh;">
        <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>InfoSec learning</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/search/">
                <i class="iconfont icon-search"></i>
                搜索
              </a>
            </li>
          
        
        
        
          
        
      </ul>
    </div>
  </div>
</nav>

          <div class="banner" id="banner" false
            style="background: url('/img/default.png') no-repeat center center;
              background-size: cover;">
              <div class="full-bg-img">
                <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
                  <div class="page-header text-center fade-in-up">
                    <span class="h2 text1" id="subtitle" title="university.alchemy2">
                      
                        university.alchemy2
                      
                    </span>
        
                    
                      <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2025-12-11 06:08" pubdate>
        2025年12月11日 早上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6.2k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      72
       分钟
    </span>
  

  
  
</div>

                    
                  </div>
                    
                  </div>
                  
                </div>
              </div>
          </div>
      </header>

      <main>
        
          

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" data-pagefind-body>
            <!-- SEO header -->
            <h1 style="display: none">university.alchemy2</h1>
            
            <div class="markdown-body">
              <p>学习资料： <a target="_blank" rel="noopener" href="https://university.alchemy.com/course/solidity/md/64f0ba677a31d90002d48887">https://university.alchemy.com/course/solidity/md/64f0ba677a31d90002d48887</a></p>
<h1 id="EOA-contract是什么意思"><a href="#EOA-contract是什么意思" class="headerlink" title="EOA -&gt; contract是什么意思"></a>EOA -&gt; contract是什么意思</h1><p>“EOA -&gt; contract”是区块链（尤其以太坊生态）中核心的交互关系表述，直译是“<strong>外部账户向智能合约账户发起交互</strong>”，是Web3开发、交易执行中最常见的操作模式，我们先拆解核心概念，再讲具体场景和特点：</p>
<h3 id="一、核心概念拆解"><a href="#一、核心概念拆解" class="headerlink" title="一、核心概念拆解"></a>一、核心概念拆解</h3><p>先明确“EOA”和“contract”的本质区别，才能理解这个交互的核心逻辑：</p>
<p>| 类型       | 全称                  | 中文名称       | 核心特征                                                                 |<br>| EOA        | Externally Owned Account | 外部拥有账户   | 1. 由私钥控制（对应普通人的“钱包地址”，如MetaMask地址）；<br>2. 无代码逻辑，仅能发起交易&#x2F;签名；<br>3. 可存储ETH&#x2F;代币，是所有交易的“发起源头”。 |<br>| contract   | Smart Contract Account | 智能合约账户   | 1. 由部署在链上的代码控制（无私钥）；<br>2. 有预设的业务逻辑（如转账、NFT铸造、DeFi兑换）；<br>3. 需接收外部触发（如EOA调用）才会执行代码。 |</p>
<p>“-&gt;”代表“发起调用&#x2F;触发交互”，即<strong>用户通过自己的EOA钱包，向部署在链上的智能合约地址发送交易，触发合约执行预设逻辑</strong>。</p>
<h3 id="二、典型应用场景（举例说明）"><a href="#二、典型应用场景（举例说明）" class="headerlink" title="二、典型应用场景（举例说明）"></a>二、典型应用场景（举例说明）</h3><p>所有你在区块链上的操作，本质几乎都是EOA对contract的交互，比如：</p>
<ol>
<li><strong>NFT铸造</strong>：你用MetaMask（EOA）向NFT合约地址发送交易，调用合约中的<code>mint()</code>函数，合约执行铸造逻辑，将NFT转到你的EOA地址。</li>
<li><strong>DeFi兑换（如Uniswap）</strong>：你用EOA向Uniswap合约发起交易，调用<code>swap()</code>函数，合约扣减你的USDT，向你发放ETH（核心逻辑由合约代码执行）。</li>
<li><strong>代币转账（ERC20）</strong>：若你给他人转USDT，本质是你的EOA调用USDT合约的<code>transfer()</code>函数，合约更新你和接收方的余额（而非直接“转币”）。</li>
<li><strong>投票&#x2F;治理</strong>：你用EOA调用DAO治理合约的<code>vote()</code>函数，合约记录你的投票信息，按规则统计结果。</li>
</ol>
<h3 id="三、EOA-contract-交互的关键特点"><a href="#三、EOA-contract-交互的关键特点" class="headerlink" title="三、EOA -&gt; contract 交互的关键特点"></a>三、EOA -&gt; contract 交互的关键特点</h3><ol>
<li><strong>必须消耗Gas</strong>：EOA发起的每一笔交互交易，都需要支付Gas（以太坊的计算燃料），用于激励节点执行合约代码；Gas由发起交互的EOA承担（合约本身无法主动支付Gas）。</li>
<li><strong>交易不可逆</strong>：一旦EOA发送交易并上链确认，合约执行的结果（如转账、铸造）无法撤回（除非合约内置“撤回&#x2F;回滚”逻辑）。</li>
<li><strong>触发逻辑依赖合约代码</strong>：交互的结果完全由合约代码决定——如果合约有漏洞（如重入攻击、权限错误），EOA的交互可能导致资产损失。</li>
<li><strong>交互需指定“函数+参数”</strong>：EOA发起交易时，必须明确调用合约的哪个函数（如<code>mint()</code>）、传入什么参数（如铸造数量），否则合约无法执行（这也是之前提到的“message call breakdown”常见原因）。</li>
</ol>
<h3 id="四、和“contract-contract”的区别（补充理解）"><a href="#四、和“contract-contract”的区别（补充理解）" class="headerlink" title="四、和“contract -&gt; contract”的区别（补充理解）"></a>四、和“contract -&gt; contract”的区别（补充理解）</h3><p>对比另一种常见交互，能更清晰定位EOA-&gt;contract的核心：</p>
<ul>
<li>EOA-&gt;contract：是“源头交互”，所有链上操作的起点（只有EOA能主动发起交易，合约无法主动发起交易）；</li>
<li>contract-&gt;contract：是“合约间调用”，比如Uniswap合约调用USDT合约完成转账，但其触发源头依然是某个EOA的初始调用。</li>
</ul>
<p>简单总结：<strong>EOA -&gt; contract 是区块链世界的“用户操作智能合约”的本质，是普通人与链上应用交互的唯一方式</strong>。比如你在钱包里点击“铸造NFT”，背后就是钱包（EOA）向NFT合约发起了一笔调用交易。</p>
<h1 id="message-call-breakdown是什么意思"><a href="#message-call-breakdown是什么意思" class="headerlink" title="message call breakdown是什么意思"></a>message call breakdown是什么意思</h1><p>“message call breakdown” 是一个常见于 <strong>编程开发（尤其区块链、分布式系统、API交互场景）</strong> 的技术术语，核心含义是“<strong>消息调用失败&#x2F;消息调用崩溃</strong>”，指在程序或系统间通过“消息”传递指令、数据时，调用过程未正常完成，出现中断、报错或功能失效的情况。</p>
<h3 id="1-核心拆解：术语含义与适用场景"><a href="#1-核心拆解：术语含义与适用场景" class="headerlink" title="1. 核心拆解：术语含义与适用场景"></a>1. 核心拆解：术语含义与适用场景</h3><p>要理解它，先拆分三个关键部分，再结合具体场景看实际表现：</p>
<ul>
<li><strong>message（消息）</strong>：不是日常聊天的“消息”，而是程序间的“数据&#x2F;指令载体”，比如区块链中合约间传递的函数参数、API接口请求的数据包、分布式系统中节点间的通信内容。</li>
<li><strong>call（调用）</strong>：程序主动发起的“请求行为”，比如区块链里「合约A调用合约B的某个函数」、APP调用后端服务器的API接口。</li>
<li><strong>breakdown（崩溃&#x2F;失败）</strong>：调用过程未达成预期目标，可能是“直接中断”“返回错误码”“超时无响应”等。</li>
</ul>
<h3 id="2-典型应用场景：哪里会遇到这个问题？"><a href="#2-典型应用场景：哪里会遇到这个问题？" class="headerlink" title="2. 典型应用场景：哪里会遇到这个问题？"></a>2. 典型应用场景：哪里会遇到这个问题？</h3><p>最常见于 <strong>区块链开发（如你关注的Solidity智能合约）</strong> 和 <strong>API&#x2F;分布式系统交互</strong>，不同场景下的“失败原因”和“表现”有差异：</p>
<p>| 应用场景 | 具体表现 | 常见失败原因 |<br>| <strong>Solidity智能合约（Web3）</strong> | 合约间调用<code>call()</code>&#x2F;<code>delegatecall()</code>时，交易回滚、返回<code>false</code>、无法触发目标函数，甚至消耗Gas后无结果 | 1. 目标合约地址错误（无效地址）；<br>2. 调用函数不存在&#x2F;参数类型不匹配；<br>3. 调用者Gas不足（区块链特有的“燃料”耗尽）；<br>4. 目标合约内有<code>revert()</code>（主动回滚）或异常逻辑（如数组越界） |<br>| <strong>API接口调用（如后端开发）</strong> | 前端&#x2F;服务端发起API请求后，收到<code>5xx</code>错误（服务器端错误）、<code>404</code>（接口不存在）、超时（超过预设等待时间），或返回数据格式错误 | 1. 接口URL错误&#x2F;服务未启动；<br>2. 请求参数缺失&#x2F;格式错误（如JSON语法错）；<br>3. 服务器过载&#x2F;网络中断（跨服务通信时）；<br>4. 权限不足（如未传Token） |<br>| <strong>分布式系统（如微服务）</strong> | 服务A向服务B发送消息（如通过Kafka&#x2F;RabbitMQ）时，消息发送失败、丢失，或服务B接收后处理报错 | 1. 消息队列服务宕机；<br>2. 服务间网络分区（网络断开）；<br>3. 接收方服务崩溃，无法消费消息；<br>4. 消息格式不兼容（如序列化&#x2F;反序列化失败） |</p>
<h3 id="3-如何排查“message-call-breakdown”？"><a href="#3-如何排查“message-call-breakdown”？" class="headerlink" title="3. 如何排查“message call breakdown”？"></a>3. 如何排查“message call breakdown”？</h3><p>在开发中遇到这个问题，通常按以下步骤定位原因（以Solidity和API为例）：</p>
<ol>
<li><strong>查看日志（Log）</strong>：  <ul>
<li>Solidity：通过区块链浏览器（如Etherscan）查看交易详情，找到“Reverted Reason”（回滚原因），或在合约中加<code>event</code>日志记录调用过程；  </li>
<li>API：查看服务端日志（如Nginx&#x2F;Node.js日志），确认是“请求没到服务器”还是“服务器处理时出错”。</li>
</ul>
</li>
<li><strong>验证基础信息</strong>：  <ul>
<li>检查调用地址&#x2F;URL是否正确、参数是否匹配（类型&#x2F;数量&#x2F;格式）、权限是否有效（如合约调用的Gas设置、API的Token）。</li>
</ul>
</li>
<li><strong>复现与隔离</strong>：  <ul>
<li>用最小化案例复现（如Solidity中先在测试网调用、API用Postman单独测试），排除其他代码干扰，定位是“调用方问题”还是“接收方问题”。</li>
</ul>
</li>
</ol>
<p>比如你在做Solidity审计时，若遇到“某合约调用外部合约时频繁回滚”，就可以描述为“存在message call breakdown风险”，并进一步分析是Gas设置不足、函数参数错误，还是目标合约有异常回滚逻辑——这也是审计中需要重点排查的“外部调用风险”之一。</p>
<h1 id="msg-sender-这里面是msg是什么的缩写"><a href="#msg-sender-这里面是msg是什么的缩写" class="headerlink" title="msg.sender 这里面是msg是什么的缩写"></a>msg.sender 这里面是msg是什么的缩写</h1><p>在以太坊Solidity智能合约中，<code>msg</code> 是 <strong>message</strong> 的缩写，直译就是“消息&#x2F;调用消息”，代表“当前触发合约执行的调用消息（交易）上下文”——可以把它理解为一个“内置全局对象”，封装了本次合约调用（EOA→contract 或 contract→contract）的核心元数据，而 <code>msg.sender</code> 是这个对象中最常用的属性之一。</p>
<h3 id="一、先理清：msg-是什么？"><a href="#一、先理清：msg-是什么？" class="headerlink" title="一、先理清：msg 是什么？"></a>一、先理清：<code>msg</code> 是什么？</h3><p><code>msg</code> 不是普通变量，是 Solidity 内置的<strong>全局上下文对象</strong>，仅在合约函数执行期间有效，每次调用合约时，以太坊虚拟机（EVM）都会自动填充这个对象的所有属性，用于让合约知道“谁发起的调用”“调用带了多少ETH”“调用的参数是什么”等关键信息。</p>
<h3 id="二、msg-的核心属性（补充理解）"><a href="#二、msg-的核心属性（补充理解）" class="headerlink" title="二、msg 的核心属性（补充理解）"></a>二、<code>msg</code> 的核心属性（补充理解）</h3><p>除了 <code>msg.sender</code>，<code>msg</code> 还有这些常用属性，能帮你完整理解“调用消息”的上下文：</p>
<p>| 属性          | 含义                                                                 |<br>| <code>msg.sender</code>  | 本次调用的发起者地址（EOA 或合约地址），是调用链的“直接发起方”       |<br>| <code>msg.value</code>   | 本次调用中附带的 ETH 数量（以 wei 为单位，比如转 1 ETH 就是 1e18 wei） |<br>| <code>msg.data</code>    | 本次调用的原始数据（包含要调用的函数签名+参数，即“calldata”）         |<br>| <code>msg.gas</code>     | 本次调用剩余的 Gas 数量（Solidity 0.8+ 已废弃，改用 <code>gasleft()</code>）    |</p>
<h3 id="三、msg-sender-的关键场景（结合-EOA→contract）"><a href="#三、msg-sender-的关键场景（结合-EOA→contract）" class="headerlink" title="三、msg.sender 的关键场景（结合 EOA→contract）"></a>三、<code>msg.sender</code> 的关键场景（结合 EOA→contract）</h3><ol>
<li><p><strong>基础场景（EOA 直接调用合约）</strong>：<br>你用 MetaMask（EOA 地址：0x123）调用 NFT 合约的 <code>mint()</code> 函数，此时合约内的 <code>msg.sender</code> 就是 0x123——合约通过这个值确认“谁在铸造 NFT”，并将 NFT 归属到该地址。</p>
</li>
<li><p><strong>嵌套场景（contract→contract）</strong>：<br>若你用 EOA（0x123）调用合约 A，合约 A 又调用合约 B，那么：  </p>
<ul>
<li>合约 A 内的 <code>msg.sender</code> &#x3D; 0x123（你的EOA）；  </li>
<li>合约 B 内的 <code>msg.sender</code> &#x3D; 合约 A 的地址（而非你的EOA）。<br>这是最容易踩坑的点：<code>msg.sender</code> 是“直接调用方”，而非“最终发起方”，若要获取最终的 EOA，需额外处理（如通过 <code>tx.origin</code>，但 <code>tx.origin</code> 有安全风险）。</li>
</ul>
</li>
</ol>
<h3 id="四、常见误区"><a href="#四、常见误区" class="headerlink" title="四、常见误区"></a>四、常见误区</h3><ul>
<li>误区1：<code>msg</code> 是“消息”，所以只对应“聊天信息”→ 错！Solidity 中的 <code>msg</code> 是“调用交易的上下文消息”，和日常聊天无关；</li>
<li>误区2：<code>msg.sender</code> 永远是 EOA→ 错！若合约调用合约，<code>msg.sender</code> 会是调用方合约的地址；</li>
<li>误区3：<code>msg</code> 可以被手动修改→ 错！<code>msg</code> 由 EVM 自动填充，合约代码无法修改 <code>msg</code> 的任何属性，保证了调用方身份的不可伪造。</li>
</ul>
<p>简单总结：<code>msg</code> &#x3D; 本次调用的“消息上下文”，<code>msg.sender</code> &#x3D; 本次调用的“直接发起者地址”，是 Solidity 中验证身份、控制权限的核心工具（比如只有 <code>msg.sender</code> 是合约所有者时，才能执行 <code>withdraw()</code> 提现函数）。</p>
<h1 id="payable是不是必须要和external关键词一起使用。除了external还有public-internal等等"><a href="#payable是不是必须要和external关键词一起使用。除了external还有public-internal等等" class="headerlink" title="payable是不是必须要和external关键词一起使用。除了external还有public,internal等等"></a>payable是不是必须要和external关键词一起使用。除了external还有public,internal等等</h1><p>在Solidity中，<code>payable</code> <strong>并非必须和<code>external</code>一起使用</strong> ——<code>payable</code>是修饰函数&#x2F;地址的“支付属性”（允许接收ETH），而<code>external</code>&#x2F;<code>public</code>&#x2F;<code>internal</code>&#x2F;<code>private</code>是修饰函数的“可见性”，二者是完全独立的维度，可自由组合（仅需遵循可见性的基础规则）。</p>
<p>下面先理清核心逻辑，再拆解不同可见性与<code>payable</code>的组合场景、规则和注意事项：</p>
<h3 id="一、核心前提：两个维度的本质区别"><a href="#一、核心前提：两个维度的本质区别" class="headerlink" title="一、核心前提：两个维度的本质区别"></a>一、核心前提：两个维度的本质区别</h3><p>| 维度         | 作用                                                                 | 关键词                |<br>| 支付属性     | 标记“是否允许接收ETH”：<br>- <code>payable</code>：允许，调用时可附带<code>msg.value</code>；<br>- 无<code>payable</code>：禁止，带ETH调用会直接回滚 | <code>payable</code>（可选）     |<br>| 函数可见性   | 标记“函数能被谁调用”：<br>- <code>external</code>：仅外部（EOA&#x2F;其他合约）调用；<br>- <code>public</code>：内部&#x2F;外部都可调用；<br>- <code>internal</code>：仅当前合约&#x2F;子合约内部调用；<br>- <code>private</code>：仅当前合约内部调用 | <code>external</code>&#x2F;<code>public</code>&#x2F;<code>internal</code>&#x2F;<code>private</code>（必选） |</p>
<p>简言之：<code>payable</code>决定“能不能收钱”，可见性决定“谁能调用”，二者互不依赖。</p>
<h3 id="二、不同可见性-payable-的组合场景（附示例）"><a href="#二、不同可见性-payable-的组合场景（附示例）" class="headerlink" title="二、不同可见性 + payable 的组合场景（附示例）"></a>二、不同可见性 + payable 的组合场景（附示例）</h3><h4 id="1-external-payable（最常见，但非必须）"><a href="#1-external-payable（最常见，但非必须）" class="headerlink" title="1. external + payable（最常见，但非必须）"></a>1. external + payable（最常见，但非必须）</h4><ul>
<li>适用场景：仅需外部（EOA&#x2F;其他合约）调用且需要接收ETH的函数（如NFT铸造、DeFi充值、提现）。</li>
<li>特点：<code>external</code>函数的参数直接读取<code>calldata</code>（更省Gas），适合高频外部调用的收钱函数。</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">// NFT铸造函数：仅外部调用，且需要支付ETH（铸造费）<br>function mint() external payable &#123;<br>    require(msg.value &gt;= 0.01 ether, &quot;Insufficient ETH&quot;);<br>    // 铸造逻辑...<br>&#125;<br></code></pre></div></td></tr></table></figure></li>
</ul>
<h4 id="2-public-payable（常用）"><a href="#2-public-payable（常用）" class="headerlink" title="2. public + payable（常用）"></a>2. public + payable（常用）</h4><ul>
<li>适用场景：既需要外部调用，也需要合约内部（或子合约）调用，且需要接收ETH的函数。</li>
<li>注意：<code>public</code>函数参数会加载到<code>memory</code>（Gas略高），但支持内部调用。</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">contract Wallet &#123;<br>    // 充值函数：外部（用户）可调用，合约内部也可调用（如其他函数触发充值）<br>    function deposit() public payable &#123;<br>        // 记录余额...<br>    &#125;<br><br>    // 内部调用deposit的示例<br>    function autoDeposit() external &#123;<br>        deposit(); // 内部调用public+payable函数（可附带msg.value，也可不带）<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li>
</ul>
<h4 id="3-internal-payable（少见，但合法）"><a href="#3-internal-payable（少见，但合法）" class="headerlink" title="3. internal + payable（少见，但合法）"></a>3. internal + payable（少见，但合法）</h4><ul>
<li>适用场景：仅允许当前合约&#x2F;子合约内部调用，且需要接收ETH的函数（比如内部资金划转逻辑）。</li>
<li>关键：<code>internal</code>函数无法被外部直接调用，只能由合约内部触发，调用时可附带<code>msg.value</code>。</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">contract Parent &#123;<br>    // 内部转账函数：仅子合约/自身可调用，需接收ETH<br>    function transferInternal(address to) internal payable &#123;<br>        (bool success, ) = to.call&#123;value: msg.value&#125;(&quot;&quot;);<br>        require(success, &quot;Transfer failed&quot;);<br>    &#125;<br>&#125;<br><br>contract Child is Parent &#123;<br>    // 外部函数触发内部payable函数<br>    function transfer(address to) external payable &#123;<br>        transferInternal(to); // 内部调用，将外部传入的msg.value转发<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li>
</ul>
<h4 id="4-private-payable（极少见，合法）"><a href="#4-private-payable（极少见，合法）" class="headerlink" title="4. private + payable（极少见，合法）"></a>4. private + payable（极少见，合法）</h4><ul>
<li>适用场景：仅当前合约内部调用，且需要接收ETH的私有函数（比如合约内部核心资金操作）。</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">contract Vault &#123;<br>    // 私有提现函数：仅当前合约内部调用，需接收ETH（比如归集资金）<br>    function _withdrawToOwner() private payable &#123;<br>        (bool success, ) = owner.call&#123;value: msg.value&#125;(&quot;&quot;);<br>        require(success, &quot;Withdraw failed&quot;);<br>    &#125;<br><br>    // 外部函数触发私有payable函数<br>    function withdrawAll() external onlyOwner &#123;<br>        _withdrawToOwner&#123;value: address(this).balance&#125;(); // 附带合约全部余额调用<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li>
</ul>
<h3 id="三、关键规则与误区澄清"><a href="#三、关键规则与误区澄清" class="headerlink" title="三、关键规则与误区澄清"></a>三、关键规则与误区澄清</h3><h4 id="1-绝对禁止的组合？"><a href="#1-绝对禁止的组合？" class="headerlink" title="1. 绝对禁止的组合？"></a>1. 绝对禁止的组合？</h4><p>没有！所有可见性关键词都能和<code>payable</code>组合，只要符合可见性的基础规则（比如<code>private</code>函数不能被外部调用）。</p>
<h4 id="2-常见误区"><a href="#2-常见误区" class="headerlink" title="2. 常见误区"></a>2. 常见误区</h4><ul>
<li>误区1：<code>payable</code>只能和<code>external</code>用→ 错！<code>public</code>+<code>payable</code>是更通用的选择（支持内&#x2F;外部调用）。</li>
<li>误区2：<code>internal</code>&#x2F;<code>private</code>函数加<code>payable</code>没用→ 不一定！若内部调用时需要传递<code>msg.value</code>（比如内部资金转发），就需要加<code>payable</code>；若内部函数不需要接收ETH，加了也不影响（只是没必要）。</li>
<li>误区3：不带<code>payable</code>的函数也能收ETH→ 错！任何函数&#x2F;地址，只要没有<code>payable</code>修饰，接收ETH都会触发回滚（除非是合约的<code>receive()</code>&#x2F;<code>fallback()</code>函数，这两个是特殊的<code>payable</code>函数）。</li>
</ul>
<h4 id="3-特殊补充：receive-fallback-函数"><a href="#3-特殊补充：receive-fallback-函数" class="headerlink" title="3. 特殊补充：receive()&#x2F;fallback() 函数"></a>3. 特殊补充：receive()&#x2F;fallback() 函数</h4><p>这两个是合约的“默认收款函数”，<strong>必须是<code>external + payable</code></strong>（Solidity强制规则），无法用其他可见性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">// 接收纯ETH转账（无数据）的函数：必须external+payable<br>receive() external payable &#123;&#125;<br><br>// 接收带数据的ETH转账：必须external+payable<br>fallback() external payable &#123;&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="四、选型建议（实战参考）"><a href="#四、选型建议（实战参考）" class="headerlink" title="四、选型建议（实战参考）"></a>四、选型建议（实战参考）</h3><p>| 场景                          | 推荐组合               | 原因                     |<br>| 仅外部调用的收钱函数（如铸造） | external + payable     | 省Gas，限制调用范围      |<br>| 内&#x2F;外部都需调用的收钱函数     | public + payable       | 灵活，支持内部调用       |<br>| 内部资金划转逻辑              | internal + payable     | 仅内部可用，安全         |<br>| 合约私有资金操作              | private + payable      | 仅当前合约可用，最安全   |<br>| 纯ETH转账接收                 | receive() external payable | 符合Solidity强制规则 |</p>
<p>总结：<code>payable</code>和<code>external</code>无绑定关系，核心是根据“是否需要收ETH”（选payable）和“谁能调用函数”（选可见性）来组合，实战中<code>external+payable</code>和<code>public+payable</code>是最常用的两种组合。</p>
<h1 id="address-this-是什么意思"><a href="#address-this-是什么意思" class="headerlink" title="address(this)是什么意思"></a>address(this)是什么意思</h1><p>在 <strong>Solidity（以太坊智能合约编程语言）</strong> 中，<code>address(this)</code> 是一个核心表达式，用于获取<strong>当前智能合约自身的地址</strong>。</p>
<h3 id="一、核心含义"><a href="#一、核心含义" class="headerlink" title="一、核心含义"></a>一、核心含义</h3><p><code>this</code> 代表当前合约实例本身，<code>address(this)</code> 则将合约实例显式转换为其对应的以太坊地址（<code>address</code> 类型）—— 这个地址是合约部署到区块链上时生成的唯一标识符（长度为20字节的十六进制字符串，如 <code>0x123...abc</code>）。</p>
<h3 id="二、关键特性"><a href="#二、关键特性" class="headerlink" title="二、关键特性"></a>二、关键特性</h3><ol>
<li><strong>类型</strong>：返回值为 <code>address</code> 类型（Solidity 0.8.x 后也可显式转为 <code>address payable</code> 以支持转账）；</li>
<li><strong>作用域</strong>：可在合约的任意函数（包括 <code>public</code>&#x2F;<code>private</code>&#x2F;<code>internal</code>&#x2F;<code>external</code>）中使用；</li>
<li><strong>不可变性</strong>：合约部署后地址固定，<code>address(this)</code> 的值永久不变。</li>
</ol>
<h3 id="三、常见使用场景"><a href="#三、常见使用场景" class="headerlink" title="三、常见使用场景"></a>三、常见使用场景</h3><h4 id="场景1：获取合约地址（基础）"><a href="#场景1：获取合约地址（基础）" class="headerlink" title="场景1：获取合约地址（基础）"></a>场景1：获取合约地址（基础）</h4><p>直接返回合约自身地址，方便前端&#x2F;外部合约查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.20;<br><br>contract MyContract &#123;<br>    // 返回合约自身地址<br>    function getContractAddress() public view returns (address) &#123;<br>        return address(this);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h4 id="场景2：合约接收-管理ETH（核心）"><a href="#场景2：合约接收-管理ETH（核心）" class="headerlink" title="场景2：合约接收&#x2F;管理ETH（核心）"></a>场景2：合约接收&#x2F;管理ETH（核心）</h4><p>合约地址可作为ETH接收方，需结合 <code>payable</code> 转换：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">contract ETHVault &#123;<br>    // 向合约自身转账（示例：从调用者转ETH到合约）<br>    function deposit() public payable &#123;&#125;<br><br>    // 获取合约余额（通过address(this)查询）<br>    function getContractBalance() public view returns (uint256) &#123;<br>        return address(this).balance; // 查询合约地址的ETH余额<br>    &#125;<br><br>    // 合约转账给其他地址（需将address(this)转为payable）<br>    function withdrawTo(address payable _to) public &#123;<br>        payable(address(this)).transfer(_to.balance); // 合约转出ETH<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h4 id="场景3：外部合约交互时标识自身"><a href="#场景3：外部合约交互时标识自身" class="headerlink" title="场景3：外部合约交互时标识自身"></a>场景3：外部合约交互时标识自身</h4><p>当当前合约需要向其他合约传递“自己的地址”（如授权、回调）时使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">contract A &#123;<br>    B public bContract;<br><br>    constructor(address _bAddress) &#123;<br>        bContract = B(_bAddress);<br>    &#125;<br><br>    function registerSelf() public &#123;<br>        // 向合约B注册当前合约的地址<br>        bContract.registerContract(address(this));<br>    &#125;<br>&#125;<br><br>contract B &#123;<br>    mapping(address =&gt; bool) public registeredContracts;<br><br>    function registerContract(address _contractAddr) public &#123;<br>        registeredContracts[_contractAddr] = true;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="四、注意事项"><a href="#四、注意事项" class="headerlink" title="四、注意事项"></a>四、注意事项</h3><ol>
<li><p><strong><code>this</code> 与 <code>msg.sender</code> 的区别</strong>：</p>
<ul>
<li><code>address(this)</code>：当前合约的地址；</li>
<li><code>msg.sender</code>：调用当前函数的外部账户&#x2F;合约地址。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">function compare() public view returns (address, address) &#123;<br>    return (address(this), msg.sender); // 前者是合约地址，后者是调用者地址<br>&#125;<br></code></pre></div></td></tr></table></figure>
</li>
<li><p><strong><code>address(this).balance</code></strong>：</p>
<ul>
<li>仅查询合约地址的 <strong>ETH余额</strong>（不包含ERC20&#x2F;ERC721等代币余额）；</li>
<li>代币余额需通过对应代币合约的 <code>balanceOf(address(this))</code> 查询。</li>
</ul>
</li>
<li><p><strong><code>payable</code> 转换</strong>：<br>Solidity 0.8.x 后，普通 <code>address</code> 无法直接转账，需显式转为 <code>payable(address(this))</code> 才能调用 <code>transfer()</code>&#x2F;<code>send()</code>&#x2F;<code>call()</code>。</p>
</li>
</ol>
<h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p><code>address(this)</code> 是Solidity中获取<strong>当前合约部署地址</strong>的标准方式，核心用于：</p>
<ul>
<li>查询合约地址&#x2F;余额；</li>
<li>合约间交互时标识自身；</li>
<li>管理合约的ETH资产。</li>
</ul>
<p>它是智能合约开发中最常用的表达式之一，需重点区分其与 <code>msg.sender</code>、<code>tx.origin</code> 的差异。</p>
<h1 id="example-t-sol-这个文件和example-sol有什么区别"><a href="#example-t-sol-这个文件和example-sol有什么区别" class="headerlink" title="example.t.sol 这个文件和example.sol有什么区别"></a>example.t.sol 这个文件和example.sol有什么区别</h1><p>在 Solidity 开发中，<code>example.t.sol</code> 和 <code>example.sol</code> 是<strong>约定俗成的命名区分</strong>，核心差异在于文件用途、内容定位和工具链适配，以下是详细拆解：</p>
<h3 id="一、核心用途差异"><a href="#一、核心用途差异" class="headerlink" title="一、核心用途差异"></a>一、核心用途差异</h3><p>| 特征                | example.sol                | example.t.sol                          |<br>| <strong>核心定位</strong>        | 业务&#x2F;合约逻辑实现文件      | 合约测试文件（Test）                   |<br>| <strong>内容主体</strong>        | 正式的智能合约代码（如业务逻辑、数据结构、接口定义） | 基于测试框架的测试用例（如 Forge、Hardhat 测试） |<br>| <strong>是否部署</strong>        | 通常会部署到区块链        | 仅用于本地&#x2F;测试网验证，不部署          |<br>| <strong>依赖关系</strong>        | 可能依赖其他合约，但不依赖测试框架 | 依赖 <code>example.sol</code> 和测试框架（如 Forge 的 <code>Test</code> 合约、Hardhat 的 Chai） |</p>
<h3 id="二、命名规范的由来"><a href="#二、命名规范的由来" class="headerlink" title="二、命名规范的由来"></a>二、命名规范的由来</h3><p><code>t.sol</code> 是 <strong>Foundry（主流 Solidity 测试框架）</strong> 的官方约定：</p>
<ul>
<li>Foundry 会自动识别后缀为 <code>.t.sol</code> 的文件作为测试文件，运行 <code>forge test</code> 时仅执行这类文件中的测试逻辑；</li>
<li>无 <code>.t</code> 后缀的 <code>.sol</code> 文件被视为“源码文件”，Foundry 编译时会优先处理，但不会当作测试用例执行。</li>
</ul>
<p>其他框架（如 Hardhat）虽不强制 <code>.t.sol</code> 命名，但社区也普遍沿用这一约定区分源码和测试文件（Hardhat 更常见的是将测试文件放在 <code>test/</code> 目录，源码在 <code>contracts/</code> 目录）。</p>
<h3 id="三、代码示例对比"><a href="#三、代码示例对比" class="headerlink" title="三、代码示例对比"></a>三、代码示例对比</h3><h4 id="1-example-sol（源码文件）"><a href="#1-example-sol（源码文件）" class="headerlink" title="1. example.sol（源码文件）"></a>1. example.sol（源码文件）</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.20;<br><br>// 业务合约：简单的计数器<br>contract Counter &#123;<br>    uint256 public count;<br><br>    function increment() external &#123;<br>        count += 1;<br>    &#125;<br><br>    function decrement() external &#123;<br>        require(count &gt; 0, &quot;Count is zero&quot;);<br>        count -= 1;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h4 id="2-example-t-sol（测试文件）"><a href="#2-example-t-sol（测试文件）" class="headerlink" title="2. example.t.sol（测试文件）"></a>2. example.t.sol（测试文件）</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.20;<br><br>// 引入 Foundry 测试框架<br>import &quot;forge-std/Test.sol&quot;;<br>// 引入待测试的合约<br>import &quot;./example.sol&quot;;<br><br>// 测试合约：继承 Test 以使用断言、日志等测试能力<br>contract CounterTest is Test &#123;<br>    Counter public counter;<br><br>    // 测试前置：每个测试用例执行前初始化<br>    function setUp() public &#123;<br>        counter = new Counter();<br>    &#125;<br><br>    // 测试用例：命名以 test 开头（Foundry 识别规则）<br>    function testIncrement() public &#123;<br>        counter.increment();<br>        assertEq(counter.count(), 1); // 断言计数为1<br>    &#125;<br><br>    function testDecrementRevertWhenZero() public &#123;<br>        // 断言调用 decrement 会触发 revert，且理由匹配<br>        vm.expectRevert(&quot;Count is zero&quot;);<br>        counter.decrement();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="四、关键补充"><a href="#四、关键补充" class="headerlink" title="四、关键补充"></a>四、关键补充</h3><ol>
<li><strong>目录结构配合</strong>：<br>规范的项目中，源码文件通常放在 <code>src/</code> 目录（如 <code>src/example.sol</code>），测试文件放在 <code>test/</code> 目录（如 <code>test/example.t.sol</code>），进一步区分职责。</li>
<li><strong>编译&#x2F;执行差异</strong>：<ul>
<li>编译源码：<code>forge build</code> 会编译所有 <code>.sol</code> 文件，但仅输出源码合约的 ABI&#x2F;字节码；</li>
<li>执行测试：<code>forge test</code> 仅扫描 <code>.t.sol</code> 文件，执行其中以 <code>test</code> 开头的函数。</li>
</ul>
</li>
<li><strong>非强制但推荐</strong>：<br>理论上可以将测试代码写在普通 <code>.sol</code> 文件中，但违反约定会导致工具链无法自动识别、团队协作混乱，因此<strong>必须严格遵循</strong>。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>example.sol</code>：<strong>业务合约源码</strong>，实现核心逻辑，是部署和调用的主体；</li>
<li><code>example.t.sol</code>：<strong>测试合约</strong>，基于测试框架验证 <code>example.sol</code> 的正确性，仅用于开发阶段的验证。</li>
</ul>
<p>这一区分是 Solidity 生态的通用最佳实践，核心目的是隔离“业务代码”和“测试代码”，提升项目可维护性。</p>
<h1 id="账户"><a href="#账户" class="headerlink" title="账户"></a>账户</h1><p>在以太坊中，账户通常分为两类：外部拥有账户（Externally Owned Accounts，EOA）和合约账户（Contract Accounts）。这两类账户的差异在很大程度上仅存在于概念层面——因为以太坊虚拟机（EVM）本质上对它们一视同仁！</p>
<p>以太坊虚拟机上的每个账户都拥有一个公钥地址和账户余额。合约账户还会存储自身的字节码，以及内部的存储数据。</p>
<p>当从外部拥有账户向合约账户发起调用时，有几项关键信息需要明确：调用发起者是谁、调用时附带了多少以太币、以及调用者想要触发合约的哪个函数（包括传入的参数）。</p>
<p>Solidity 语言会自动将交易数据与我们在合约中定义的函数进行关联匹配。同时，该语言还允许我们通过 <code>msg.sender</code>、<code>msg.value</code> 等全局变量获取交易参数。</p>
<p>借助这些用于处理账户相关操作的工具，我们可以轻松地在合约中定义角色、权限，以及追踪代币余额。接下来，让我们全面学习如何在 Solidity 中处理账户相关的开发工作！</p>
<h1 id="以太坊消息"><a href="#以太坊消息" class="headerlink" title="以太坊消息"></a><strong>以太坊消息</strong></h1><p>如果一个外部拥有账户（EOA）想要与以太坊网络交互，它会广播一笔交易。该交易中包含数据，旨在指示以太坊虚拟机（EVM）执行某些操作。</p>
<p>这些数据通常被称为 <strong>calldata</strong>，它指定了 EVM 执行的操作，并标识了目标合约账户。目标合约账户可能会进一步发起对其他合约账户的调用。每一个这样的调用都被视为一个消息调用，并携带像发送者地址、目标函数签名以及发送的 wei 数量等信息。</p>
<p>在 Solidity 中，我们可以通过全局变量访问这些消息：</p>
<ul>
<li><code>msg.data (bytes)</code> - 完整的 calldata</li>
<li><code>msg.sender (address)</code> - 发送消息的地址</li>
<li><code>msg.sig (bytes4)</code> - 目标函数的签名</li>
<li><code>msg.value (uint)</code> - 发送的 wei 数量</li>
</ul>
<p>你可能会好奇，为什么 <code>msg.sig</code> 是 4 个字节？这个值实际上是目标函数签名的 <code>keccak256</code> 哈希值的前四个字节。它为我们提供了一种方法，可以用少量字节唯一地标识（并且确定性地定位）智能合约中的函数。</p>
<h1 id="Your-Goal-Store-the-Owner"><a href="#Your-Goal-Store-the-Owner" class="headerlink" title="Your Goal: Store the Owner"></a>Your Goal: Store the Owner</h1><p>Create a public address state variable called owner on the contract<br>Next create a constructor function which will store the msg.sender in owner</p>
<p>答案：</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">// SPDX-License-Identifier: MIT</span><br>pragma solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.20</span>;<br><br>contract <span class="hljs-title class_">Contract</span> &#123;<br>    address <span class="hljs-keyword">public</span> owner;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        owner = msg.<span class="hljs-property">sender</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Web3/">Web3</a>
                    
                  </div>
                
              </div>
              
                
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/12/11/21502.html">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">university.alchemy3</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/12/10/47034.html">
                        <span class="hidden-mobile">university.alchemy</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


            

                
                  <a id="scroll-top-button" href="#" role="button">
                    <i class="iconfont icon-arrowup" aria-hidden="true"></i>
                  </a>
                  

                    

                          
      </main>

      <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://whale3070.github.io/" target="_blank" rel="nofollow noopener"><span>Whale3070</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->




  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>





  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<link href="/pagefind/pagefind-ui.css" rel="stylesheet">
  <script src="/pagefind/pagefind-ui.js"></script>
  <style>
    /* 搜索框配色适配 */
    #search { margin-top: 2rem; }
    [data-user-color-scheme='dark'] .pagefind-ui {
      --pagefind-ui-primary: #eeeeee;
      --pagefind-ui-text: #eeeeee;
      --pagefind-ui-background: #151515;
      --pagefind-ui-border: #333;
    }
  </style>
    </body>

  </html>