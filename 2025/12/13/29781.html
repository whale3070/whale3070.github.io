

  <!DOCTYPE html>
  <html lang="zh-CN" data-default-color-scheme=&#34;dark&#34; >
  <style>
    .text1
    {
    text-shadow: 0px 0px 2px #f2f3f2;
    }
    </style>

  <script>
    // 强制内网 IP 识别为安全上下文
    if (window.location.hostname !== 'localhost' && window.location.protocol === 'http:') {
        // 尝试手动映射 crypto 属性
        if (!window.crypto.subtle && window.crypto.webkitSubtle) {
            window.crypto.subtle = window.crypto.webkitSubtle;
        }
    }
    
    // 终极补丁：如果还是没有 subtle，则创建一个占位符避免报错
    // 提示：这通常能解决加载报错，但如果插件强依赖原生加密，建议执行下面的“降级”预判
    if (!window.isSecureContext) {
        console.warn('当前环境非安全上下文，正在尝试兼容内网加密解密...');
    }
</script>


<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/null">
  <link rel="icon" type="image/png" href="/null">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>university.alchemy4 - whale3070&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.4.0/styles/github-gist.min.css" />
    
  

  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"whale3070.github.io","root":"/","version":"1.8.7","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":false,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 7.3.0"></head>


    <body>
      <header style="height: 70vh;">
        <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>InfoSec learning</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/search/">
                <i class="iconfont icon-search"></i>
                搜索
              </a>
            </li>
          
        
        
        
          
        
      </ul>
    </div>
  </div>
</nav>

          <div class="banner" id="banner" false
            style="background: url('/img/default.png') no-repeat center center;
              background-size: cover;">
              <div class="full-bg-img">
                <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
                  <div class="page-header text-center fade-in-up">
                    <span class="h2 text1" id="subtitle" title="university.alchemy4">
                      
                        university.alchemy4
                      
                    </span>
        
                    
                      <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2025-12-13 07:28" pubdate>
        2025年12月13日 早上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      5.7k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      71
       分钟
    </span>
  

  
  
</div>

                    
                  </div>
                    
                  </div>
                  
                </div>
              </div>
          </div>
      </header>

      <main>
        
          

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" data-pagefind-body>
            <!-- SEO header -->
            <h1 style="display: none">university.alchemy4</h1>
            
            <div class="markdown-body">
              <h1 id="Calldata"><a href="#Calldata" class="headerlink" title="Calldata"></a><strong>Calldata</strong></h1><p>当我们想与智能合约进行通信时，我们从外部拥有账户（Externally Owned Account，EOA）发送一个交易。在这个交易中，有一个数据属性，通常被称为“calldata”。这种调用数据格式对于调用 Solidity 函数来说，无论是来自 EOA 的交易，还是一个合约之间的消息调用，都是相同的。</p>
<p>这个格式大致如下。假设你想调用一个 <code>approve</code> 方法，接受一个 <code>uint</code> 参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">function approve(uint val) external;<br></code></pre></div></td></tr></table></figure>

<p>我们可以通过对该函数的签名进行哈希处理（使用 <code>keccak256</code>），然后取哈希值的前 4 个字节来定位这个函数。对于 <code>approve</code> 方法来说，哈希值是 <code>keccak256(&quot;approve(uint256)&quot;)</code>。该哈希值的前 4 个字节是 <code>0xb759f954</code>。这就是我们的 calldata 的第一部分！</p>
<p>接下来，我们需要确定我们要批准多少数量。假设我们要批准的值是 15，那么它的十六进制表示是 <code>0xf</code>。我们需要将这个值填充为 256 位，或者说 64 个十六进制字符。结果的值将是：</p>
<figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">000000000000000000000000000000000000000000000000000000000000000f<br></code></pre></div></td></tr></table></figure>

<p>如果我们将这个值与函数签名结合起来，我们的 calldata 将是：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-number">0xb759f954000000000000000000000000000000000000000000000000000000000000000f</span><br></code></pre></div></td></tr></table></figure>

<p>无论是来自 EOA 的交易，还是合约之间的消息调用，这都会是我们发送 15 给 <code>approve</code> 函数的 calldata。</p>
<p>准备好开始处理 calldata 了吗？让我们开始吧！</p>
<h1 id="接口-Interfaces"><a href="#接口-Interfaces" class="headerlink" title="接口 (Interfaces)"></a><strong>接口 (Interfaces)</strong></h1><p>使一个合约与另一个合约交互的最简单方式是定义目标合约。接口就是为了这个目的而存在的。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">interface IToken &#123;<br>    function getBalance(address user) external;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>我们可以使用这个接口与实现了 <code>getBalance</code> 方法的代币合约进行正确的通信：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">// tokenAddress: 我们想要与之通信的合约地址<br>// userAddress: 我们想要查询余额的地址<br>uint balance = IToken(tokenAddress).getBalance(userAddress);<br></code></pre></div></td></tr></table></figure>

<p>在幕后，Solidity 正在创建一个消息调用，该调用为 <code>getBalance</code> 调用编码了 calldata。</p>
<h1 id="你的目标：警告英雄"><a href="#你的目标：警告英雄" class="headerlink" title="你的目标：警告英雄"></a><strong>你的目标：警告英雄</strong></h1><p>使用 <code>IHero</code> 接口和传入 <code>sendAlert</code> 的英雄地址，从 Sidekick 合约中向英雄发送警报。</p>
<p>答案：</p>
<figure class="highlight scss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scss"><span class="hljs-comment">// SPDX-License-Identifier: MIT</span><br>pragma solidity ^<span class="hljs-number">0.8</span><span class="hljs-selector-class">.20</span>;<br><br>interface IHero &#123;<br>    function <span class="hljs-built_in">alert</span>() external;<br>&#125;<br><br>contract Sidekick &#123;<br>    function <span class="hljs-built_in">sendAlert</span>(address hero) external &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> alert the hero using the IHero interface</span><br>        <span class="hljs-built_in">IHero</span>(hero)<span class="hljs-selector-class">.alert</span>();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="为什么Ihero接口可以传入hero地址，那能不能传入balance余额"><a href="#为什么Ihero接口可以传入hero地址，那能不能传入balance余额" class="headerlink" title="为什么Ihero接口可以传入hero地址，那能不能传入balance余额"></a>为什么Ihero接口可以传入hero地址，那能不能传入balance余额</h1><p>要理解这个问题，核心是分清<strong>接口的作用</strong>和<strong>数据类型的本质</strong>：<code>IHero</code> 接口是用来和「实现该接口的合约地址」交互的，而 <code>balance</code> 是地址的<strong>属性值</strong>（不是合约地址本身），二者不能混为一谈。下面分两部分详细解释：</p>
<h3 id="一、为什么-IHero-接口可以传入-hero-地址？"><a href="#一、为什么-IHero-接口可以传入-hero-地址？" class="headerlink" title="一、为什么 IHero 接口可以传入 hero 地址？"></a>一、为什么 <code>IHero</code> 接口可以传入 <code>hero</code> 地址？</h3><p><code>IHero(hero)</code> 本质是「<strong>类型转换</strong>」，不是「传入参数」，核心逻辑是：</p>
<ol>
<li><strong>接口的本质</strong>：<code>IHero</code> 接口是一个「函数签名规范」，它定义了“只要某个合约实现了 <code>alert()</code> 函数，就可以被当作 <code>IHero</code> 类型来调用”。</li>
<li><strong>地址的作用</strong>：<code>hero</code> 是一个 <code>address</code> 类型的值，代表一个合约的部署地址（这个合约恰好实现了 <code>IHero</code> 接口的 <code>alert()</code> 函数）。</li>
<li><strong>类型转换的意义</strong>：<code>IHero(hero)</code> 告诉 Solidity 编译器：“把这个 <code>hero</code> 地址对应的合约，当作实现了 <code>IHero</code> 接口的合约来处理，我要调用它的 <code>alert()</code> 函数”。</li>
</ol>
<p>简单说：接口是「操作规范」，地址是「操作目标」，接口 + 地址 &#x3D; 明确“对哪个合约执行哪些规范内的操作”。</p>
<h3 id="二、能不能把-balance-余额传入-IHero-接口？——-不能（核心原因）"><a href="#二、能不能把-balance-余额传入-IHero-接口？——-不能（核心原因）" class="headerlink" title="二、能不能把 balance 余额传入 IHero 接口？—— 不能（核心原因）"></a>二、能不能把 <code>balance</code> 余额传入 <code>IHero</code> 接口？—— 不能（核心原因）</h3><p><code>balance</code> 是 <code>address</code> 类型的<strong>只读属性</strong>（比如 <code>address(this).balance</code>、<code>hero.balance</code>），它的类型是 <code>uint256</code>（数字），而 <code>IHero</code> 接口只能和 <code>address</code> 类型（合约地址）绑定，二者的本质和用途完全不同：</p>
<p>| 特征                | <code>hero</code> 地址（<code>address</code>）| <code>balance</code> 余额（<code>uint256</code>）|<br>| 数据类型            | 地址类型（标识合约&#x2F;账户的身份） | 无符号整数（纯数值）|<br>| 作用                | 定位要交互的合约&#x2F;账户          | 表示地址下的ETH余额            |<br>| 能否绑定到 <code>IHero</code>  | 能（接口需和地址绑定才能调用函数） | 不能（接口只认地址，不认数字） |</p>
<h4 id="错误示例（直观理解）："><a href="#错误示例（直观理解）：" class="headerlink" title="错误示例（直观理解）："></a>错误示例（直观理解）：</h4><p>如果强行把 <code>balance</code> 传给 <code>IHero</code>，编译器会直接报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">function sendAlert(address hero) external &#123;<br>    // 获取hero地址的余额（uint256类型）<br>    uint256 heroBalance = hero.balance;<br>    // 错误！IHero() 要求传入address类型，但heroBalance是uint256<br>    IHero(heroBalance).alert(); <br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>报错原因：<code>IHero()</code> 括号内必须传入 <code>address</code> 类型的值，而 <code>balance</code> 是 <code>uint256</code>，类型不匹配，编译器无法将一个数字解析为合约地址。</p>
<h3 id="三、如果想操作-balance-余额，该怎么做？"><a href="#三、如果想操作-balance-余额，该怎么做？" class="headerlink" title="三、如果想操作 balance 余额，该怎么做？"></a>三、如果想操作 <code>balance</code> 余额，该怎么做？</h3><p>虽然不能把 <code>balance</code> 传入 <code>IHero</code> 接口，但可以<strong>基于 <code>hero</code> 地址获取&#x2F;操作其余额</strong>，比如：</p>
<ol>
<li><strong>读取 <code>hero</code> 地址的余额</strong>：直接通过 <code>address</code> 类型的 <code>balance</code> 属性获取（无需接口）；</li>
<li><strong>向 <code>hero</code> 地址转账（修改余额）</strong>：将地址转为 <code>payable</code> 后调用 <code>transfer</code>&#x2F;<code>send</code>&#x2F;<code>call</code>（也无需 <code>IHero</code> 接口）。</li>
</ol>
<h4 id="正确示例（结合接口-余额操作）："><a href="#正确示例（结合接口-余额操作）：" class="headerlink" title="正确示例（结合接口+余额操作）："></a>正确示例（结合接口+余额操作）：</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.20;<br><br>interface IHero &#123;<br>    function alert() external;<br>&#125;<br><br>contract Sidekick &#123;<br>    function sendAlertAndCheckBalance(address hero) external &#123;<br>        // 1. 先通过IHero接口调用hero合约的alert()函数（核心需求）<br>        IHero(hero).alert();<br><br>        // 2. 再获取hero地址的余额（uint256类型）<br>        uint256 heroBalance = hero.balance;<br>        // 比如：打印余额（测试用）<br>        emit HeroBalance(hero, heroBalance);<br><br>        // 3. 若需向hero地址转账（修改余额），需转为payable<br>        if (heroBalance &lt; 1 ether) &#123;<br>            payable(hero).transfer(1 ether); // 给hero转1ETH<br>        &#125;<br>    &#125;<br><br>    // 事件：用于打印hero的余额（方便测试）<br>    event HeroBalance(address indexed hero, uint256 balance);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><ol>
<li><code>IHero</code> 接口的核心是「调用指定地址合约的 <code>alert()</code> 函数」，因此必须传入 <code>address</code> 类型的 <code>hero</code> 合约地址；</li>
<li><code>balance</code> 是地址的<strong>数值属性</strong>（<code>uint256</code>），不是地址本身，无法传入 <code>IHero()</code> 进行接口绑定；</li>
<li>操作余额的正确方式：基于 <code>hero</code> 地址（<code>address</code>）直接读取&#x2F;修改，和 <code>IHero</code> 接口是“并行操作”，而非“传入关系”。</li>
</ol>
<p>简单记：接口绑「地址」，余额是地址的「属性值」，二者是“对象”和“对象的属性”的关系，不能互相替代。</p>
<h1 id="Your-Goal-Alert-Hero-Manually-你的目标：手动提醒英雄"><a href="#Your-Goal-Alert-Hero-Manually-你的目标：手动提醒英雄" class="headerlink" title="Your Goal: Alert Hero, Manually 你的目标：手动提醒英雄"></a>Your Goal: Alert Hero, Manually 你的目标：手动提醒英雄</h1><p>Alert the Hero, manually this time!<br>这次手动通知英雄！</p>
<p>Fill in the function signature for the Hero’s alert function. Notice that we are taking the first 4 bytes of the hash of this function and passing it in as calldata to the hero.<br>填写英雄的alert函数的函数签名。注意，我们要取这个函数哈希值的前4个字节，并将其作为calldata传递给英雄。</p>
<p>答案：</p>
<figure class="highlight smali"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs smali">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.20;<br><br>contract Sidekick &#123;<br>    function sendAlert(address hero) external &#123;<br>        // TODO:<span class="hljs-built_in"> fill </span>in the function signature in the <span class="hljs-string">&quot;&quot;</span><br>        bytes4 signature = bytes4(keccak256(<span class="hljs-string">&quot;alert()&quot;</span>));<br><br>        (bool success, ) = hero.call(abi.encodePacked(signature));<br><br>        require(success);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="Your-Goal-Alert-the-Hero-with-Arguments"><a href="#Your-Goal-Alert-the-Hero-with-Arguments" class="headerlink" title="Your Goal: Alert the Hero with Arguments"></a>Your Goal: Alert the Hero with Arguments</h1><p>你的目标：用论据提醒英雄<br>Alert the Hero by calling alert and passing the number of enemies and whether or not they are armed<br>通过调用alert并传入enemies的数量以及他们是否armed，来向Hero发出警报。</p>
<p>答案：</p>
<figure class="highlight zephir"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs zephir"><span class="hljs-comment">// SPDX-License-Identifier: MIT</span><br>pragma solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.20</span>;<br><br>contract Sidekick &#123;<br>    <span class="hljs-comment">// sendAlert 函数根据传入的参数生成 calldata</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendAlert</span><span class="hljs-params">(address hero, <span class="hljs-keyword">uint</span> enemies, <span class="hljs-keyword">bool</span> armed)</span> <span class="hljs-title">external</span> </span>&#123;<br>        <span class="hljs-comment">// 使用传入的 enemies 和 armed 参数构造 calldata</span><br>        bytes memory payload = abi.encodeWithSignature(<span class="hljs-string">&quot;alert(uint256,bool)&quot;</span>, enemies, armed);<br>        <br>        <span class="hljs-comment">// 调用 hero 合约的 alert 函数</span><br>        (<span class="hljs-keyword">bool</span> success, ) = hero.call(payload);<br>        <span class="hljs-keyword">require</span>(success, <span class="hljs-string">&quot;Alert failed&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="之前的报错"><a href="#之前的报错" class="headerlink" title="之前的报错"></a>之前的报错</h1><p>错误答案：</p>
<figure class="highlight d"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: MIT </span><br><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.20</span>; <br>contract Sidekick &#123; <br>	<span class="hljs-built_in">function</span> sendAlert(address hero, <span class="hljs-built_in">uint</span> enemies, <span class="hljs-built_in">bool</span> armed) external &#123; <br>		bytes memory payload = abi.encodeWithSignature(<span class="hljs-string">&quot;alert(uint256,bool)&quot;</span>,<span class="hljs-number">5</span>,<span class="hljs-literal">true</span>); <br>		(<span class="hljs-built_in">bool</span> success1, ) = hero.call(payload); <br>	&#125; <br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>从你提供的错误信息来看，<code>testAlert2()</code> 测试没有通过，错误表明传递给 <code>hero</code> 合约的敌人数量和敌人是否武装的值与预期不匹配：</p>
<ul>
<li><strong>错误 1:</strong> <code>it should have let the hero know there are 2 enemies</code> — 你传递的敌人数量是 5，但应该是 2。</li>
<li><strong>错误 2:</strong> <code>it should have let the hero know the enemies are not armed</code> — 你传递的敌人是否武装是 <code>true</code>，但应该是 <code>false</code>。</li>
</ul>
<p>这意味着你的 <code>sendAlert</code> 函数只发送了固定的值 <code>5</code> 和 <code>true</code>，没有根据测试要求传递正确的动态值。</p>
<h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h3><p>你需要调整 <code>Sidekick</code> 合约中的 <code>sendAlert</code> 函数，使其能够根据传入的 <code>enemies</code> 和 <code>armed</code> 参数来动态生成 calldata，并将这些值传递给 <code>hero</code> 合约。这样，<code>testAlert2()</code> 测试就会传递正确的敌人数量和武装状态。</p>
<h3 id="修改后的代码："><a href="#修改后的代码：" class="headerlink" title="修改后的代码："></a>修改后的代码：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.20;<br><br>contract Sidekick &#123;<br>    // sendAlert 函数根据传入的参数生成 calldata<br>    function sendAlert(address hero, uint enemies, bool armed) external &#123;<br>        // 使用传入的 enemies 和 armed 参数构造 calldata<br>        bytes memory payload = abi.encodeWithSignature(&quot;alert(uint256,bool)&quot;, enemies, armed);<br>        <br>        // 调用 hero 合约的 alert 函数<br>        (bool success, ) = hero.call(payload);<br>        require(success, &quot;Alert failed&quot;);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h3><ul>
<li>在原来的代码中，<code>sendAlert</code> 函数总是传递固定的 <code>5</code> 和 <code>true</code>。但我们需要动态传递 <code>enemies</code> 和 <code>armed</code> 参数，因此我们使用 <code>abi.encodeWithSignature</code> 来根据传入的参数构造正确的 calldata。</li>
<li>通过 <code>hero.call(payload)</code> 调用 <code>hero</code> 合约的 <code>alert</code> 函数，传递动态的 <code>enemies</code> 和 <code>armed</code> 参数。</li>
</ul>
<h3 id="进一步说明："><a href="#进一步说明：" class="headerlink" title="进一步说明："></a>进一步说明：</h3><ul>
<li><strong><code>abi.encodeWithSignature(&quot;alert(uint256,bool)&quot;, enemies, armed)</code></strong>: 这里我们构造了一个 calldata，用于调用 <code>alert(uint256,bool)</code> 函数。我们用传入的 <code>enemies</code> 和 <code>armed</code> 参数来替代原来的固定值 <code>5</code> 和 <code>true</code>，确保每次调用时传递正确的值。</li>
<li><strong><code>(bool success, ) = hero.call(payload)</code></strong>: 使用 <code>call</code> 机制调用目标合约的 <code>alert</code> 函数，并传递正确的 calldata。</li>
</ul>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>通过上述修改，<code>Sidekick</code> 合约的 <code>sendAlert</code> 函数将根据输入动态生成正确的 calldata，并传递给 <code>hero</code> 合约。这样，<code>testAlert2()</code> 测试将能够通过，传递正确的敌人数量和敌人是否武装的状态。</p>
<h1 id="Your-Goal-Pass-Calldata-你的目标：传递调用数据"><a href="#Your-Goal-Pass-Calldata-你的目标：传递调用数据" class="headerlink" title="Your Goal: Pass Calldata 你的目标：传递调用数据"></a>Your Goal: Pass Calldata 你的目标：传递调用数据</h1><p>The Sidekick needs to be able to relay any calldata along to the Hero. Update the relay function to take the data and send it to the Hero as calldata.<br>Sidekick需要能够将任何调用数据转发给Hero。更新relay函数以接收data并将其作为调用数据发送给Hero。</p>
<p>答案：</p>
<figure class="highlight armasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs armasm"><span class="hljs-comment">// SPDX-License-Identifier: MIT</span><br><span class="hljs-symbol">pragma</span> solidity ^<span class="hljs-number">0</span>.<span class="hljs-number">8</span>.<span class="hljs-number">20</span><span class="hljs-comment">;</span><br><br><span class="hljs-symbol">contract</span> Sidekick &#123;<br>    <span class="hljs-meta">function</span> relay(address hero, bytes memory <span class="hljs-meta">data</span>) external &#123;<br>        <span class="hljs-comment">// send all of the data as calldata to the hero</span><br>        (bool success, ) = hero.call(<span class="hljs-meta">data</span>)<span class="hljs-comment">;</span><br>        <span class="hljs-meta">require</span>(success, <span class="hljs-string">&quot;Relay failed&quot;</span>)<span class="hljs-comment">;</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="Your-Goal-Trigger-the-fallback-你的目标：传递调用数据"><a href="#Your-Goal-Trigger-the-fallback-你的目标：传递调用数据" class="headerlink" title="Your Goal: Trigger the fallback 你的目标：传递调用数据"></a>Your Goal: Trigger the fallback 你的目标：传递调用数据</h1><p><strong>回退函数 (Fallback Function)</strong></p>
<p>当数据发送到合约时，如果数据与合约中任何函数的“标识符”不匹配（即函数签名的前 4 个字节的哈希值），合约的回退函数（fallback function）将被触发。这意味着，如果你向合约发送一个随机的 4 字节值，它很可能不会匹配任何函数，如果合约中存在回退函数，就会触发回退函数。</p>
<p>同样的，如果你发送的数据字节数少于或多于 4 字节！只要这前 4 字节与某个函数标识符不匹配，回退函数就会被触发。</p>
<p>题目：<br>In the makeContact method, send some calldata to the Hero contract that will trigger its fallback function.<br>Sidekick需要能够将任何调用数据转发给Hero。更新relay函数以接收data并将其作为调用数据发送给Hero。</p>
<p>答案：</p>
<figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-comment">// SPDX-License-Identifier: MIT</span><br>pragma solidity ^<span class="hljs-number">0.8</span>.<span class="hljs-number">20</span>;<br><br>contract Sidekick &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeContact</span>(<span class="hljs-params">address hero</span>) <span class="hljs-title">external</span> </span>&#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> trigger the hero&#x27;s fallback function!</span><br>        (<span class="hljs-keyword">bool</span> success, ) = hero.<span class="hljs-title function_ invoke__">call</span>(<span class="hljs-string">&quot;data&quot;</span>);<br>        <span class="hljs-keyword">require</span>(success, <span class="hljs-string">&quot;Relay failed&quot;</span>);<br>    &#125;<br>    <span class="hljs-title function_ invoke__">fallback</span>() external payable &#123;<br>        <span class="hljs-comment">// 这里可以处理触发回退函数的逻辑</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="let’s-build-an-escrow-agreement-between-2-parties-to-transfer-some-value-arbitrated-by-a-3rd-party-解释一下这句话的意思"><a href="#let’s-build-an-escrow-agreement-between-2-parties-to-transfer-some-value-arbitrated-by-a-3rd-party-解释一下这句话的意思" class="headerlink" title="let’s build an escrow agreement between 2 parties to transfer some value, arbitrated by a 3rd party 解释一下这句话的意思"></a>let’s build an escrow agreement between 2 parties to transfer some value, arbitrated by a 3rd party 解释一下这句话的意思</h1><p>这句话的意思是：<strong>让我们构建一份由第三方仲裁的、双方之间的价值转移托管协议</strong>。</p>
<p>我们可以拆解一下句子中的关键术语，结合你提到的 <strong>Escrow Smart Contract（托管智能合约）</strong> 背景来理解：</p>
<ol>
<li><strong>escrow agreement</strong>：托管协议。指交易双方把要转移的资产（比如资金、代币、数字资产等）先交给一个中立的第三方保管，满足约定条件后，第三方再把资产转给接收方。</li>
<li><strong>between 2 parties</strong>：在双方之间。这里的双方就是交易的发起方和接收方，比如买家和卖家。</li>
<li><strong>to transfer some value</strong>：用以转移一定的价值。这里的“价值”可以是货币、加密货币、数字资产，或是其他有价值的标的物。</li>
<li><strong>arbitrated by a 3rd party</strong>：由第三方仲裁。第三方扮演“托管人”或“仲裁者”的角色，它需要确保交易双方都遵守协议条款——比如买家付款后，卖家是否履约发货；如果双方产生纠纷，也由这个第三方来判定资产最终归属。</li>
</ol>
<p>在区块链和智能合约的场景下，这个“第三方”通常就是<strong>托管智能合约</strong>，它会按照预先编写好的代码逻辑自动执行托管、验证条件和完成资产转移，无需人工干预，能有效降低信任成本。</p>
<p>我可以帮你整理一份<strong>简单的托管智能合约核心逻辑清单</strong>，让你更直观地理解这种三方模式的运作步骤，需要吗？</p>
<h1 id="Your-Goal-Addresses-你的目标：地址"><a href="#Your-Goal-Addresses-你的目标：地址" class="headerlink" title="Your Goal: Addresses 你的目标：地址"></a>Your Goal: Addresses 你的目标：地址</h1><p>Create three public storage variables for the addresses of the depositor, beneficiary and arbiter.<br>为depositor、beneficiary和arbiter的地址创建三个公共存储变量。</p>
<p>答案：</p>
<figure class="highlight d"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: MIT</span><br><span class="hljs-keyword">pragma</span> solidity <span class="hljs-number">0.8</span><span class="hljs-number">.20</span>;<br><br>contract Escrow &#123;<br>    address <span class="hljs-keyword">public</span> depositor;<br>    address <span class="hljs-keyword">public</span> beneficiary;<br>    address <span class="hljs-keyword">public</span> arbiter;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="存款人是部署合约的地址，因此获取该地址并将其存储在depositor状态变量中。部署合约的地址不就是address-this-合约的地址吗？"><a href="#存款人是部署合约的地址，因此获取该地址并将其存储在depositor状态变量中。部署合约的地址不就是address-this-合约的地址吗？" class="headerlink" title="存款人是部署合约的地址，因此获取该地址并将其存储在depositor状态变量中。部署合约的地址不就是address(this)合约的地址吗？"></a>存款人是部署合约的地址，因此获取该地址并将其存储在depositor状态变量中。部署合约的地址不就是address(this)合约的地址吗？</h1><p>你的核心疑问是 <strong>“部署合约的地址” 和 “合约自身地址” 的混淆</strong> —— 这是 Solidity 中最基础也最容易踩坑的地址概念，必须明确区分：</p>
<h3 id="关键结论先摆清楚"><a href="#关键结论先摆清楚" class="headerlink" title="关键结论先摆清楚"></a>关键结论先摆清楚</h3><ul>
<li><strong>部署合约的地址</strong> &#x3D; <code>msg.sender</code>（发起部署交易的外部账户&#x2F;合约）</li>
<li><strong>合约自身的地址</strong> &#x3D; <code>address(this)</code>（合约部署后在链上的唯一标识）</li>
<li>两者<strong>永远不是同一个地址</strong>（除非极端特殊场景，且无实际意义）</li>
</ul>
<h3 id="用通俗的例子解释"><a href="#用通俗的例子解释" class="headerlink" title="用通俗的例子解释"></a>用通俗的例子解释</h3><p>把合约想象成「一个快递柜」：</p>
<ol>
<li>你（比如地址 <code>0x123</code>）去快递柜公司申请部署一个新快递柜 → 你就是「部署者」（<code>msg.sender</code>）</li>
<li>快递柜安装好后，有了自己的物理编号（比如 <code>0x456</code>）→ 这是「快递柜自身地址」（<code>address(this)</code>）</li>
<li>你（<code>0x123</code>）往快递柜（<code>0x456</code>）里放包裹 → 你是「存款人」，快递柜是「资金托管容器」</li>
</ol>
<p>显然：<strong>你（部署者）和快递柜（合约）是两个完全不同的主体</strong>，地址自然不一样。</p>
<h3 id="回到你的代码误区"><a href="#回到你的代码误区" class="headerlink" title="回到你的代码误区"></a>回到你的代码误区</h3><p>你原来的代码写 <code>depositor = address(this)</code>，相当于：</p>
<ul>
<li>把「快递柜自身」当成了「放包裹的人」→ 逻辑完全错误</li>
<li>正确逻辑是「放包裹的人（你，<code>msg.sender</code>）」才是 <code>depositor</code></li>
</ul>
<h3 id="用代码验证（一看就懂）"><a href="#用代码验证（一看就懂）" class="headerlink" title="用代码验证（一看就懂）"></a>用代码验证（一看就懂）</h3><p>部署以下测试合约，就能直观看到两者的区别：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">pragma solidity 0.8.20;<br><br>contract TestAddress &#123;<br>    address public deployer; // 部署合约的地址（msg.sender）<br>    address public contractAddress; // 合约自身地址（address(this)）<br><br>    constructor() &#123;<br>        deployer = msg.sender; // 部署者地址<br>        contractAddress = address(this); // 合约自身地址<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>部署后调用两个查询函数：</p>
<ul>
<li><code>deployer</code> 会返回 <strong>你的钱包地址</strong>（比如 MetaMask 账户地址）</li>
<li><code>contractAddress</code> 会返回 <strong>合约部署后的链上地址</strong>（一串全新的地址）</li>
<li>两者必然不同，这就是你之前报错的根本原因（工具预期 <code>depositor</code> 是部署者地址，而你存的是合约地址）</li>
</ul>
<h3 id="补充：address-this-的正确用法"><a href="#补充：address-this-的正确用法" class="headerlink" title="补充：address(this) 的正确用法"></a>补充：address(this) 的正确用法</h3><p><code>address(this)</code> 是「合约自身的地址」，核心用途是：</p>
<ol>
<li>查询合约的 ETH 余额：<code>address(this).balance</code>（比如托管合约中查询当前托管的资金）</li>
<li>合约向其他地址转账时，作为「付款方」（比如 <code>(bool success, ) = beneficiary.call&#123;value: address(this).balance&#125;(&quot;&quot;)</code>）</li>
<li>引用合约自身的其他功能（极少用，一般用 <code>this</code> 直接调用函数）</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>部署合约的地址 ≠ 合约自身的地址</li>
<li>部署者 &#x3D; <code>msg.sender</code>（发起部署交易的账户）</li>
<li>合约自身 &#x3D; <code>address(this)</code>（合约在链上的身份）</li>
<li>你的需求是「存款人 &#x3D; 部署者」，所以必须用 <code>depositor = msg.sender</code>，而不是 <code>address(this)</code></li>
</ul>
<h1 id="Your-Goal-Store-Addresses-你的目标：存储地址"><a href="#Your-Goal-Store-Addresses-你的目标：存储地址" class="headerlink" title="Your Goal: Store Addresses 你的目标：存储地址"></a>Your Goal: Store Addresses 你的目标：存储地址</h1><p>Create a constructor which takes two arguments: an address for the arbiter and an address for the beneficiary (in that order). Store these variables in the corresponding state variables.<br>创建一个constructor，它接受两个参数：一个用于仲裁者的address和一个用于受益人的address（按此顺序）。将这些变量存储在相应的状态变量中。<br>The depositor is the address deploying the contract, so take this address and store it in the depositor state variable.<br>存款人是部署合约的地址，因此获取该地址并将其存储在depositor状态变量中。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">// SPDX-License-Identifier: MIT</span><br>pragma solidity <span class="hljs-number">0.8</span><span class="hljs-number">.20</span>;<br><br>contract <span class="hljs-title class_">Escrow</span> &#123;<br>    address <span class="hljs-keyword">public</span> depositor;<br>    address <span class="hljs-keyword">public</span> beneficiary;<br>    address <span class="hljs-keyword">public</span> arbiter;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">address _arbiter, address _beneficiary</span>) &#123;<br>        arbiter = _arbiter;<br>        beneficiary = _beneficiary;<br>        depositor = msg.<span class="hljs-property">sender</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="Your-Goal-Payable-你的目标：存储地址"><a href="#Your-Goal-Payable-你的目标：存储地址" class="headerlink" title="Your Goal: Payable 你的目标：存储地址"></a>Your Goal: Payable 你的目标：存储地址</h1><p>Modify the constructor function to make it payable.<br>修改构造函数，使其可支付。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">// SPDX-License-Identifier: MIT</span><br>pragma solidity <span class="hljs-number">0.8</span><span class="hljs-number">.20</span>;<br><br>contract <span class="hljs-title class_">Escrow</span> &#123;<br>    address <span class="hljs-keyword">public</span> depositor;<br>    address <span class="hljs-keyword">public</span> beneficiary;<br>    address <span class="hljs-keyword">public</span> arbiter;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">address _arbiter, address _beneficiary</span>) payable &#123;<br>        arbiter = _arbiter;<br>        beneficiary = _beneficiary;<br>        depositor = msg.<span class="hljs-property">sender</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="Your-Goal-Approve-你的目标：批准"><a href="#Your-Goal-Approve-你的目标：批准" class="headerlink" title="Your Goal: Approve 你的目标：批准"></a>Your Goal: Approve 你的目标：批准</h1><p>Create an external function called approve.<br>创建一个名为approve的外部函数。<br>This function should move the contract’s balance to the beneficiary’s address.<br>此函数应将合约余额转移到受益人的地址。</p>
<p>答案：</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">// SPDX-License-Identifier: MIT</span><br>pragma solidity <span class="hljs-number">0.8</span><span class="hljs-number">.20</span>;<br><br>contract <span class="hljs-title class_">Escrow</span> &#123;<br>    address <span class="hljs-keyword">public</span> depositor;<br>    address <span class="hljs-keyword">public</span> beneficiary;<br>    address <span class="hljs-keyword">public</span> arbiter;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">address _arbiter, address _beneficiary</span>) payable &#123;<br>        arbiter = _arbiter;<br>        beneficiary = _beneficiary;<br>        depositor = msg.<span class="hljs-property">sender</span>;<br>    &#125;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">approve</span>(<span class="hljs-params"></span>) external &#123;<br>        uint256 amount = <span class="hljs-title function_">address</span>(<span class="hljs-variable language_">this</span>).<span class="hljs-property">balance</span>;<br>        (bool success, ) = <span class="hljs-title function_">payable</span>(beneficiary).<span class="hljs-property">call</span>&#123;<span class="hljs-attr">value</span>: amount&#125;(<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-built_in">require</span>(success);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="请问实现approve函数有几种方法"><a href="#请问实现approve函数有几种方法" class="headerlink" title="请问实现approve函数有几种方法?"></a>请问实现approve函数有几种方法?</h1><p>我记得可以用transfer，我以前学习erc20合约标准的时候有学过，transfer函数和transferFrom的区别，我记得第二种方法是使用payable</p>
<p>在Solidity中实现 <code>approve</code> 函数（核心功能：将合约余额转移给受益人），主要有 <strong>3种核心实现方式</strong>，其中你提到的 <code>transfer</code>、<code>payable</code> 是关键技术点（注：<code>transferFrom</code> 是ERC20的授权转账，不适用于合约余额直接转移，后文会明确区分）。以下是详细说明：</p>
<h3 id="一、先明确核心前提"><a href="#一、先明确核心前提" class="headerlink" title="一、先明确核心前提"></a>一、先明确核心前提</h3><ol>
<li>合约余额：指合约中存储的 <strong>原生代币（ETH&#x2F;BNB等）</strong>，而非ERC20代币（ERC20代币的转账需用 <code>transfer</code>&#x2F;<code>transferFrom</code>，但合约“余额”默认指原生代币）。</li>
<li>受益人地址：必须是 <code>payable</code> 类型（才能接收原生代币）。</li>
<li><code>approve</code> 函数的权限：通常需要 <strong>管理员&#x2F;授权账户</strong> 调用（避免任何人随意转走合约余额，下文示例会加入权限控制）。</li>
</ol>
<h3 id="二、3种实现方法（按安全性优先级排序）"><a href="#二、3种实现方法（按安全性优先级排序）" class="headerlink" title="二、3种实现方法（按安全性优先级排序）"></a>二、3种实现方法（按安全性优先级排序）</h3><h4 id="方法1：使用-transfer（最安全，推荐）"><a href="#方法1：使用-transfer（最安全，推荐）" class="headerlink" title="方法1：使用 transfer（最安全，推荐）"></a>方法1：使用 <code>transfer</code>（最安全，推荐）</h4><p><code>transfer</code> 是Solidity内置的原生代币转账函数，特点：</p>
<ul>
<li>固定转账2300 gas（防止重入攻击）；</li>
<li>转账失败时直接 <strong>回滚交易</strong>（无需手动处理返回值）；</li>
<li>语法：<code>beneficiary.transfer(amount)</code>（<code>beneficiary</code> 必须是 <code>payable</code> 地址）。</li>
</ul>
<p><strong>实现代码</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract ApproveContract &#123;<br>    address public immutable owner; // 管理员（有权调用approve）<br>    address public immutable beneficiary; // 固定受益人（也可设为参数）<br><br>    // 构造函数：初始化管理员和受益人<br>    constructor(address _beneficiary) &#123;<br>        owner = msg.sender;<br>        beneficiary = payable(_beneficiary); // 强制转为payable<br>    &#125;<br><br>    // 权限修饰符：仅管理员可调用<br>    modifier onlyOwner() &#123;<br>        require(msg.sender == owner, &quot;Not owner&quot;);<br>        _;<br>    &#125;<br><br>    // 外部函数：将合约全部余额转移给受益人<br>    function approve() external onlyOwner &#123;<br>        uint256 contractBalance = address(this).balance; // 获取合约余额<br>        require(contractBalance &gt; 0, &quot;Contract has no balance&quot;);<br>        <br>        // 核心：用transfer转账（失败自动回滚）<br>        payable(beneficiary).transfer(contractBalance); <br>        // 注：Solidity 0.8.0+ 中，address类型需显式转为payable（即使构造函数已转）<br>    &#125;<br><br>    // 接收原生代币的函数（合约需有此函数才能接收转账）<br>    receive() external payable &#123;&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>


<h4 id="方法2：使用-call-value-amount-（最灵活，推荐）"><a href="#方法2：使用-call-value-amount-（最灵活，推荐）" class="headerlink" title="方法2：使用 call{value: amount}(&quot;&quot;)（最灵活，推荐）"></a>方法2：使用 <code>call&#123;value: amount&#125;(&quot;&quot;)</code>（最灵活，推荐）</h4><p><code>call</code> 是低级别转账函数，特点：</p>
<ul>
<li>可自定义gas上限（默认使用剩余gas）；</li>
<li>转账失败时返回 <code>bool</code> 值（需手动检查，否则交易不会回滚）；</li>
<li>支持携带额外数据（此处用空字符串 <code>&quot;&quot;</code> 表示仅转账）；</li>
<li>安全性：需配合 <code>ReentrancyGuard</code> 防止重入攻击（Solidity 0.8.0+ 内置溢出检查，无需额外处理）。</li>
</ul>
<p><strong>实现代码</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br>import &quot;@openzeppelin/contracts/security/ReentrancyGuard.sol&quot;; // 防重入库<br><br>// 继承ReentrancyGuard实现防重入<br>contract ApproveContractWithCall is ReentrancyGuard &#123;<br>    address public immutable owner;<br>    address public immutable beneficiary;<br><br>    constructor(address _beneficiary) &#123;<br>        owner = msg.sender;<br>        beneficiary = payable(_beneficiary);<br>    &#125;<br><br>    modifier onlyOwner() &#123;<br>        require(msg.sender == owner, &quot;Not owner&quot;);<br>        _;<br>    &#125;<br><br>    // 外部函数：转账（加nonReentrant防重入）<br>    function approve() external onlyOwner nonReentrant &#123;<br>        uint256 contractBalance = address(this).balance;<br>        require(contractBalance &gt; 0, &quot;Contract has no balance&quot;);<br><br>        // 核心：用call转账，必须检查返回值<br>        (bool success, ) = payable(beneficiary).call&#123;value: contractBalance&#125;(&quot;&quot;);<br>        require(success, &quot;Transfer failed&quot;); // 转账失败则回滚<br>    &#125;<br><br>    receive() external payable &#123;&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>


<h4 id="方法3：使用-send（不推荐，仅作了解）"><a href="#方法3：使用-send（不推荐，仅作了解）" class="headerlink" title="方法3：使用 send（不推荐，仅作了解）"></a>方法3：使用 <code>send</code>（不推荐，仅作了解）</h4><p><code>send</code> 是早期的转账函数，特点：</p>
<ul>
<li>固定转账2300 gas（同transfer）；</li>
<li>转账失败时返回 <code>bool</code> 值（需手动检查，否则交易不会回滚）；</li>
<li>安全性：不如 <code>transfer</code>（失败不自动回滚，容易被忽略错误）。</li>
</ul>
<p><strong>实现代码（仅示例，不推荐生产使用）</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">function approve() external onlyOwner &#123;<br>    uint256 contractBalance = address(this).balance;<br>    require(contractBalance &gt; 0, &quot;Contract has no balance&quot;);<br><br>    // 核心：用send转账，必须检查返回值<br>    bool success = payable(beneficiary).send(contractBalance);<br>    require(success, &quot;Transfer failed&quot;);<br>&#125;<br></code></pre></div></td></tr></table></figure>


<h3 id="三、关键概念澄清（你提到的ERC20相关疑问）"><a href="#三、关键概念澄清（你提到的ERC20相关疑问）" class="headerlink" title="三、关键概念澄清（你提到的ERC20相关疑问）"></a>三、关键概念澄清（你提到的ERC20相关疑问）</h3><p>你提到的 <code>transfer</code> 和 <code>transferFrom</code> 是 <strong>ERC20代币的转账函数</strong>，与本文“合约原生代币余额转移”完全不同，需明确区分：</p>
<p>| 函数         | 适用场景                | 核心逻辑                                  |<br>| <code>transfer</code>（原生代币） | 合约→受益人（原生代币） | <code>payable(address).transfer(amount)</code>，失败自动回滚 |<br>| <code>transfer</code>（ERC20）   | 代币持有者→接收者       | <code>IERC20(token).transfer(to, amount)</code>，需授权（无） |<br>| <code>transferFrom</code>（ERC20）| 授权方→接收者（代转账） | 需先通过 <code>approve</code> 授权，再由第三方调用转账    |</p>
<p>简单说：</p>
<ul>
<li>本文的 <code>approve</code> 函数是 <strong>转移合约的原生代币</strong>，用 <code>transfer</code>&#x2F;<code>call</code> 即可；</li>
<li>ERC20的 <code>approve</code> 是 <strong>授权第三方操作自己的代币</strong>，后续用 <code>transferFrom</code> 执行转账。</li>
</ul>
<h3 id="四、总结与推荐"><a href="#四、总结与推荐" class="headerlink" title="四、总结与推荐"></a>四、总结与推荐</h3><ol>
<li><strong>推荐使用方法1（transfer）</strong>：简单、安全，适合大多数场景（无需自定义gas）；</li>
<li><strong>推荐使用方法2（call）</strong>：适合需要自定义gas、携带数据的场景（需配合防重入）；</li>
<li><strong>避免使用方法3（send）</strong>：错误处理繁琐，安全性不足；</li>
<li>必须加 <strong>权限控制</strong>（如 <code>onlyOwner</code>），否则任何人都能转走合约余额；</li>
<li>合约需实现 <code>receive()</code> 或 <code>fallback()</code> 函数，才能接收原生代币（否则无法存入余额）。</li>
</ol>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Web3/">Web3</a>
                    
                  </div>
                
              </div>
              
                
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/12/13/48114.html">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">别再卷低端岗了！“人才过剩”骗局下，这3类岗位正在抢人</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/12/11/41332.html">
                        <span class="hidden-mobile">CertiK最大的Web3安全公司</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


            

                
                  <a id="scroll-top-button" href="#" role="button">
                    <i class="iconfont icon-arrowup" aria-hidden="true"></i>
                  </a>
                  

                    

                          
      </main>

      <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://whale3070.github.io/" target="_blank" rel="nofollow noopener"><span>Whale3070</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->




  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>





  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<link href="/pagefind/pagefind-ui.css" rel="stylesheet">
  <script src="/pagefind/pagefind-ui.js"></script>
  <style>
    /* 搜索框配色适配 */
    #search { margin-top: 2rem; }
    [data-user-color-scheme='dark'] .pagefind-ui {
      --pagefind-ui-primary: #eeeeee;
      --pagefind-ui-text: #eeeeee;
      --pagefind-ui-background: #151515;
      --pagefind-ui-border: #333;
    }
  </style>
    </body>

  </html>