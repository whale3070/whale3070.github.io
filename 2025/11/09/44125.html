

  <!DOCTYPE html>
  <html lang="zh-CN" data-default-color-scheme=&#34;dark&#34; >
  <style>
    .text1
    {
    text-shadow: 0px 0px 2px #f2f3f2;
    }
    </style>

  

<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/null">
  <link rel="icon" type="image/png" href="/null">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>Solidity programming essentials-编写智能合约 - whale3070&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"192.168.126.129","root":"/","version":"1.8.7","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 7.3.0"></head>


    <body>
      <header style="height: 70vh;">
        <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>InfoSec learning</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/search/">
                <i class="iconfont icon-search"></i>
                搜索
              </a>
            </li>
          
        
        
        
          
        
      </ul>
    </div>
  </div>
</nav>

          <div class="banner" id="banner" false
            style="background: url('/img/default.png') no-repeat center center;
              background-size: cover;">
              <div class="full-bg-img">
                <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
                  <div class="page-header text-center fade-in-up">
                    <span class="h2 text1" id="subtitle" title="Solidity programming essentials-编写智能合约">
                      
                        Solidity programming essentials-编写智能合约
                      
                    </span>
        
                    
                      <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2025-11-09 11:11" pubdate>
        2025年11月9日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      3.6k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      40
       分钟
    </span>
  

  
  
</div>

                    
                  </div>
                    
                  </div>
                  
                </div>
              </div>
          </div>
      </header>

      <main>
        
          

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" data-pagefind-body>
            <!-- SEO header -->
            <h1 style="display: none">Solidity programming essentials-编写智能合约</h1>
            
            <div class="markdown-body">
              <h1 id="本章内容"><a href="#本章内容" class="headerlink" title="本章内容"></a>本章内容</h1><p>在本章中，您将开始编写真正的智能合约。它将讨论智能合约的设计方面，包括定义和实现合约，以及使用不同的机制（例如使用 <code>new</code>关键字和使用已知地址）部署和创建合约。</p>
<p>Solidity提供了丰富的面向对象特性，本章将深入探讨面向对象的概念和实现，例如继承、多重继承、声明抽象类和接口，以及为抽象函数和接口提供方法实现。</p>
<p>Solidity用于编写智能合约。本章专门介绍智能合约。您将从这里开始编写智能合约。本章将讨论智能合约的设计方面，包括合约的定义和实现，以及使用不同的机制（例如使用新的关键字和已知地址）来部署和创建合约。Solidity 提供了丰富的</p>
<p>面向对象特性，本章将深入探讨面向对象的概念和实现，例如继承、多重继承、声明抽象类和接口，以及为抽象函数和接口提供方法实现。</p>
<p>本章涵盖以下主题：</p>
<p>Creating contracts<br>Creating contracts via new<br>Inheritance<br>Abstract contracts<br>Interfaces</p>
<h1 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h1><p>什么是智能合约？每个人都试图理解合约的含义以及“智能”一词在合约语境中的意义，但往往一头雾水。智能合约本质上是部署在EVM（执行虚拟机）中的代码段或程序。合约一词通常用于法律领域，在编程领域意义不大。用Solidity编写智能合约并不意味着编写一份具有法律效力的合同。</p>
<p>此外，合约与其他任何程序代码一样，包含Solidity代码，并在被调用时执行。它本身并不智能。智能合约是区块链术语，指的是在EVM中执行的编程逻辑和代码。</p>
<p>智能合约与 C++、Java 或 C# 类非常相似。正如类由状态（变量）和行为（方法）组成一样，合约包含状态变量和函数。状态变量的作用是维护合约的当前状态，而函数负责执行逻辑并对当前状态进行更新和读取操作。</p>
<p>我们在上一章已经看到了一些智能合约的示例；</p>
<p>现在是时候深入探讨这个主题了。</p>
<h1 id="编写一个简单的合约"><a href="#编写一个简单的合约" class="headerlink" title="编写一个简单的合约"></a>编写一个简单的合约</h1><p>合约使用 <code>contract</code> 关键字和一个标识符来声明，如下面的代码片段所示：</p>
<p><code>contract SampleContract &#123; &#125;</code></p>
<p>在括号内是状态变量和函数定义的声明。合约的完整定义已在第 3 章“Solidity 简介”中讨论过，我再次提供该定义，以便快速参考。</p>
<p>此合约包含状态变量、结构体、定义、枚举声明、函数定义、修饰符和事件。</p>
<p>状态变量、结构体和枚举已在第 4 章“全局变量和函数”中详细讨论过。</p>
<p>函数、修饰符和事件将在接下来的两章中详细讨论。</p>
<h1 id="创建合约"><a href="#创建合约" class="headerlink" title="创建合约"></a>创建合约</h1><p>在 Solidity 中，创建和使用合约有两种方法：</p>
<p>使用 <code>new</code> 关键字</p>
<p>使用已部署合约的地址</p>
<h2 id="使用-new-关键字"><a href="#使用-new-关键字" class="headerlink" title="使用 new 关键字"></a>使用 <code>new</code> 关键字</h2><p>Solidity 中的 <code>new</code> 关键字用于部署并创建一个新的合约实例。它通过部署合约、初始化状态变量、运行构造函数、将 nonce 值设置为 1 来初始化合约实例，最终将实例地址返回给调用者。部署合约包括检查请求者是否提供了足够的 gas 来完成部署，使用请求者的地址和 nonce 值生成一个新的账户&#x2F;地址用于合约部署，并将随附的任何以太币传递给该账户&#x2F;地址。</p>
<p>在下一张截图中，定义了两个合约：HelloWorld 和 client。<br>在这种情况下，一个合约（client）部署并创建了另一个合约（HelloWorld）的一个新实例。<br>它使用 new 关键字来实现这一点，如下面的代码片段所示：</p>
<p><code>HelloWorld myObj = new HelloWorld();</code><br><img src="/2025/11/09/44125/1.png" srcset="/img/loading.gif"></p>
<h2 id="使用已部署合约的地址"><a href="#使用已部署合约的地址" class="headerlink" title="使用已部署合约的地址"></a>使用已部署合约的地址</h2><p>当合约已部署并实例化时，可以使用此方法创建合约实例。此方法使用已部署合约的地址。不会创建新的实例；而是重用现有实例。<br>通过地址创建对现有合约的引用。</p>
<p>在下一个代码示例中，定义了两个合约：HelloWorld 和 client。</p>
<p>在这种情况下，一个合约（client）使用另一个合约（HelloWorld）的已知地址来创建对其的引用。</p>
<p>它使用地址数据类型并将实际地址强制转换为 HelloWorld 合约类型。<br>myObj 对象包含现有合约的地址，</p>
<p>如下面的代码片段所示：<br><img src="/2025/11/09/44125/2.png" srcset="/img/loading.gif"></p>
<h1 id="构造函数（constructor）"><a href="#构造函数（constructor）" class="headerlink" title="构造函数（constructor）"></a>构造函数（constructor）</h1><p>Solidity 支持在合约中声明构造函数。</p>
<p>构造函数在 Solidity 中是可选的。如果开发者没有显式定义构造函数，编译器会自动生成一个默认构造函数。</p>
<p>构造函数在部署合约时执行一次。这与其他编程语言截然不同。<br>在其他语言中，每当创建一个对象实例时，构造函数都会被执行一次。</p>
<p>然而在 Solidity 中，构造函数仅在合约被部署到 EVM 的那一刻执行。构造函数通常用于初始化状态变量，并且一般应避免在其中书写过多或过于复杂的 Solidity 代码。</p>
<p>构造函数代码是一个合约生命周期中最先被执行的代码。<br>一个合约最多只能有一个构造函数，这与某些支持多个构造器重载的编程语言不同。<br>构造函数可以接受参数，这些参数应在部署合约时提供。</p>
<p>构造函数的名称应当与合约名称相同，两者必须一致。（注：这是 Solidity 0.4.x 的旧语法。新版已改为 constructor()。）<br>从可见性角度说，构造函数可以是 public 或 internal，但不能是 external 或 private。</p>
<p>（现代 Solidity 的构造函数不写可见性修饰符，默认是 public。）<br>构造函数不能显式返回任何数据。</p>
<p>在下面的示例中，定义了一个与 HelloWorld 合约同名的构造函数。它将存储变量 value 设置为 5。</p>
<p>当然可以 😊<br>下面是一个完整、适合在 <strong>Remix IDE</strong> 中直接运行的教学合约，<br>用于演示构造函数（constructor）的作用、参数传入、以及初始化状态变量的过程。</p>
<h2 id="🧩-文件名：HelloWorld-sol"><a href="#🧩-文件名：HelloWorld-sol" class="headerlink" title="🧩 文件名：HelloWorld.sol"></a>🧩 文件名：<code>HelloWorld.sol</code></h2><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.24;<br><br>/// @title Constructor 教学合约<br>/// @notice 演示 constructor 的参数传递与状态变量初始化<br>contract HelloWorld &#123;<br>    string public name;<br>    uint public value;<br>    address public owner;<br><br>    // 构造函数：部署时自动执行一次<br>    constructor(string memory _name, uint _value) &#123;<br>        name = _name;      // 初始化字符串<br>        value = _value;    // 初始化数值<br>        owner = msg.sender; // 记录部署者地址<br>    &#125;<br><br>    // 普通函数：修改状态变量（可手动调用）<br>    function updateValue(uint newValue) public &#123;<br>        require(msg.sender == owner, &quot;Only owner can update value&quot;);<br>        value = newValue;<br>    &#125;<br><br>    // 只读函数：返回合约当前信息<br>    function getInfo() public view returns (string memory, uint, address) &#123;<br>        return (name, value, owner);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><img src="/2025/11/09/44125/5.png" srcset="/img/loading.gif"></p>
<h2 id="🧠-学习要点解析"><a href="#🧠-学习要点解析" class="headerlink" title="🧠 学习要点解析"></a>🧠 学习要点解析</h2><p>| 概念              | 说明                      |<br>| <code>constructor</code>   | 构造函数，在合约部署时自动执行，仅执行一次。  |<br>| <code>_name, _value</code> | 部署时传入的参数，用来初始化状态变量。     |<br>| <code>msg.sender</code>    | 部署合约的账户地址，会被存入 <code>owner</code>。 |<br>| <code>require</code>       | 确保只有合约部署者可以更新 <code>value</code>。  |<br>| <code>view</code>          | 表示只读函数，不会修改链上数据。        |</p>
<h2 id="🧪-Remix-测试步骤"><a href="#🧪-Remix-测试步骤" class="headerlink" title="🧪 Remix 测试步骤"></a>🧪 Remix 测试步骤</h2><ol>
<li><p>打开 <a target="_blank" rel="noopener" href="https://remix.ethereum.org/">Remix IDE</a></p>
</li>
<li><p>新建文件 <code>HelloWorld.sol</code>，粘贴上方代码</p>
</li>
<li><p>选择编译器版本 <code>0.8.24</code> 或更高</p>
</li>
<li><p>点击 <strong>Deploy &amp; Run Transactions</strong></p>
<ul>
<li>在部署栏输入：<br><code>name = &quot;Solidity Demo&quot;</code><br><code>value = 5</code></li>
</ul>
</li>
<li><p>点击 <strong>Deploy</strong></p>
</li>
</ol>
<p>部署成功后，你可以在 <strong>Deployed Contracts</strong> 看到：</p>
<figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">name</span><span class="hljs-params">()</span></span>  → Solidity Demo<br><span class="hljs-function"><span class="hljs-title">value</span><span class="hljs-params">()</span></span> → <span class="hljs-number">5</span><br><span class="hljs-function"><span class="hljs-title">owner</span><span class="hljs-params">()</span></span> → 你的地址（msg.sender）<br></code></pre></div></td></tr></table></figure>


<h2 id="🧭-可选扩展：多个构造函数的历史写法（仅了解）"><a href="#🧭-可选扩展：多个构造函数的历史写法（仅了解）" class="headerlink" title="🧭 可选扩展：多个构造函数的历史写法（仅了解）"></a>🧭 可选扩展：多个构造函数的历史写法（仅了解）</h2><p>旧版本 Solidity（0.4.x 以前）用“同名函数”来定义构造函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">contract HelloWorld &#123;<br>    uint value;<br><br>    function HelloWorld(uint _v) public &#123;<br>        value = _v;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>在现代版本（≥0.5.0）中，这种写法已被弃用，<br>统一使用 <code>constructor(...) &#123;&#125;</code> 语法。</p>
<h1 id="合约组合（Contract-composition）"><a href="#合约组合（Contract-composition）" class="headerlink" title="合约组合（Contract composition）"></a>合约组合（Contract composition）</h1><p>Solidity 支持<strong>合约组合</strong>。所谓“组合”，是指将多个合约或数据类型<strong>组合在一起</strong>，以创建更复杂的数据结构和合约。</p>
<p>我们之前已经看到过许多合约组合的例子。例如，在本章前面展示的、使用 <code>new</code> 关键字创建合约的代码片段中。</p>
<p>在 Solidity 中，将复杂问题拆解为多个合约，再通过<strong>合约组合</strong>将它们组织起来，是一种良好的实践。</p>
<p>当然可以 👍 我们可以把“父子关系”改成**“继承关系”<strong>或</strong>“上层与下层合约关系”**，这样就更中性、专业，也没有性别色彩。下面是改写后的版本：</p>
<h1 id="继承（Inheritance）"><a href="#继承（Inheritance）" class="headerlink" title="继承（Inheritance）"></a>继承（Inheritance）</h1><p>继承是<strong>面向对象编程的核心概念之一</strong>，Solidity 同样支持智能合约之间的继承。</p>
<p>所谓继承，是指通过<strong>继承关系</strong>定义多个相互关联的合约。<br>被继承的合约称为<strong>基合约（base contract）</strong>，<br>而继承它的合约称为<strong>派生合约（derived contract）</strong>。</p>
<p>继承的主要目的在于<strong>代码复用（code reusability）</strong>。<br>基合约与派生合约之间存在一种 <strong>“is-a”（是一个）关系</strong>，<br>并且所有 <code>public</code> 和 <code>internal</code> 作用域的函数与状态变量都可以被派生合约访问。</p>
<p>实际上，Solidity 编译器会将基合约的字节码复制到派生合约的字节码中。<br>在派生合约中使用关键字 <code>is</code> 来继承基合约。</p>
<p>继承是每一位 Solidity 开发者必须掌握的重要概念，<br>因为它直接影响合约的<strong>版本管理</strong>与<strong>部署方式</strong>。</p>
<p>Solidity 支持多种形式的继承，包括<strong>多重继承（multiple inheritance）</strong>。<br>编译时，Solidity 会将所有基合约的内容复制进派生合约，<br>最终生成<strong>一个完整的合约</strong>，并由系统分配<strong>一个唯一地址</strong>，<br>供所有具备继承关系的合约共享使用。</p>
<h2 id="单一继承（Single-inheritance）"><a href="#单一继承（Single-inheritance）" class="headerlink" title="单一继承（Single inheritance）"></a><strong>单一继承（Single inheritance）</strong></h2><p>单一继承是指一个派生合约（derived contract）<strong>只继承一个基合约（base contract）</strong>。<br>通过单一继承，派生合约可以<strong>继承基合约中的变量、函数、修饰器（modifier）以及事件（event）</strong>，<br>从而实现代码复用与逻辑扩展。</p>
<p>可以想象成：“下层合约在上层合约的基础上继续发展功能”。</p>
<h3 id="Solidity-示例：单一继承（Single-Inheritance）"><a href="#Solidity-示例：单一继承（Single-Inheritance）" class="headerlink" title="Solidity 示例：单一继承（Single Inheritance）"></a>Solidity 示例：单一继承（Single Inheritance）</h3><p>下面这个例子展示了一个简单的单一继承结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>// 基合约（Base Contract）<br>contract HelloWorld &#123;<br>    string public message;<br><br>    // 构造函数<br>    constructor(string memory _msg) &#123;<br>        message = _msg;<br>    &#125;<br><br>    // 公共函数<br>    function sayHello() public view returns (string memory) &#123;<br>        return message;<br>    &#125;<br>&#125;<br><br>// 派生合约（Derived Contract）<br>// 使用 is 关键字继承 HelloWorld 合约<br>contract HelloClient is HelloWorld &#123;<br>    // 派生合约的构造函数<br>    constructor(string memory _msg) HelloWorld(_msg) &#123;&#125;<br><br>    // 新增函数：调用基合约函数<br>    function greet() public view returns (string memory) &#123;<br>        return string(abi.encodePacked(&quot;Client says: &quot;, sayHello()));<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>


<h3 id="🧩-说明"><a href="#🧩-说明" class="headerlink" title="🧩 说明"></a>🧩 说明</h3><ul>
<li><code>HelloWorld</code> 是 <strong>基合约</strong>，定义了一个状态变量 <code>message</code> 和一个函数 <code>sayHello()</code>。</li>
<li><code>HelloClient</code> 是 <strong>派生合约</strong>，通过 <code>is HelloWorld</code> 继承了 <code>HelloWorld</code> 的所有 <code>public</code> 与 <code>internal</code> 成员。</li>
<li>在 <code>HelloClient</code> 的构造函数中，通过 <code>HelloWorld(_msg)</code> 显式调用了基合约的构造函数。</li>
<li><code>HelloClient</code> 还定义了自己的新函数 <code>greet()</code>，展示了<strong>在继承基础上扩展功能</strong>的用法。</li>
</ul>
<p>🧠 <strong>总结：</strong></p>
<blockquote>
<p>单一继承让一个合约可以完整继承另一个合约的逻辑与数据，<br>既避免重复编写代码，又方便在此基础上扩展新特性。</p>
</blockquote>
<h2 id="Multi-level多层继承"><a href="#Multi-level多层继承" class="headerlink" title="Multi-level多层继承"></a>Multi-level多层继承</h2><blockquote>
<p>多层继承与单层继承非常相似；不同的是，它不是只有一层“基合约与派生合约”的关系，而是存在多个层级的继承结构。<br>换句话说，一个合约可以继承自另一个，而那个合约又继承自更上层的合约，形成继承链。</p>
</blockquote>
<figure class="highlight maxima"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs maxima"><span class="hljs-built_in">contract</span> A &#123;&#125;<br><br><span class="hljs-built_in">contract</span> B <span class="hljs-built_in">is</span> A &#123;&#125;<br><br><span class="hljs-built_in">contract</span> C <span class="hljs-built_in">is</span> B &#123;&#125;<br><br></code></pre></div></td></tr></table></figure>

<h3 id="🧩-Solidity-示例：多层继承（Multi-level-Inheritance）"><a href="#🧩-Solidity-示例：多层继承（Multi-level-Inheritance）" class="headerlink" title="🧩 Solidity 示例：多层继承（Multi-level Inheritance）"></a>🧩 Solidity 示例：多层继承（Multi-level Inheritance）</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.24;<br><br>// 🌱 最上层：基础合约<br>contract Base &#123;<br>    string internal message;<br><br>    function setMessage(string memory _msg) public &#123;<br>        message = _msg;<br>    &#125;<br><br>    function getMessage() public view returns (string memory) &#123;<br>        return message;<br>    &#125;<br>&#125;<br><br>// 🌿 中间层：扩展合约<br>contract Intermediate is Base &#123;<br>    function addExclamation() public &#123;<br>        message = string(abi.encodePacked(message, &quot;!&quot;));<br>    &#125;<br>&#125;<br><br>// 🌻 最底层：最终合约<br>contract Final is Intermediate &#123;<br>    function addSignature(string memory _sig) public &#123;<br>        message = string(abi.encodePacked(message, &quot; - &quot;, _sig));<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>


<h3 id="🧠-运行说明（在-Remix-中）"><a href="#🧠-运行说明（在-Remix-中）" class="headerlink" title="🧠 运行说明（在 Remix 中）"></a>🧠 运行说明（在 Remix 中）</h3><p><img src="/2025/11/09/44125/6.png" srcset="/img/loading.gif"></p>
<h3 id="🧭-结构图"><a href="#🧭-结构图" class="headerlink" title="🧭 结构图"></a>🧭 结构图</h3><figure class="highlight excel"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs excel"><span class="hljs-built_in">Base</span>  →  Intermediate  →  Final<br>（基础合约）    （中间层合约）     （最终合约）<br></code></pre></div></td></tr></table></figure>


<h2 id="层级继承（Hierarchical-inheritance）与简单继承类似；"><a href="#层级继承（Hierarchical-inheritance）与简单继承类似；" class="headerlink" title="层级继承（Hierarchical inheritance）与简单继承类似；"></a>层级继承（Hierarchical inheritance）与简单继承类似；</h2><p>不过，在这种继承中，<strong>一个合约同时作为多个其他合约的基础合约</strong>。</p>
<p>如下图所示：<br>合约 <strong>A</strong> 被同时继承在合约 <strong>B</strong> 和合约 <strong>C</strong> 中。</p>
<figure class="highlight maxima"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs maxima"><span class="hljs-built_in">contract</span> A &#123;&#125;<br><br><span class="hljs-built_in">contract</span> B <span class="hljs-built_in">is</span> A &#123;&#125;<br><br><span class="hljs-built_in">contract</span> C <span class="hljs-built_in">is</span> A &#123;&#125;<br><br></code></pre></div></td></tr></table></figure>

<h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><p>Solidity 支持多重继承。可以存在多级单继承（即一个合约继承自另一个合约，然后再被另一个合约继承）。然而，也可以有多个合约从同一个基合约派生出来。这些派生合约可以在进一步的子合约中作为基合约一起使用。当合约同时继承自这些子合约时，就形成了多重继承，如下图所示：</p>
<p><img src="/2025/11/09/44125/7.png" srcset="/img/loading.gif"></p>
<h3 id="✅-小结"><a href="#✅-小结" class="headerlink" title="✅ 小结"></a>✅ 小结</h3><p>| 类型   | 示例结构                        | 含义            |<br>| 单层继承 | Base → Derived              | 一层扩展关系        |<br>| 多层继承 | Base → Intermediate → Final | 多个层级连续扩展      |<br>| 多重继承 | A, B → C                    | 从多个基础合约继承     |<br>| 菱形继承 | A→B, A→C, B+C→D             | 需要线性化解决重复继承问题 |</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装是面向对象编程（OOP）最重要的支柱之一。<br>封装指的是隐藏状态变量或控制对其的直接访问，以改变其状态的过程。它指的是一种模式，即声明变量，使客户端无法直接访问这些变量，只能通过函数进行修改。这有助于对变量访问进行约束，同时又允许类提供足够的访问接口以便执行操作。Solidity 提供了多种可见性修饰符（visibility modifiers），如 <strong>external</strong>、<strong>public</strong>、<strong>internal</strong> 和 <strong>private</strong>，它们会影响状态变量在合约内部、继承的子合约或外部合约中的可见性。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Web3/">Web3</a>
                    
                  </div>
                
              </div>
              
                
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/11/09/48937.html">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Remix 部署 Solidity 合约的完整标准操作步骤</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/11/09/22392.html">
                        <span class="hidden-mobile">Solidity 2 个月学习路线</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


            

                
                  <a id="scroll-top-button" href="#" role="button">
                    <i class="iconfont icon-arrowup" aria-hidden="true"></i>
                  </a>
                  

                    

                          
      </main>

      <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://whale3070.github.io/" target="_blank" rel="nofollow noopener"><span>Whale3070</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<link href="/pagefind/pagefind-ui.css" rel="stylesheet">
  <script src="/pagefind/pagefind-ui.js"></script>
  <style>
    /* 搜索框配色适配 */
    #search { margin-top: 2rem; }
    [data-user-color-scheme='dark'] .pagefind-ui {
      --pagefind-ui-primary: #eeeeee;
      --pagefind-ui-text: #eeeeee;
      --pagefind-ui-background: #151515;
      --pagefind-ui-border: #333;
    }
  </style>
    </body>

  </html>