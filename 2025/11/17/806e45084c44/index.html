

  <!DOCTYPE html>
  <html lang="zh-CN" data-default-color-scheme=&#34;dark&#34; >
  <style>
    .text1
    {
    text-shadow: 0px 0px 2px #f2f3f2;
    }
    </style>

  

<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/null">
  <link rel="icon" type="image/png" href="/null">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>remix编译运行solidity12 - whale3070&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"192.168.126.129","root":"/","version":"1.8.7","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 7.3.0"></head>


    <body>
      <header style="height: 70vh;">
        <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>InfoSec learning</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/search/">
                <i class="iconfont icon-search"></i>
                搜索
              </a>
            </li>
          
        
        
        
          
        
      </ul>
    </div>
  </div>
</nav>

          <div class="banner" id="banner" false
            style="background: url('/img/default.png') no-repeat center center;
              background-size: cover;">
              <div class="full-bg-img">
                <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
                  <div class="page-header text-center fade-in-up">
                    <span class="h2 text1" id="subtitle" title="remix编译运行solidity12">
                      
                        remix编译运行solidity12
                      
                    </span>
        
                    
                      <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2025-11-17 08:29" pubdate>
        2025年11月17日 早上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      10.9k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      125
       分钟
    </span>
  

  
  
</div>

                    
                  </div>
                    
                  </div>
                  
                </div>
              </div>
          </div>
      </header>

      <main>
        
          

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" data-pagefind-body>
            <!-- SEO header -->
            <h1 style="display: none">remix编译运行solidity12</h1>
            
            <div class="markdown-body">
              <h1 id="4-什么是智能合约中的重入攻击（Reentrancy-Attack）？如何防范？"><a href="#4-什么是智能合约中的重入攻击（Reentrancy-Attack）？如何防范？" class="headerlink" title="4. 什么是智能合约中的重入攻击（Reentrancy Attack）？如何防范？"></a>4. 什么是智能合约中的重入攻击（Reentrancy Attack）？如何防范？</h1><p>重入攻击的概念和一些常见的防范策略是什么？</p>
<p>重入攻击（Reentrancy Attack）是一种常见的智能合约攻击类型，攻击者利用合约中的某些漏洞反复调用合约中的函数，造成不正常的行为，通常表现为多次修改状态或获取资金等。这种攻击通常发生在智能合约执行外部调用（例如调用另一个合约的函数或转账时）时，攻击者利用合约调用的可重入性（Reentrancy）反复进入合约并执行恶意操作。</p>
<h3 id="重入攻击的概念"><a href="#重入攻击的概念" class="headerlink" title="重入攻击的概念"></a><strong>重入攻击的概念</strong></h3><p>简单来说，重入攻击发生在智能合约调用另一个合约的外部函数时，攻击者能够通过恶意的回调函数再次调用原始合约的关键函数，造成预期之外的结果。例如，合约调用转账函数时，攻击者能够在接收到资金前重新调用原合约的函数，从而重复执行资金转账操作。</p>
<p>最著名的重入攻击案例就是 2016 年的 <strong>The DAO 攻击</strong>，攻击者利用重入攻击成功窃取了大量的以太币。</p>
<h3 id="重入攻击的示例"><a href="#重入攻击的示例" class="headerlink" title="重入攻击的示例"></a><strong>重入攻击的示例</strong></h3><p>假设有一个简单的智能合约，允许用户提取他们的余额：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">pragma solidity ^0.8.0;<br><br>contract Vulnerable &#123;<br>    mapping(address =&gt; uint) public balances;<br><br>    // 用户存款<br>    function deposit() public payable &#123;<br>        balances[msg.sender] += msg.value;<br>    &#125;<br><br>    // 用户提取存款<br>    function withdraw(uint _amount) public &#123;<br>        require(balances[msg.sender] &gt;= _amount, &quot;Insufficient balance&quot;);<br>        payable(msg.sender).transfer(_amount);  // 外部调用，可能会被重入攻击<br>        balances[msg.sender] -= _amount;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>在这个合约中，用户可以存入以太币并在需要时提取。如果用户想提取余额，合约会先通过 <code>transfer()</code> 函数将资金发送给用户，然后再更新用户的余额。</p>
<p>攻击者可以部署一个恶意合约，当它接收到资金时，会重新调用原始合约的 <code>withdraw()</code> 函数，从而导致余额被多次提取，直到原始合约的资金耗尽。</p>
<h3 id="如何防范重入攻击？"><a href="#如何防范重入攻击？" class="headerlink" title="如何防范重入攻击？"></a><strong>如何防范重入攻击？</strong></h3><p>防范重入攻击的方法通常是通过确保资金转账和状态更新操作的顺序，或者使用一些设计模式来避免攻击者在合约执行期间进行恶意重入。下面是一些常见的防范策略：</p>
<h4 id="1-遵循“检查-效果-交互”（Checks-Effects-Interactions）模式"><a href="#1-遵循“检查-效果-交互”（Checks-Effects-Interactions）模式" class="headerlink" title="1. 遵循“检查-效果-交互”（Checks-Effects-Interactions）模式"></a>1. <strong>遵循“检查-效果-交互”（Checks-Effects-Interactions）模式</strong></h4><p>在 Solidity 编程中，最常见的防范重入攻击的策略是遵循 “检查-效果-交互” 模式。即在进行任何外部调用之前，先更新合约的状态。</p>
<p><strong>具体步骤：</strong></p>
<ol>
<li><strong>检查</strong>：先验证条件（如余额足够）。</li>
<li><strong>效果</strong>：更新合约的状态（如修改余额）。</li>
<li><strong>交互</strong>：最后进行外部调用（如转账）。</li>
</ol>
<p>例如，修改上面合约中的 <code>withdraw()</code> 函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">function withdraw(uint _amount) public &#123;<br>    require(balances[msg.sender] &gt;= _amount, &quot;Insufficient balance&quot;);<br>    balances[msg.sender] -= _amount;  // 在转账前先更新状态<br>    payable(msg.sender).transfer(_amount);  // 然后进行外部调用<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>这样，攻击者就无法通过重入攻击再次调用合约中的 <code>withdraw()</code>，因为状态已经在外部调用之前更新。</p>
<h4 id="2-使用-reentrancyGuard-修饰符"><a href="#2-使用-reentrancyGuard-修饰符" class="headerlink" title="2. 使用 reentrancyGuard 修饰符"></a>2. <strong>使用 <code>reentrancyGuard</code> 修饰符</strong></h4><p>可以使用一个 <code>reentrancyGuard</code> 修饰符来防止合约在执行外部调用时被重入。这个修饰符通常使用一个简单的状态变量来锁定合约，防止同一函数在执行过程中被再次调用。</p>
<p><strong>实现 <code>reentrancyGuard</code> 修饰符的示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">uint private lock = 1;<br><br>modifier nonReentrant() &#123;<br>    require(lock == 1, &quot;No reentrancy allowed&quot;);<br>    lock = 2;<br>    _;<br>    lock = 1;<br>&#125;<br><br>function withdraw(uint _amount) public nonReentrant &#123;<br>    require(balances[msg.sender] &gt;= _amount, &quot;Insufficient balance&quot;);<br>    balances[msg.sender] -= _amount;<br>    payable(msg.sender).transfer(_amount);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>这里的 <code>nonReentrant</code> 修饰符通过 <code>lock</code> 变量来防止同一函数的重入。每次函数被调用时，都会锁定合约执行，直到函数执行完毕。</p>
<h4 id="3-限制外部调用的数量"><a href="#3-限制外部调用的数量" class="headerlink" title="3. 限制外部调用的数量"></a>3. <strong>限制外部调用的数量</strong></h4><p>限制每次交易中的外部调用次数，避免合约中出现多个外部调用。</p>
<h4 id="4-使用-call-替代-transfer-或-send"><a href="#4-使用-call-替代-transfer-或-send" class="headerlink" title="4. 使用 call 替代 transfer 或 send"></a>4. <strong>使用 <code>call</code> 替代 <code>transfer</code> 或 <code>send</code></strong></h4><p>虽然 <code>transfer</code> 和 <code>send</code> 是较安全的转账方式，但它们的 gas 限制（2300 gas）可能无法满足某些操作。推荐使用 <code>call</code> 函数来进行转账，并通过合理设置 gas 来确保不会受到重入攻击。</p>
<p><strong>使用 <code>call</code> 进行转账示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">(bool success, ) = msg.sender.call&#123;value: _amount&#125;(&quot;&quot;);<br>require(success, &quot;Transfer failed&quot;);<br></code></pre></div></td></tr></table></figure>

<p><code>call</code> 允许你控制发送的 gas 数量，通常比 <code>transfer</code> 或 <code>send</code> 更灵活，但在使用时仍然需要小心处理，避免暴露给重入攻击的风险。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>重入攻击是一种针对智能合约的常见攻击，攻击者通过利用合约中的外部调用反复调用合约函数，进而窃取资金。最有效的防范方法是遵循“检查-效果-交互”模式，即先更新状态再进行外部调用，另外可以使用 <code>reentrancyGuard</code> 来进一步增强防护。通过这些措施，可以有效防止重入攻击的发生，确保智能合约的安全性。</p>
<p>在 Solidity 中，智能合约一旦部署到区块链上，它们的代码和状态就无法修改。这意味着一旦合约部署后，如果需要修改或添加功能，必须通过某种方式进行升级。这种合约的“不可修改性”带来了对升级的挑战。为了应对这个问题，区块链开发者常常采用合约升级模式，以保证合约的灵活性和可扩展性。</p>
<h3 id="合约升级的常用模式"><a href="#合约升级的常用模式" class="headerlink" title="合约升级的常用模式"></a><strong>合约升级的常用模式</strong></h3><ol>
<li><p><strong>代理模式（Proxy Pattern）</strong><br>代理模式是最常见的合约升级模式，它通过分离合约的存储和逻辑来实现合约的升级。在这种模式下，合约分为两个主要部分：</p>
<ul>
<li><strong>代理合约（Proxy Contract）</strong>：代理合约负责存储所有状态变量，并转发所有调用到逻辑合约。代理合约的唯一职责是转发请求，它本身不包含任何业务逻辑。</li>
<li><strong>逻辑合约（Logic Contract）</strong>：逻辑合约包含实际的业务逻辑，但没有存储状态。所有的函数执行和状态修改都在逻辑合约中定义。</li>
</ul>
<p>通过这种模式，如果需要升级合约，只需要部署新的逻辑合约，并将代理合约指向新的逻辑合约地址，而不需要修改代理合约中的存储数据。</p>
<p><strong>代理模式的基本结构：</strong></p>
<ol>
<li><p><strong>代理合约</strong>：</p>
<ul>
<li>存储数据。</li>
<li>转发函数调用到逻辑合约。</li>
</ul>
</li>
<li><p><strong>逻辑合约</strong>：</p>
<ul>
<li>负责处理业务逻辑，但不存储数据。</li>
</ul>
</li>
</ol>
<p>代理合约和逻辑合约之间的关系通过一个合约地址来绑定，通常这个地址是可以更新的。这样，即使业务逻辑发生变化，也可以将新的合约逻辑部署到新的地址上，而不影响存储在代理合约中的数据。</p>
<p><strong>实现代理合约的基本方式</strong>：<br>使用 Solidity 中的 <strong>delegatecall</strong> 来实现合约的升级，<code>delegatecall</code> 会让代理合约调用逻辑合约的代码，并使用代理合约的存储。</p>
<p><strong>代理合约示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">pragma solidity ^0.8.0;<br><br>// 代理合约<br>contract Proxy &#123;<br>    address public implementation;<br><br>    constructor(address _implementation) &#123;<br>        implementation = _implementation;<br>    &#125;<br><br>    // 转发所有调用到逻辑合约<br>    fallback() external payable &#123;<br>        address _impl = implementation;<br>        require(_impl != address(0), &quot;Implementation not set&quot;);<br>        (bool success, ) = _impl.delegatecall(msg.data);<br>        require(success, &quot;Delegatecall failed&quot;);<br>    &#125;<br><br>    // 设置新的逻辑合约地址<br>    function upgrade(address newImplementation) public &#123;<br>        implementation = newImplementation;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>在这个例子中，代理合约接收到的调用会通过 <code>delegatecall</code> 转发到逻辑合约中，而代理合约的状态（如 <code>implementation</code> 地址）可以在任何时候更新。</p>
<p><strong>逻辑合约示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">pragma solidity ^0.8.0;<br><br>// 逻辑合约<br>contract Logic &#123;<br>    uint256 public value;<br><br>    function setValue(uint256 _value) public &#123;<br>        value = _value;<br>    &#125;<br><br>    function getValue() public view returns (uint256) &#123;<br>        return value;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li>
<li><p><strong>可升级合约框架：OpenZeppelin Upgrades</strong><br>OpenZeppelin 提供了一个用于开发和管理可升级智能合约的框架，它基于代理模式。OpenZeppelin 提供了一个库和工具来帮助开发者创建、部署和管理升级的智能合约。</p>
<p>OpenZeppelin Upgrades 允许开发者使用代理合约模式，并且提供了易于使用的工具来确保合约的安全性和可升级性。它使用了类似代理合约和逻辑合约的结构，并通过一些额外的检查来防止潜在的安全问题。</p>
<p><strong>如何使用 OpenZeppelin Upgrades：</strong></p>
<ul>
<li>使用 <code>@openzeppelin/contracts-upgradeable</code> 包中的合约库来编写可升级的智能合约。</li>
<li>使用 <code>@openzeppelin/hardhat-upgrades</code> 插件来进行合约的部署和升级。</li>
</ul>
<p><strong>示例：</strong></p>
<ol>
<li><p>创建一个可升级的合约：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">pragma solidity ^0.8.0;<br>import &quot;@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol&quot;;<br><br>contract MyContract is Initializable &#123;<br>    uint256 public value;<br><br>    function initialize(uint256 _value) public initializer &#123;<br>        value = _value;<br>    &#125;<br><br>    function setValue(uint256 _value) public &#123;<br>        value = _value;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li>
<li><p>部署和升级合约：</p>
<p>使用 Hardhat 和 OpenZeppelin 的升级插件，你可以部署和升级合约：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; ethers, upgrades &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;hardhat&quot;</span>);<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title class_">MyContract</span> = <span class="hljs-keyword">await</span> ethers.<span class="hljs-title function_">getContractFactory</span>(<span class="hljs-string">&quot;MyContract&quot;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Deploying MyContract...&quot;</span>);<br>    <span class="hljs-keyword">const</span> myContract = <span class="hljs-keyword">await</span> upgrades.<span class="hljs-title function_">deployProxy</span>(<span class="hljs-title class_">MyContract</span>, [<span class="hljs-number">42</span>], &#123; <span class="hljs-attr">initializer</span>: <span class="hljs-string">&#x27;initialize&#x27;</span> &#125;);<br>    <span class="hljs-keyword">await</span> myContract.<span class="hljs-title function_">deployed</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;MyContract deployed to:&quot;</span>, myContract.<span class="hljs-property">address</span>);<br><br>    <span class="hljs-comment">// 升级合约</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title class_">MyContractV2</span> = <span class="hljs-keyword">await</span> ethers.<span class="hljs-title function_">getContractFactory</span>(<span class="hljs-string">&quot;MyContractV2&quot;</span>);<br>    <span class="hljs-keyword">const</span> upgraded = <span class="hljs-keyword">await</span> upgrades.<span class="hljs-title function_">upgradeProxy</span>(myContract.<span class="hljs-property">address</span>, <span class="hljs-title class_">MyContractV2</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;MyContract upgraded&quot;</span>);<br>&#125;<br><br><span class="hljs-title function_">main</span>();<br></code></pre></div></td></tr></table></figure></li>
</ol>
</li>
<li><p><strong>使用代理合约的关键点</strong></p>
<ul>
<li>通过代理合约和逻辑合约分离存储和执行代码，实现合约的灵活升级。</li>
<li>需要小心合约的状态管理和升级流程，避免出现不一致或错误的合约状态。</li>
<li>代理合约升级时，通常需要确保逻辑合约保持与代理合约的兼容性，以避免升级过程中出现问题。</li>
</ul>
</li>
</ol>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>在 Solidity 中，由于合约一旦部署无法修改，因此必须使用代理模式（Proxy Pattern）等升级模式来实现合约的灵活更新。代理模式通过分离存储和逻辑合约，使得升级变得可能，同时也避免了直接修改原始合约的存储数据。通过使用代理合约和逻辑合约分离，你可以在需要时部署新版本的逻辑合约，而不改变存储数据，确保合约的持续升级和扩展。OpenZeppelin 提供了一个便捷的框架来帮助开发者实现可升级合约。</p>
<h1 id="5-如何在-Solidity-中实现合约升级？"><a href="#5-如何在-Solidity-中实现合约升级？" class="headerlink" title="5. 如何在 Solidity 中实现合约升级？"></a>5. 如何在 Solidity 中实现合约升级？</h1><p>合约一旦部署到区块链上无法修改，如何应对合约的更新需求？有没有常用的合约升级模式？ 不知道 </p>
<p>在 Solidity 中，智能合约一旦部署到区块链上，它们的代码和状态就无法修改。这意味着一旦合约部署后，如果需要修改或添加功能，必须通过某种方式进行升级。这种合约的“不可修改性”带来了对升级的挑战。为了应对这个问题，区块链开发者常常采用合约升级模式，以保证合约的灵活性和可扩展性。</p>
<h3 id="合约升级的常用模式-1"><a href="#合约升级的常用模式-1" class="headerlink" title="合约升级的常用模式"></a><strong>合约升级的常用模式</strong></h3><ol>
<li><p><strong>代理模式（Proxy Pattern）</strong><br>代理模式是最常见的合约升级模式，它通过分离合约的存储和逻辑来实现合约的升级。在这种模式下，合约分为两个主要部分：</p>
<ul>
<li><strong>代理合约（Proxy Contract）</strong>：代理合约负责存储所有状态变量，并转发所有调用到逻辑合约。代理合约的唯一职责是转发请求，它本身不包含任何业务逻辑。</li>
<li><strong>逻辑合约（Logic Contract）</strong>：逻辑合约包含实际的业务逻辑，但没有存储状态。所有的函数执行和状态修改都在逻辑合约中定义。</li>
</ul>
<p>通过这种模式，如果需要升级合约，只需要部署新的逻辑合约，并将代理合约指向新的逻辑合约地址，而不需要修改代理合约中的存储数据。</p>
<p><strong>代理模式的基本结构：</strong></p>
<ol>
<li><p><strong>代理合约</strong>：</p>
<ul>
<li>存储数据。</li>
<li>转发函数调用到逻辑合约。</li>
</ul>
</li>
<li><p><strong>逻辑合约</strong>：</p>
<ul>
<li>负责处理业务逻辑，但不存储数据。</li>
</ul>
</li>
</ol>
<p>代理合约和逻辑合约之间的关系通过一个合约地址来绑定，通常这个地址是可以更新的。这样，即使业务逻辑发生变化，也可以将新的合约逻辑部署到新的地址上，而不影响存储在代理合约中的数据。</p>
<p><strong>实现代理合约的基本方式</strong>：<br>使用 Solidity 中的 <strong>delegatecall</strong> 来实现合约的升级，<code>delegatecall</code> 会让代理合约调用逻辑合约的代码，并使用代理合约的存储。</p>
<p><strong>代理合约示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">pragma solidity ^0.8.0;<br><br>// 代理合约<br>contract Proxy &#123;<br>    address public implementation;<br><br>    constructor(address _implementation) &#123;<br>        implementation = _implementation;<br>    &#125;<br><br>    // 转发所有调用到逻辑合约<br>    fallback() external payable &#123;<br>        address _impl = implementation;<br>        require(_impl != address(0), &quot;Implementation not set&quot;);<br>        (bool success, ) = _impl.delegatecall(msg.data);<br>        require(success, &quot;Delegatecall failed&quot;);<br>    &#125;<br><br>    // 设置新的逻辑合约地址<br>    function upgrade(address newImplementation) public &#123;<br>        implementation = newImplementation;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>在这个例子中，代理合约接收到的调用会通过 <code>delegatecall</code> 转发到逻辑合约中，而代理合约的状态（如 <code>implementation</code> 地址）可以在任何时候更新。</p>
<p><strong>逻辑合约示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">pragma solidity ^0.8.0;<br><br>// 逻辑合约<br>contract Logic &#123;<br>    uint256 public value;<br><br>    function setValue(uint256 _value) public &#123;<br>        value = _value;<br>    &#125;<br><br>    function getValue() public view returns (uint256) &#123;<br>        return value;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li>
<li><p><strong>可升级合约框架：OpenZeppelin Upgrades</strong><br>OpenZeppelin 提供了一个用于开发和管理可升级智能合约的框架，它基于代理模式。OpenZeppelin 提供了一个库和工具来帮助开发者创建、部署和管理升级的智能合约。</p>
<p>OpenZeppelin Upgrades 允许开发者使用代理合约模式，并且提供了易于使用的工具来确保合约的安全性和可升级性。它使用了类似代理合约和逻辑合约的结构，并通过一些额外的检查来防止潜在的安全问题。</p>
<p><strong>如何使用 OpenZeppelin Upgrades：</strong></p>
<ul>
<li>使用 <code>@openzeppelin/contracts-upgradeable</code> 包中的合约库来编写可升级的智能合约。</li>
<li>使用 <code>@openzeppelin/hardhat-upgrades</code> 插件来进行合约的部署和升级。</li>
</ul>
<p><strong>示例：</strong></p>
<ol>
<li><p>创建一个可升级的合约：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">pragma solidity ^0.8.0;<br>import &quot;@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol&quot;;<br><br>contract MyContract is Initializable &#123;<br>    uint256 public value;<br><br>    function initialize(uint256 _value) public initializer &#123;<br>        value = _value;<br>    &#125;<br><br>    function setValue(uint256 _value) public &#123;<br>        value = _value;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li>
<li><p>部署和升级合约：</p>
<p>使用 Hardhat 和 OpenZeppelin 的升级插件，你可以部署和升级合约：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; ethers, upgrades &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;hardhat&quot;</span>);<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title class_">MyContract</span> = <span class="hljs-keyword">await</span> ethers.<span class="hljs-title function_">getContractFactory</span>(<span class="hljs-string">&quot;MyContract&quot;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Deploying MyContract...&quot;</span>);<br>    <span class="hljs-keyword">const</span> myContract = <span class="hljs-keyword">await</span> upgrades.<span class="hljs-title function_">deployProxy</span>(<span class="hljs-title class_">MyContract</span>, [<span class="hljs-number">42</span>], &#123; <span class="hljs-attr">initializer</span>: <span class="hljs-string">&#x27;initialize&#x27;</span> &#125;);<br>    <span class="hljs-keyword">await</span> myContract.<span class="hljs-title function_">deployed</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;MyContract deployed to:&quot;</span>, myContract.<span class="hljs-property">address</span>);<br><br>    <span class="hljs-comment">// 升级合约</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title class_">MyContractV2</span> = <span class="hljs-keyword">await</span> ethers.<span class="hljs-title function_">getContractFactory</span>(<span class="hljs-string">&quot;MyContractV2&quot;</span>);<br>    <span class="hljs-keyword">const</span> upgraded = <span class="hljs-keyword">await</span> upgrades.<span class="hljs-title function_">upgradeProxy</span>(myContract.<span class="hljs-property">address</span>, <span class="hljs-title class_">MyContractV2</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;MyContract upgraded&quot;</span>);<br>&#125;<br><br><span class="hljs-title function_">main</span>();<br></code></pre></div></td></tr></table></figure></li>
</ol>
</li>
<li><p><strong>使用代理合约的关键点</strong></p>
<ul>
<li>通过代理合约和逻辑合约分离存储和执行代码，实现合约的灵活升级。</li>
<li>需要小心合约的状态管理和升级流程，避免出现不一致或错误的合约状态。</li>
<li>代理合约升级时，通常需要确保逻辑合约保持与代理合约的兼容性，以避免升级过程中出现问题。</li>
</ul>
</li>
</ol>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>在 Solidity 中，由于合约一旦部署无法修改，因此必须使用代理模式（Proxy Pattern）等升级模式来实现合约的灵活更新。代理模式通过分离存储和逻辑合约，使得升级变得可能，同时也避免了直接修改原始合约的存储数据。通过使用代理合约和逻辑合约分离，你可以在需要时部署新版本的逻辑合约，而不改变存储数据，确保合约的持续升级和扩展。OpenZeppelin 提供了一个便捷的框架来帮助开发者实现可升级合约。</p>
<h1 id="6-什么是-Gas？如何优化-Solidity-合约中的-Gas-使用？"><a href="#6-什么是-Gas？如何优化-Solidity-合约中的-Gas-使用？" class="headerlink" title="6. 什么是 Gas？如何优化 Solidity 合约中的 Gas 使用？"></a>6. 什么是 Gas？如何优化 Solidity 合约中的 Gas 使用？</h1><p>Gas 在 Solidity 中的作用是什么？你通常会使用哪些技巧来减少交易的 Gas 成本？</p>
<p>答：<br>以太坊是分布在不同计算机上的同一个程序，gas费是为了保证矿工或验证者有利可图，维持以太坊网络正确运行的费用。<br>gas费能保证合约使用的资源最小化。<br>我只知道一种减少交易gas的技巧。多调用，尽量少写代码。因为存储要花钱，转账也要花gas费。</p>
<p>你对 Gas 的理解是正确的，Gas 费用确实是为了确保以太坊网络的正常运行，奖励矿工或验证者的计算工作。Gas 是对区块链上执行计算操作（包括交易和合约调用）所消耗的计算资源的度量。每个操作（如存储数据、发送交易、调用合约函数等）都需要消耗一定的 Gas，而 Gas 的价格则决定了交易或操作的费用。</p>
<h3 id="Gas-在-Solidity-中的作用"><a href="#Gas-在-Solidity-中的作用" class="headerlink" title="Gas 在 Solidity 中的作用"></a><strong>Gas 在 Solidity 中的作用</strong></h3><p>Gas 的作用在于：</p>
<ol>
<li><strong>防止滥用</strong>：每次执行智能合约时，必须消耗 Gas，从而确保网络不会因不合理或恶意操作（如无限循环、重复调用等）而受到损害。</li>
<li><strong>支付矿工/验证者</strong>：Gas 费用作为奖励支付给矿工或验证者，确保他们的计算和验证工作能获得报酬。</li>
<li><strong>确保执行资源最小化</strong>：通过为每个操作分配一个 Gas 成本，Gas 费用帮助确保智能合约的执行是高效的，防止过度消耗资源。</li>
</ol>
<h3 id="如何优化-Solidity-合约中的-Gas-使用"><a href="#如何优化-Solidity-合约中的-Gas-使用" class="headerlink" title="如何优化 Solidity 合约中的 Gas 使用"></a><strong>如何优化 Solidity 合约中的 Gas 使用</strong></h3><p>你提到的 <strong>减少交易 Gas 的技巧</strong>（如多调用、尽量少写代码，避免频繁的存储操作等）是一个有效的方式。除了这些技巧外，下面还有一些常见的 Gas 优化方法，帮助你更有效地减少 Gas 成本：</p>
<h4 id="1-减少存储操作（存储比计算消耗更多-Gas）"><a href="#1-减少存储操作（存储比计算消耗更多-Gas）" class="headerlink" title="1. 减少存储操作（存储比计算消耗更多 Gas）"></a>1. <strong>减少存储操作（存储比计算消耗更多 Gas）</strong></h4><ul>
<li><strong>存储和修改状态变量非常昂贵</strong>：在 Solidity 中，读取和写入存储是最昂贵的操作之一。尽量避免不必要的存储操作。特别是在合约中多次修改状态变量时，可以考虑将计算和存储操作最小化。</li>
<li><strong>优化存储结构</strong>：将多个变量放在一个结构体中，或者合并多个状态变量来减少存储的数量。例如，尽量将 <code>uint256</code> 数组换成合适大小的固定数组，避免浪费空间和 Gas。</li>
</ul>
<p><strong>优化建议</strong>：</p>
<ul>
<li>使用 <code>mapping</code> 或 <code>array</code> 的时候要谨慎，避免在每次调用时都进行过多的存储操作。</li>
<li>合理分配存储位置，避免频繁地更新存储数据。</li>
</ul>
<h4 id="2-减少合约的外部调用"><a href="#2-减少合约的外部调用" class="headerlink" title="2. 减少合约的外部调用"></a>2. <strong>减少合约的外部调用</strong></h4><ul>
<li><strong>外部调用（如 <code>call</code>、<code>transfer</code>、<code>delegatecall</code>）通常会消耗更多 Gas</strong>。这些操作涉及跨合约调用，可能会导致更多的状态变化和更高的 Gas 消耗。</li>
<li>尽量减少不必要的外部调用，特别是在批量处理交易时。</li>
</ul>
<p><strong>优化建议</strong>：</p>
<ul>
<li>如果可以的话，尽量将外部调用放在合约内部的逻辑执行之后，避免频繁的状态更新和合约间的交互。</li>
</ul>
<h4 id="3-批量处理操作（Batch-Processing）"><a href="#3-批量处理操作（Batch-Processing）" class="headerlink" title="3. 批量处理操作（Batch Processing）"></a>3. <strong>批量处理操作（Batch Processing）</strong></h4><ul>
<li>在处理多笔交易时，尽量将多个操作合并为一个操作。例如，通过批量转账代替逐个转账，可以节省大量 Gas。</li>
</ul>
<p><strong>优化建议</strong>：</p>
<ul>
<li>对于需要重复执行的操作，尝试使用循环一次性处理多个数据，而不是多次调用函数。例如，批量处理多个地址的代币转账。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">function batchTransfer(address[] memory recipients, uint256[] memory amounts) public &#123;<br>    require(recipients.length == amounts.length, &quot;Mismatched input arrays&quot;);<br>    for (uint256 i = 0; i &lt; recipients.length; i++) &#123;<br>        transfer(recipients[i], amounts[i]);  // 每个转账只调用一次<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h4 id="4-避免频繁修改-mapping-和-array"><a href="#4-避免频繁修改-mapping-和-array" class="headerlink" title="4. 避免频繁修改 mapping 和 array"></a>4. <strong>避免频繁修改 <code>mapping</code> 和 <code>array</code></strong></h4><ul>
<li>频繁修改 <code>mapping</code> 或 <code>array</code> 中的元素非常昂贵，尤其是在合约状态变动频繁时。尽量避免在循环或多个步骤中对这些数据结构进行重复的读取和写入。</li>
</ul>
<p><strong>优化建议</strong>：</p>
<ul>
<li>使用合适的数据结构来减少操作次数。如果可能，将多个操作合并为一个函数，并尽量减少存储操作的频率。</li>
</ul>
<h4 id="5-使用-view-和-pure-函数优化-Gas"><a href="#5-使用-view-和-pure-函数优化-Gas" class="headerlink" title="5. 使用 view 和 pure 函数优化 Gas"></a>5. <strong>使用 <code>view</code> 和 <code>pure</code> 函数优化 Gas</strong></h4><ul>
<li><code>view</code> 和 <code>pure</code> 函数是不会修改区块链状态的函数，调用这些函数不会消耗 Gas，因为它们不需要进行交易或状态更改。</li>
</ul>
<p><strong>优化建议</strong>：</p>
<ul>
<li>尽量将不涉及状态修改的函数标记为 <code>view</code> 或 <code>pure</code>，以节省 Gas。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">function getBalance() public view returns (uint256) &#123;<br>    return balances[msg.sender];  // 只读取状态，不消耗 Gas<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h4 id="6-避免使用-for-循环遍历大量数据"><a href="#6-避免使用-for-循环遍历大量数据" class="headerlink" title="6. 避免使用 for 循环遍历大量数据"></a>6. <strong>避免使用 <code>for</code> 循环遍历大量数据</strong></h4><ul>
<li>循环操作是另一种消耗大量 Gas 的常见原因，特别是在数据量大的时候。避免遍历大数据集，尤其是当这些数据需要进行状态更新时。</li>
</ul>
<p><strong>优化建议</strong>：</p>
<ul>
<li>将循环次数限制为合理的范围，避免大范围的状态修改。</li>
<li>使用事件记录数据（事件是轻量级的，不会消耗大量 Gas）而不是通过合约状态存储。</li>
</ul>
<h4 id="7-使用合适的-Solidity-数据类型"><a href="#7-使用合适的-Solidity-数据类型" class="headerlink" title="7. 使用合适的 Solidity 数据类型"></a>7. <strong>使用合适的 Solidity 数据类型</strong></h4><ul>
<li><strong>选择合适的数值类型</strong>：使用较小的数据类型（如 <code>uint8</code>、<code>uint16</code>）而不是默认的 <code>uint256</code>，可以节省存储空间和 Gas 成本。</li>
<li><strong>避免溢出或浪费空间</strong>：在设计合约时，确保使用的数据类型不会浪费存储空间。如果只需要 8 位的整数，使用 <code>uint8</code> 而不是 <code>uint256</code>。</li>
</ul>
<h4 id="8-优化-Gas-使用的其他技巧"><a href="#8-优化-Gas-使用的其他技巧" class="headerlink" title="8. 优化 Gas 使用的其他技巧"></a>8. <strong>优化 Gas 使用的其他技巧</strong></h4><ul>
<li><strong>将合约函数按需拆分</strong>：避免每个函数做过多的工作，拆分大函数为多个小函数，避免一次性执行过多操作。</li>
<li><strong>使用固定大小的数组</strong>：如果你知道数组的最大长度，使用固定大小的数组可以减少动态数组的 Gas 消耗。</li>
</ul>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>Gas 是以太坊智能合约执行过程中的资源消耗计量单位。优化 Gas 使用是开发高效智能合约的关键。通过减少存储操作、合并交易、合理使用 <code>view</code> 和 <code>pure</code> 函数、避免频繁的外部调用和循环，可以显著降低 Gas 成本。此外，使用代理合约和其他优化技巧可以帮助减少交易和调用的 Gas 消耗，从而提高智能合约的效率和经济性。</p>
<h1 id="7-请解释一下什么是-modifier，它在-Solidity-中有什么作用？"><a href="#7-请解释一下什么是-modifier，它在-Solidity-中有什么作用？" class="headerlink" title="7. 请解释一下什么是 modifier，它在 Solidity 中有什么作用？"></a>7. 请解释一下什么是 modifier，它在 Solidity 中有什么作用？</h1><p>你能举一个例子说明如何在智能合约中使用 modifier 吗？</p>
<p>modifier是函数修饰器，它检查是否符合执行条件，在符合的时候才执行函数。类似于门卫。</p>
<p>你的理解是正确的！<code>modifier</code> 在 Solidity 中确实类似于函数修饰器，它的作用是用来检查一些条件，只有在满足条件时，才允许执行某个函数。它可以帮助你在合约中实现代码复用、权限控制等功能，减少重复代码并提高合约的安全性和可维护性。</p>
<h3 id="modifier-的作用"><a href="#modifier-的作用" class="headerlink" title="modifier 的作用"></a><strong><code>modifier</code> 的作用</strong></h3><ol>
<li><strong>条件检查</strong>：在函数执行前检查某些条件是否满足，如果不满足，则函数不会执行。例如，检查账户余额、是否为合约拥有者等。</li>
<li><strong>代码复用</strong>：通过在多个函数中使用相同的 <code>modifier</code>，你可以避免在每个函数中重复编写相同的逻辑。</li>
<li><strong>权限控制</strong>：通常用来实现权限控制，例如确保只有合约的拥有者或特定角色才能调用某些函数。</li>
</ol>
<h3 id="modifier-的语法"><a href="#modifier-的语法" class="headerlink" title="modifier 的语法"></a><strong><code>modifier</code> 的语法</strong></h3><p><code>modifier</code> 的定义一般使用 <code>modifier</code> 关键字，然后后面跟上需要执行的逻辑和检查的条件。最后，使用 <code>_;</code> 表示在条件满足时，继续执行函数的主体部分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">modifier modifierName &#123;<br>    // 进行条件检查<br>    _;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><code>_;</code> 是 <code>modifier</code> 的占位符，表示“在此处插入函数体的代码”。在 <code>modifier</code> 中，如果条件没有满足，可以使用 <code>revert()</code> 来停止函数执行，并返回错误信息。</p>
<h3 id="使用-modifier-的例子"><a href="#使用-modifier-的例子" class="headerlink" title="使用 modifier 的例子"></a><strong>使用 <code>modifier</code> 的例子</strong></h3><h4 id="示例-1：权限控制"><a href="#示例-1：权限控制" class="headerlink" title="示例 1：权限控制"></a><strong>示例 1：权限控制</strong></h4><p>一个常见的 <code>modifier</code> 用法是检查某个函数是否只能由合约的拥有者调用。例如，只有合约的拥有者才可以修改合约的状态变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">pragma solidity ^0.8.0;<br><br>contract Owned &#123;<br>    address public owner;<br><br>    // 合约的构造函数，设置合约拥有者<br>    constructor() &#123;<br>        owner = msg.sender;<br>    &#125;<br><br>    // modifier: 只有合约的拥有者可以执行<br>    modifier onlyOwner() &#123;<br>        require(msg.sender == owner, &quot;You are not the owner&quot;);<br>        _;<br>    &#125;<br><br>    // 仅合约拥有者可以调用的函数<br>    function changeOwner(address newOwner) public onlyOwner &#123;<br>        owner = newOwner;<br>    &#125;<br><br>    // 任何人都可以调用的公共函数<br>    function getOwner() public view returns (address) &#123;<br>        return owner;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>在这个例子中，<code>onlyOwner</code> 是一个 <code>modifier</code>，它检查调用者的地址是否是合约的拥有者（<code>msg.sender == owner</code>）。如果条件不满足，<code>require</code> 会抛出错误并停止执行。如果条件满足，则会继续执行函数体（<code>_;</code>）。</p>
<ul>
<li><strong><code>changeOwner</code> 函数</strong>：该函数只能由合约拥有者调用，若非拥有者调用，则会被 <code>onlyOwner</code> modifier 拒绝。</li>
<li><strong><code>getOwner</code> 函数</strong>：任何人都可以调用，用于查看合约的拥有者地址。</li>
</ul>
<h4 id="示例-2：检查余额"><a href="#示例-2：检查余额" class="headerlink" title="示例 2：检查余额"></a><strong>示例 2：检查余额</strong></h4><p>另一个常见的例子是检查合约调用者的余额是否足够，才能执行某个操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">pragma solidity ^0.8.0;<br><br>contract Bank &#123;<br>    mapping(address =&gt; uint) public balances;<br><br>    // 存款函数<br>    function deposit() public payable &#123;<br>        balances[msg.sender] += msg.value;<br>    &#125;<br><br>    // modifier: 检查是否有足够余额<br>    modifier hasEnoughBalance(uint _amount) &#123;<br>        require(balances[msg.sender] &gt;= _amount, &quot;Insufficient balance&quot;);<br>        _;<br>    &#125;<br><br>    // 提现函数，只有在余额足够时才能执行<br>    function withdraw(uint _amount) public hasEnoughBalance(_amount) &#123;<br>        balances[msg.sender] -= _amount;<br>        payable(msg.sender).transfer(_amount);<br>    &#125;<br><br>    // 查询账户余额<br>    function getBalance() public view returns (uint) &#123;<br>        return balances[msg.sender];<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>在这个例子中，<code>hasEnoughBalance</code> 是一个 <code>modifier</code>，它确保调用者的余额大于或等于请求提现的金额。如果余额不足，<code>require</code> 会阻止操作。如果余额足够，操作会继续执行。</p>
<ul>
<li><strong><code>withdraw</code> 函数</strong>：在调用时，会首先检查调用者是否有足够的余额。如果没有，操作会被终止；如果有，函数会继续执行，从调用者账户中提取资金。</li>
</ul>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><strong><code>modifier</code></strong> 是一种 Solidity 的特性，用来封装一些复用逻辑（如权限控制、条件检查等），并且可以在函数执行前检查一些条件。</li>
<li><strong>用途</strong>：<code>modifier</code> 可以提高合约的安全性、减少重复代码，使得权限管理、条件验证等常见操作更加简洁和高效。</li>
<li><strong>基本语法</strong>：<code>modifier</code> 的基本结构是检查条件后使用 <code>_;</code> 继续执行函数的主体代码。</li>
</ul>
<p>通过使用 <code>modifier</code>，你可以让 Solidity 合约更灵活、更易于维护，并且提高合约的安全性。</p>
<h1 id="8-如何通过-Solidity-进行事件日志的记录？"><a href="#8-如何通过-Solidity-进行事件日志的记录？" class="headerlink" title="8. 如何通过 Solidity 进行事件日志的记录？"></a>8. 如何通过 Solidity 进行事件日志的记录？</h1><p>为什么在智能合约中使用事件，如何触发事件并在前端进行监听？</p>
<p>答：<br>event才能触发事件。例如在会员系统中，有注册事件，加分事件，升级事件。<br>必须要触发事件，才能运行。<br>至于在前端监听这块，我猜测是emit</p>
<p>你完全理解了！事件（<code>event</code>）在 Solidity 中是非常重要的，它们允许智能合约将一些关键的操作或状态变化传递给区块链外部的应用（如前端应用）。通过事件，外部应用可以有效地跟踪和响应合约的状态变化，而不必轮询区块链的每一块数据。</p>
<h3 id="为什么使用事件？"><a href="#为什么使用事件？" class="headerlink" title="为什么使用事件？"></a><strong>为什么使用事件？</strong></h3><p>在智能合约中使用事件有以下几个原因：</p>
<ol>
<li><strong>日志记录</strong>：事件能够记录合约的关键操作，并在链外进行检索，类似于日志系统。通过事件，我们可以记录发生的操作，后续能够查看和追踪。</li>
<li><strong>优化 gas 成本</strong>：相较于存储数据，触发事件的 gas 成本较低。事件的日志数据会存储在以太坊的日志中，而不是直接存储在合约状态中，因此不会消耗过多的 gas。</li>
<li><strong>链外监听</strong>：通过事件，前端或其他应用可以方便地监听合约中的关键操作，并做出响应，而不需要频繁查询合约的状态。</li>
</ol>
<h3 id="如何在-Solidity-中触发事件？"><a href="#如何在-Solidity-中触发事件？" class="headerlink" title="如何在 Solidity 中触发事件？"></a><strong>如何在 Solidity 中触发事件？</strong></h3><p>在 Solidity 中，触发事件需要使用 <code>emit</code> 关键字来触发已经定义的事件。事件需要在合约中进行声明，并且在合约的相关操作中使用 <code>emit</code> 来触发事件。</p>
<h4 id="事件的声明和触发"><a href="#事件的声明和触发" class="headerlink" title="事件的声明和触发"></a><strong>事件的声明和触发</strong></h4><ol>
<li><p><strong>声明事件</strong><br>事件通常会在合约中声明，定义它所需的参数（可以是 <code>indexed</code> 或非 <code>indexed</code> 类型）。<code>indexed</code> 关键字可以让某个参数成为索引，从而使得该参数更容易在外部进行查询和监听。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">event EventName(address indexed user, uint256 amount, string message);<br></code></pre></div></td></tr></table></figure>

<p>在这个例子中，<code>EventName</code> 是事件的名称，它有三个参数：</p>
<ul>
<li><code>user</code> 是 <code>address</code> 类型的，表示用户地址，使用了 <code>indexed</code>，表示可以在外部查询时使用这个字段作为索引。</li>
<li><code>amount</code> 是 <code>uint256</code> 类型，表示某个金额。</li>
<li><code>message</code> 是 <code>string</code> 类型，用于存储额外的文本信息。</li>
</ul>
</li>
<li><p><strong>触发事件</strong><br>触发事件时，使用 <code>emit</code> 关键字来发送事件数据。这通常是在函数内部进行的操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">function registerUser(address user, uint256 amount, string memory message) public &#123;<br>    // 注册逻辑<br>    emit EventName(user, amount, message);  // 触发事件<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>在这个函数中，<code>registerUser</code> 函数会触发 <code>EventName</code> 事件，传递用户地址、金额和消息。</p>
</li>
</ol>
<h4 id="一个完整的例子：会员系统的事件"><a href="#一个完整的例子：会员系统的事件" class="headerlink" title="一个完整的例子：会员系统的事件"></a><strong>一个完整的例子：会员系统的事件</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">pragma solidity ^0.8.0;<br><br>contract Membership &#123;<br>    mapping(address =&gt; uint256) public points;<br>    address public owner;<br><br>    // 事件声明<br>    event Registered(address indexed user, uint256 points);<br>    event PointsAdded(address indexed user, uint256 points);<br>    event Upgraded(address indexed user, string level);<br><br>    constructor() &#123;<br>        owner = msg.sender;<br>    &#125;<br><br>    // 注册函数<br>    function register(address user) public &#123;<br>        require(msg.sender == owner, &quot;Only owner can register users&quot;);<br>        points[user] = 0;<br>        emit Registered(user, 0);  // 触发注册事件<br>    &#125;<br><br>    // 加分函数<br>    function addPoints(address user, uint256 amount) public &#123;<br>        require(msg.sender == owner, &quot;Only owner can add points&quot;);<br>        points[user] += amount;<br>        emit PointsAdded(user, amount);  // 触发加分事件<br>    &#125;<br><br>    // 升级函数<br>    function upgrade(address user) public &#123;<br>        require(msg.sender == owner, &quot;Only owner can upgrade users&quot;);<br>        string memory level = (points[user] &gt;= 100) ? &quot;Gold&quot; : &quot;Silver&quot;;<br>        emit Upgraded(user, level);  // 触发升级事件<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>在这个例子中，<code>Membership</code> 合约有三个事件：</p>
<ul>
<li><code>Registered</code>：在用户注册时触发。</li>
<li><code>PointsAdded</code>：在用户加分时触发。</li>
<li><code>Upgraded</code>：在用户升级时触发。</li>
</ul>
<h3 id="如何在前端监听-Solidity-事件"><a href="#如何在前端监听-Solidity-事件" class="headerlink" title="如何在前端监听 Solidity 事件"></a><strong>如何在前端监听 Solidity 事件</strong></h3><ol>
<li><p><strong>监听事件</strong><br>在前端，使用 Web3.js 或 Ethers.js 等库来监听这些事件。Web3.js 和 Ethers.js 提供了 <code>on</code> 方法，可以让前端应用实时监听合约中触发的事件。</p>
<p>下面是如何在前端使用 Web3.js 监听 <code>Registered</code> 事件的一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 使用 Web3.js 连接到合约</span><br><span class="hljs-keyword">const</span> web3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Web3</span>(<span class="hljs-title class_">Web3</span>.<span class="hljs-property">givenProvider</span> || <span class="hljs-string">&quot;http://localhost:8545&quot;</span>);<br><br><span class="hljs-keyword">const</span> contractAddress = <span class="hljs-string">&#x27;YOUR_CONTRACT_ADDRESS&#x27;</span>;<br><span class="hljs-keyword">const</span> abi = [<span class="hljs-comment">/* ABI Here */</span>];<br><br><span class="hljs-keyword">const</span> contract = <span class="hljs-keyword">new</span> web3.<span class="hljs-property">eth</span>.<span class="hljs-title class_">Contract</span>(abi, contractAddress);<br><br><span class="hljs-comment">// 监听事件</span><br>contract.<span class="hljs-property">events</span>.<span class="hljs-title class_">Registered</span>(&#123; <span class="hljs-attr">fromBlock</span>: <span class="hljs-number">0</span> &#125;, <span class="hljs-function">(<span class="hljs-params">error, event</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (error) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;User registered:&quot;</span>, event.<span class="hljs-property">returnValues</span>);<br>    &#125;<br>&#125;);<br></code></pre></div></td></tr></table></figure>

<ul>
<li><code>contract.events.Registered</code>：监听 <code>Registered</code> 事件。</li>
<li><code>fromBlock: 0</code>：从区块链的第一个区块开始监听事件。</li>
<li><code>event.returnValues</code>：包含事件触发时传递的所有数据（如 <code>user</code> 和 <code>points</code>）。</li>
</ul>
</li>
<li><p><strong>Ethers.js 监听事件</strong><br>如果你使用的是 Ethers.js，可以使用 <code>on</code> 方法监听事件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> provider = <span class="hljs-keyword">new</span> ethers.<span class="hljs-property">providers</span>.<span class="hljs-title class_">Web3Provider</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">ethereum</span>);<br><span class="hljs-keyword">const</span> signer = provider.<span class="hljs-title function_">getSigner</span>();<br><span class="hljs-keyword">const</span> contract = <span class="hljs-keyword">new</span> ethers.<span class="hljs-title class_">Contract</span>(contractAddress, abi, signer);<br><br>contract.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;Registered&quot;</span>, <span class="hljs-function">(<span class="hljs-params">user, points</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`User <span class="hljs-subst">$&#123;user&#125;</span> registered with <span class="hljs-subst">$&#123;points&#125;</span> points`</span>);<br>&#125;);<br></code></pre></div></td></tr></table></figure>

<p>这段代码会监听 <code>Registered</code> 事件并在事件触发时打印用户的地址和积分。</p>
</li>
</ol>
<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><strong>事件</strong>（<code>event</code>）用于在 Solidity 合约中记录和发布关键操作，外部应用（如前端）可以监听这些事件来响应合约的状态变化。</li>
<li><strong>触发事件</strong> 使用 <code>emit</code> 关键字，可以传递需要记录的数据。</li>
<li><strong>前端监听</strong> 通过 Web3.js 或 Ethers.js 监听合约中的事件，可以实时获取事件数据并进行处理。</li>
<li>使用事件可以有效减少存储成本、提高数据访问效率，并且让外部应用能够及时响应合约中的变化。</li>
</ul>
<h1 id="9-Solidity-中的-view-和-pure-函数有什么区别？"><a href="#9-Solidity-中的-view-和-pure-函数有什么区别？" class="headerlink" title="9. Solidity 中的 view 和 pure 函数有什么区别？"></a>9. Solidity 中的 view 和 pure 函数有什么区别？</h1><p>它们的主要区别是什么？在什么情况下会使用这两种函数类型？</p>
<p>在 Solidity 中，<code>view</code> 和 <code>pure</code> 是两种不同的函数修饰符（modifier），它们用于表示函数的行为，并影响函数的执行方式和 Gas 消耗。</p>
<h3 id="view-函数"><a href="#view-函数" class="headerlink" title="view 函数"></a><strong><code>view</code> 函数</strong></h3><p><code>view</code> 函数是指该函数不会修改合约的状态，也不会发出交易。它只允许读取合约的状态变量或者获取合约中的数据。<code>view</code> 函数的核心特征是它 <strong>只能读取合约的存储数据</strong>，但不能修改任何数据。</p>
<ul>
<li><p><strong>特点</strong>：</p>
<ul>
<li>只能读取合约的状态变量。</li>
<li>不能修改合约的任何状态（即不能调用 <code>storage</code> 写操作）。</li>
<li>不会消耗 Gas，除非它被外部调用者（如交易所、前端）作为交易的一部分执行。</li>
<li>可以从其他合约读取状态数据，或执行逻辑计算，但不能改变任何合约的存储数据。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>：<br><code>view</code> 函数通常用于获取合约的状态数据，像是余额查询、获取当前状态、获取存储值等操作。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">pragma solidity ^0.8.0;<br><br>contract Example &#123;<br>    uint256 public value;<br><br>    // 设置值<br>    function setValue(uint256 _value) public &#123;<br>        value = _value;<br>    &#125;<br><br>    // 读取值 - 这个函数是 view 类型<br>    function getValue() public view returns (uint256) &#123;<br>        return value;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>在上面的代码中，<code>getValue</code> 函数是 <code>view</code> 类型的，它仅用于读取合约的状态变量 <code>value</code>，不会修改任何数据，因此可以标记为 <code>view</code>。</p>
</li>
</ul>
<h3 id="pure-函数"><a href="#pure-函数" class="headerlink" title="pure 函数"></a><strong><code>pure</code> 函数</strong></h3><p><code>pure</code> 函数是指该函数 <strong>既不读取也不修改合约的状态</strong>，它不依赖于合约中的任何存储数据（即 <code>storage</code> 或 <code>memory</code>）。<code>pure</code> 函数只能执行计算操作并返回结果，它 <strong>不允许访问合约的状态</strong>，包括状态变量、其他函数的输出等。</p>
<ul>
<li><p><strong>特点</strong>：</p>
<ul>
<li>不读取合约的存储数据。</li>
<li>不修改合约的任何状态。</li>
<li>通常用于计算或处理某些逻辑，无需与区块链的状态交互。</li>
<li>不会消耗 Gas（除非被作为交易的一部分调用）。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>：<br><code>pure</code> 函数通常用于实现一些纯粹的计算逻辑，比如数学计算或数据处理，这些操作与合约的状态无关。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">pragma solidity ^0.8.0;<br><br>contract Example &#123;<br>    // 计算两个数字的和 - 这个函数是 pure 类型<br>    function add(uint256 a, uint256 b) public pure returns (uint256) &#123;<br>        return a + b;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>在这个示例中，<code>add</code> 函数是 <code>pure</code> 类型的，它仅执行简单的数学操作，完全不依赖合约的任何状态数据，因此被标记为 <code>pure</code>。</p>
</li>
</ul>
<h3 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a><strong>主要区别</strong></h3><table>
<thead>
<tr>
<th>特性</th>
<th><code>view</code> 函数</th>
<th><code>pure</code> 函数</th>
</tr>
</thead>
<tbody><tr>
<td><strong>对合约状态的作用</strong></td>
<td>只能读取合约的状态变量，但不能修改。</td>
<td>不能读取或修改合约的任何状态。</td>
</tr>
<tr>
<td><strong>访问状态数据</strong></td>
<td>可以访问合约中的状态变量（<code>storage</code>）。</td>
<td>完全不能访问合约的状态数据。</td>
</tr>
<tr>
<td><strong>Gas 消耗</strong></td>
<td>读取状态数据时不消耗 Gas，但执行时会消耗 Gas（如果在交易中调用）。</td>
<td>不消耗 Gas（仅执行计算逻辑）。</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>用于查询合约状态或返回合约存储的数据。</td>
<td>用于纯粹的计算或返回无状态的结果。</td>
</tr>
</tbody></table>
<h3 id="何时使用-view-和-pure-函数"><a href="#何时使用-view-和-pure-函数" class="headerlink" title="何时使用 view 和 pure 函数"></a><strong>何时使用 <code>view</code> 和 <code>pure</code> 函数</strong></h3><ul>
<li><p><strong><code>view</code> 函数</strong>：当你需要访问合约的状态数据（例如，余额、合约的状态变量等）并返回它时，使用 <code>view</code>。如果函数仅用于读取存储而不修改存储，这时就应该使用 <code>view</code> 修饰符。</p>
<p><strong>示例</strong>：获取合约某个状态变量的值，查询账户余额等。</p>
</li>
<li><p><strong><code>pure</code> 函数</strong>：当你执行的操作与合约的状态完全无关，并且只是进行一些计算或返回数据时，使用 <code>pure</code>。通常，<code>pure</code> 函数适用于那些不需要与区块链状态交互的纯计算逻辑。</p>
<p><strong>示例</strong>：执行数学运算、字符串操作等。</p>
</li>
</ul>
<h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li>**<code>view</code>**：用于读取合约的状态，但不修改它。适合用于返回合约的存储数据（例如余额、状态等）。</li>
<li>**<code>pure</code>**：用于进行不依赖于合约状态的计算。适合纯粹的计算任务，不与区块链的存储进行交互。</li>
</ul>
<p>这些修饰符有助于清晰地定义函数的行为和优化 Gas 成本。在编写 Solidity 合约时，合理使用 <code>view</code> 和 <code>pure</code> 可以提高合约的可读性、可维护性，并减少不必要的 Gas 支出。</p>
<h1 id="10-在-Solidity-中，如何处理合约的权限管理？"><a href="#10-在-Solidity-中，如何处理合约的权限管理？" class="headerlink" title="10. 在 Solidity 中，如何处理合约的权限管理？"></a>10. 在 Solidity 中，如何处理合约的权限管理？</h1><p>比如，如何实现只有合约拥有者才能执行某些特定操作的功能？<br>答：<br>require(msg.owner) 这样设置只有合约拥有者才能执行功能</p>
<p>你提到的 <code>require(msg.owner)</code> 接近了权限管理的实现思路，但需要做一些调整来正确实现。要在 Solidity 中实现权限管理，特别是确保只有合约的拥有者才能执行特定的操作，通常需要依赖合约中存储的拥有者地址，并在需要时进行检查。</p>
<h3 id="合约权限管理的实现方法"><a href="#合约权限管理的实现方法" class="headerlink" title="合约权限管理的实现方法"></a><strong>合约权限管理的实现方法</strong></h3><ol>
<li><p><strong>存储合约拥有者的地址</strong><br>通常，合约的拥有者地址会在合约部署时由构造函数设置。这个地址会被存储在合约中，并在之后的操作中进行检查。</p>
</li>
<li><p><strong>通过 <code>require</code> 检查是否为拥有者</strong><br>使用 <code>require</code> 语句来检查调用者（<code>msg.sender</code>）是否是合约的拥有者地址。如果不是，则拒绝执行相关操作。</p>
</li>
</ol>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a><strong>步骤</strong></h3><ol>
<li><strong>定义拥有者地址</strong>：通过合约的构造函数来设置合约的拥有者地址。</li>
<li><strong>权限检查</strong>：在需要权限控制的函数中，使用 <code>require(msg.sender == owner)</code> 来检查当前调用者是否是拥有者。</li>
</ol>
<h3 id="示例代码：权限管理"><a href="#示例代码：权限管理" class="headerlink" title="示例代码：权限管理"></a><strong>示例代码：权限管理</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">pragma solidity ^0.8.0;<br><br>contract Owned &#123;<br>    address public owner;<br><br>    // 合约构造函数，设置合约的拥有者<br>    constructor() &#123;<br>        owner = msg.sender;  // 部署合约的账户就是拥有者<br>    &#125;<br><br>    // modifier: 只有合约的拥有者可以执行<br>    modifier onlyOwner() &#123;<br>        require(msg.sender == owner, &quot;You are not the owner&quot;);  // 检查调用者是否是拥有者<br>        _;<br>    &#125;<br><br>    // 仅合约拥有者可以调用的函数<br>    function changeOwner(address newOwner) public onlyOwner &#123;<br>        owner = newOwner;<br>    &#125;<br><br>    // 查询合约拥有者<br>    function getOwner() public view returns (address) &#123;<br>        return owner;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a><strong>解释</strong></h3><ol>
<li><strong><code>owner</code> 变量</strong>：合约的拥有者地址存储在 <code>owner</code> 变量中。在合约部署时，<code>msg.sender</code> 会被设置为合约的拥有者。</li>
<li><strong><code>onlyOwner</code> 修饰符</strong>：这是一个自定义的 <code>modifier</code>，用于检查函数调用者是否为合约拥有者。<code>msg.sender</code> 表示当前调用函数的地址，如果这个地址与 <code>owner</code> 不匹配，<code>require</code> 会抛出异常，阻止函数执行。</li>
<li><strong><code>changeOwner</code> 函数</strong>：只有拥有者可以执行此函数，修改合约的拥有者地址。使用 <code>onlyOwner</code> 修饰符来确保只有合约拥有者可以调用该函数。</li>
<li><strong><code>getOwner</code> 函数</strong>：允许任何人查看当前合约的拥有者地址。</li>
</ol>
<h3 id="权限管理的其他常见策略"><a href="#权限管理的其他常见策略" class="headerlink" title="权限管理的其他常见策略"></a><strong>权限管理的其他常见策略</strong></h3><ul>
<li><p><strong>多重签名（Multisignature）</strong>：有时一个合约可能不只依赖一个拥有者，而是需要多个签名者才能执行某些重要操作。通过这种方式，可以增加合约的安全性，避免单点故障。</p>
<p>例如，可以通过存储多个地址来实现多重签名机制，只有在多个地址的批准下才能执行某些操作。</p>
</li>
<li><p><strong>角色和权限管理</strong>：合约的权限管理不仅仅是简单的“拥有者”控制，可能还需要更细粒度的权限控制。例如，不同角色（如管理员、用户、审核员等）可以执行不同的操作。可以使用 <code>mapping</code> 来为不同的地址分配不同的角色，并通过 <code>modifier</code> 来检查角色权限。</p>
</li>
</ul>
<h3 id="扩展：使用-OpenZeppelin-的-Ownable-合约"><a href="#扩展：使用-OpenZeppelin-的-Ownable-合约" class="headerlink" title="扩展：使用 OpenZeppelin 的 Ownable 合约"></a><strong>扩展：使用 OpenZeppelin 的 Ownable 合约</strong></h3><p>如果你希望使用现成的、安全的权限管理功能，OpenZeppelin 提供了一个 <code>Ownable</code> 合约，可以轻松实现合约拥有者控制。它已经封装好了权限管理的逻辑。</p>
<h4 id="OpenZeppelin-Ownable-示例"><a href="#OpenZeppelin-Ownable-示例" class="headerlink" title="OpenZeppelin Ownable 示例"></a><strong>OpenZeppelin Ownable 示例</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">// 引入 OpenZeppelin 的 Ownable 合约<br>import &quot;@openzeppelin/contracts/access/Ownable.sol&quot;;<br><br>contract MyContract is Ownable &#123;<br>    uint256 public data;<br><br>    // 只有拥有者可以调用<br>    function setData(uint256 _data) public onlyOwner &#123;<br>        data = _data;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>在这个例子中，<code>Ownable</code> 合约提供了 <code>onlyOwner</code> 修饰符，它自动帮助你处理了合约拥有者的管理和权限检查。你只需要继承 <code>Ownable</code> 合约，就能使用这些功能，而不需要自己编写权限管理的代码。</p>
<h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li>在 Solidity 中，权限管理通常通过存储合约拥有者的地址并使用 <code>require(msg.sender == owner)</code> 来实现。</li>
<li>自定义 <code>modifier</code> 如 <code>onlyOwner</code> 可以帮助检查调用者是否具备权限执行特定操作。</li>
<li>OpenZeppelin 提供了一个强大的 <code>Ownable</code> 合约，可以简化权限管理，推荐在项目中使用。</li>
</ul>
<h1 id="ERC20-ERC721-合约有什么区别？"><a href="#ERC20-ERC721-合约有什么区别？" class="headerlink" title="ERC20/ERC721 合约有什么区别？"></a>ERC20/ERC721 合约有什么区别？</h1><p>ERC20 和 ERC721 是两种常见的以太坊智能合约标准，它们的主要区别在于它们的代币类型和用途：</p>
<h3 id="ERC20-标准："><a href="#ERC20-标准：" class="headerlink" title="ERC20 标准："></a>ERC20 标准：</h3><ul>
<li><p><strong>代币类型</strong>：<strong>可替代代币（Fungible Tokens）</strong>。每个代币单位是相同的，彼此没有区别。例如，一个 ERC20 代币中的 1 单位代币和另一个 1 单位代币完全相同，可以互换。</p>
</li>
<li><p><strong>常见用途</strong>：通常用于创建货币型代币，如 DAI、USDT 等稳定币，或是项目的原生代币（如项目的筹款代币）。</p>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li><code>totalSupply()</code>: 返回代币的总供应量。</li>
<li><code>balanceOf(address account)</code>: 查询某个地址持有的代币数量。</li>
<li><code>transfer(address recipient, uint256 amount)</code>: 转账指定数量的代币。</li>
<li><code>approve(address spender, uint256 amount)</code>: 允许指定的地址花费一定数量的代币。</li>
<li><code>transferFrom(address sender, address recipient, uint256 amount)</code>: 从一个地址转账到另一个地址。</li>
</ul>
</li>
</ul>
<h3 id="ERC721-标准："><a href="#ERC721-标准：" class="headerlink" title="ERC721 标准："></a>ERC721 标准：</h3><ul>
<li><p><strong>代币类型</strong>：<strong>不可替代代币（Non-Fungible Tokens, NFT）</strong>。每个代币都是唯一的，可以代表独一无二的资产，如艺术品、收藏品或其他唯一的物品。</p>
</li>
<li><p><strong>常见用途</strong>：用于数字艺术、游戏物品、房地产等需要唯一标识的资产。例如，CryptoKitties、CryptoPunks、土地和其他数字物品都可以通过 ERC721 实现。</p>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li><code>ownerOf(uint256 tokenId)</code>: 查询某个代币 ID 所属的地址。</li>
<li><code>safeTransferFrom(address from, address to, uint256 tokenId)</code>: 安全转移指定 tokenId 的代币。</li>
<li><code>approve(address to, uint256 tokenId)</code>: 授权指定地址管理某个 tokenId。</li>
<li><code>getApproved(uint256 tokenId)</code>: 查询某个 tokenId 的批准地址。</li>
<li><code>setApprovalForAll(address operator, bool approved)</code>: 授权某个地址管理用户所有的代币。</li>
</ul>
</li>
</ul>
<h3 id="主要区别总结："><a href="#主要区别总结：" class="headerlink" title="主要区别总结："></a>主要区别总结：</h3><ul>
<li><strong>ERC20</strong>：代币是相同的，每个单位都是一样的，适合表示货币或积分等。</li>
<li><strong>ERC721</strong>：每个代币都是唯一的，适合表示独一无二的物品（如艺术品、收藏品、游戏物品等）。</li>
</ul>
<p>因此，ERC20 适用于传统的货币型代币，而 ERC721 适用于代表唯一物品的数字资产。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Web3/">Web3</a>
                    
                  </div>
                
              </div>
              
                
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/11/17/378601e5cdea/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">copilot</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/11/17/9e37fb976f40/">
                        <span class="hidden-mobile">我的生平（二十二）</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


            

                
                  <a id="scroll-top-button" href="#" role="button">
                    <i class="iconfont icon-arrowup" aria-hidden="true"></i>
                  </a>
                  

                    

                          
      </main>

      <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://whale3070.github.io/" target="_blank" rel="nofollow noopener"><span>Whale3070</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<link href="/pagefind/pagefind-ui.css" rel="stylesheet">
  <script src="/pagefind/pagefind-ui.js"></script>
  <style>
    /* 搜索框配色适配 */
    #search { margin-top: 2rem; }
    [data-user-color-scheme='dark'] .pagefind-ui {
      --pagefind-ui-primary: #eeeeee;
      --pagefind-ui-text: #eeeeee;
      --pagefind-ui-background: #151515;
      --pagefind-ui-border: #333;
    }
  </style>
    </body>

  </html>