

  <!DOCTYPE html>
  <html lang="zh-CN" data-default-color-scheme=&#34;dark&#34; >
  <style>
    .text1
    {
    text-shadow: 0px 0px 2px #f2f3f2;
    }
    </style>

  <script>
    // 强制内网 IP 识别为安全上下文
    if (window.location.hostname !== 'localhost' && window.location.protocol === 'http:') {
        // 尝试手动映射 crypto 属性
        if (!window.crypto.subtle && window.crypto.webkitSubtle) {
            window.crypto.subtle = window.crypto.webkitSubtle;
        }
    }
    
    // 终极补丁：如果还是没有 subtle，则创建一个占位符避免报错
    // 提示：这通常能解决加载报错，但如果插件强依赖原生加密，建议执行下面的“降级”预判
    if (!window.isSecureContext) {
        console.warn('当前环境非安全上下文，正在尝试兼容内网加密解密...');
    }
</script>


<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/null">
  <link rel="icon" type="image/png" href="/null">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>cryptozombies - whale3070&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.4.0/styles/github-gist.min.css" />
    
  

  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"whale3070.github.io","root":"/","version":"1.8.7","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":false,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 7.3.0"></head>


    <body>
      <header style="height: 70vh;">
        <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>InfoSec learning</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/search/">
                <i class="iconfont icon-search"></i>
                搜索
              </a>
            </li>
          
        
        
        
          
        
      </ul>
    </div>
  </div>
</nav>

          <div class="banner" id="banner" false
            style="background: url('/img/default.png') no-repeat center center;
              background-size: cover;">
              <div class="full-bg-img">
                <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
                  <div class="page-header text-center fade-in-up">
                    <span class="h2 text1" id="subtitle" title="cryptozombies">
                      
                        cryptozombies
                      
                    </span>
        
                    
                      <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2025-11-20 13:17" pubdate>
        2025年11月20日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      5.6k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      64
       分钟
    </span>
  

  
  
</div>

                    
                  </div>
                    
                  </div>
                  
                </div>
              </div>
          </div>
      </header>

      <main>
        
          

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" data-pagefind-body>
            <!-- SEO header -->
            <h1 style="display: none">cryptozombies</h1>
            
            <div class="markdown-body">
              <p>网站： <a target="_blank" rel="noopener" href="https://cryptozombies.io/">https://cryptozombies.io/</a><br>是一个学习solidity的教学网站，英语的。<br>可以一边学英语一边学solidity开发。</p>
<p>状态变量state 变量将会永久存储在以太坊链上<br>Unsigned Integers无符号整数</p>
<h1 id="英语中，如何表达次方"><a href="#英语中，如何表达次方" class="headerlink" title="英语中，如何表达次方"></a>英语中，如何表达次方</h1><p>to the power of (最正式、最标准)</p>
<p>10 to the power of 3 (10的3次方)</p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组分为固定数组和动态数组</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-comment">// Array with a fixed length of 2 elements:</span><br><span class="hljs-built_in">uint</span>[<span class="hljs-number">2</span>] fixedArray;<br><span class="hljs-comment">// another fixed Array, can contain 5 strings:</span><br><span class="hljs-built_in">string</span>[<span class="hljs-number">5</span>] <span class="hljs-built_in">string</span>Array;<br><span class="hljs-comment">// a dynamic Array - has no fixed size, can keep growing:</span><br><span class="hljs-built_in">uint</span>[] dynamicArray;<br></code></pre></div></td></tr></table></figure>

<p>你可以创建一个公开public数组，solidity编译器会自动创建一个getter方法</p>
<p>变量声明解析</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">// 定义结构体</span><br><span class="hljs-keyword">struct</span> Person &#123;<br>    <span class="hljs-built_in">string</span> name;<br>    <span class="hljs-built_in">uint</span> age;<br>&#125;<br><br><span class="hljs-comment">// 声明数组</span><br>Person[] <span class="hljs-keyword">public</span> people;  <span class="hljs-comment">// people 就是数组的名字</span><br></code></pre></div></td></tr></table></figure>

<p><code>Person[] public people;</code><br>Person[]: 这是一个类型声明，表示这是一个 Person 类型的数组<br>public: 可见性修饰符，表示这个变量可以被外部访问<br>people: 这是变量名，也就是你给这个数组起的名字</p>
<p>数组不一定非要和结构体有关，它们可以存储任何数据类型。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-comment">// 基本类型的数组</span><br><span class="hljs-built_in">uint</span>[] <span class="hljs-keyword">public</span> numbers;        <span class="hljs-comment">// 整数数组</span><br><span class="hljs-built_in">string</span>[] <span class="hljs-keyword">public</span> names;        <span class="hljs-comment">// 字符串数组</span><br>address[] <span class="hljs-keyword">public</span> wallets;     <span class="hljs-comment">// 地址数组</span><br><span class="hljs-built_in">bool</span>[] <span class="hljs-keyword">public</span> flags;          <span class="hljs-comment">// 布尔值数组</span><br></code></pre></div></td></tr></table></figure>

<h1 id="第11章：Keccak256-与类型转换"><a href="#第11章：Keccak256-与类型转换" class="headerlink" title="第11章：Keccak256 与类型转换"></a>第11章：Keccak256 与类型转换</h1><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">uint <span class="hljs-built_in">rand</span> = unit(keccak256(abi.encodePacked(_str)));<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">rand</span> <span class="hljs-comment">% dnaModulus;</span><br></code></pre></div></td></tr></table></figure>

<p>我来解释这段Solidity代码：</p>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">uint rand = uint(keccak256(abi.encodePacked(&quot;_str&quot;)));<br>return rand % dnaModulus;<br></code></pre></div></td></tr></table></figure>

<h3 id="1-随机数生成过程"><a href="#1-随机数生成过程" class="headerlink" title="1. 随机数生成过程"></a>1. 随机数生成过程</h3><p><strong><code>abi.encodePacked(&quot;_str&quot;)</code></strong></p>
<ul>
<li>将字符串 “_str” 进行紧凑编码（不添加填充字节）</li>
<li>返回 <code>bytes</code> 类型的数据</li>
</ul>
<p><strong><code>keccak256(...)</code></strong></p>
<ul>
<li>对编码后的数据进行Keccak-256哈希计算</li>
<li>返回32字节的哈希值（<code>bytes32</code>类型）</li>
</ul>
<p><strong><code>uint(...)</code></strong></p>
<ul>
<li>将哈希结果转换为无符号整数（uint256）</li>
<li>将32字节的哈希值解释为一个非常大的整数</li>
</ul>
<p><strong><code>% dnaModulus</code></strong></p>
<ul>
<li>对生成的随机数取模，限制在特定范围内</li>
<li><code>dnaModulus</code> 通常是一个定义范围的除数</li>
</ul>
<p>这种模式常用于：</p>
<ul>
<li>生成伪随机DNA或特征值</li>
<li>创建基于输入的确定性但看似随机的标识符</li>
<li>游戏中的随机元素生成</li>
</ul>
<p><strong>注意：</strong> 在区块链上无法获得真正的随机数，所有”随机”都是伪随机且可预测的。</p>
<h2 id="对生成的随机数取模是什么意思"><a href="#对生成的随机数取模是什么意思" class="headerlink" title="对生成的随机数取模是什么意思"></a>对生成的随机数取模是什么意思</h2><p>好的，这是一个非常核心的编程和数学概念。我用一个简单的方式来解释“对生成的随机数取模”是什么意思。</p>
<h3 id="一句话概括"><a href="#一句话概括" class="headerlink" title="一句话概括"></a>一句话概括</h3><p><strong>取模运算就是求余数。</strong> 对一个随机数取模，就是为了<strong>限制这个随机数的范围</strong>，让它最终落在一个你想要的区间内。</p>
<h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="1-什么是取模运算？"><a href="#1-什么是取模运算？" class="headerlink" title="1. 什么是取模运算？"></a>1. 什么是取模运算？</h4><p>符号是 <code>%</code>。它的作用是计算一个数除以另一个数后的<strong>余数</strong>。</p>
<ul>
<li><strong>例子：</strong><ul>
<li><code>7 % 3 = 1</code> （因为7除以3等于2，余1）</li>
<li><code>10 % 4 = 2</code> （因为10除以4等于2，余2）</li>
<li><code>15 % 5 = 0</code> （因为15除以5等于3，余0）</li>
</ul>
</li>
</ul>
<h4 id="2-为什么在随机数生成中要用取模？"><a href="#2-为什么在随机数生成中要用取模？" class="headerlink" title="2. 为什么在随机数生成中要用取模？"></a>2. 为什么在随机数生成中要用取模？</h4><p>在你提供的代码中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">uint rand = uint(keccak256(abi.encodePacked(&quot;_str&quot;))); // 这会产生一个巨大的随机数，比如 123456789...<br>return rand % dnaModulus; // 我们用取模来限制范围<br></code></pre></div></td></tr></table></figure>

<ul>
<li><strong>第一步产生的问题</strong>：<code>keccak256</code> 会生成一个非常非常大的随机数（范围从 0 到 2²⁵⁶ - 1）。这个范围太大了，通常不是我们想要的。</li>
<li><strong>第二步（取模）的目的</strong>：我们使用 <code>% dnaModulus</code> 把这个巨大的数字“压缩”到一个可控的范围内。</li>
</ul>
<p><strong>取模运算的关键特性：</strong><br><code>X % N</code> 的结果<strong>永远在 [0, N-1] 这个区间内</strong>。</p>
<h4 id="3-具体例子"><a href="#3-具体例子" class="headerlink" title="3. 具体例子"></a>3. 具体例子</h4><p>假设：</p>
<ul>
<li><code>keccak256(...)</code> 生成了一个巨大的随机数：<strong><code>123456</code></strong></li>
<li>你设定的 <code>dnaModulus = 100</code></li>
</ul>
<p>那么：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">123456 % 100 = 56<br></code></pre></div></td></tr></table></figure>
<p>最终返回的随机数就是 <strong>56</strong>。</p>
<p><strong>为什么是56？</strong></p>
<ul>
<li>因为 123456 除以 100 等于 1234 <strong>余 56</strong>。</li>
<li>由于除数是100，余数<strong>不可能大于等于100</strong>，所以结果被牢牢地限制在了 0 到 99 之间。</li>
</ul>
<h3 id="在您代码中的具体应用"><a href="#在您代码中的具体应用" class="headerlink" title="在您代码中的具体应用"></a>在您代码中的具体应用</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">uint rand = uint(keccak256(abi.encodePacked(&quot;_str&quot;)));<br>return rand % dnaModulus;<br></code></pre></div></td></tr></table></figure>

<ul>
<li><strong>目的</strong>：生成一个在 <code>0</code> 到 <code>dnaModulus - 1</code> 之间的伪随机数。</li>
<li><strong>假设 <code>dnaModulus = 10</code></strong>，那么无论 <code>rand</code> 多大，最终结果一定是 0, 1, 2, …, 9 中的一个。</li>
<li><strong>假设 <code>dnaModulus = 100</code></strong>，那么最终结果就是 0 到 99 之间的一个数。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>“对生成的随机数取模”就是一个数学上的“缩放”过程：</strong></p>
<ol>
<li><strong>输入</strong>：一个巨大的、范围不可控的随机数。</li>
<li><strong>操作</strong>：使用 <code>%</code>（取模）运算。</li>
<li><strong>输出</strong>：一个范围被精确控制在 <code>[0, 模数-1]</code> 之间的、更实用的随机数。</li>
</ol>
<p>这是一种非常常见且重要的技巧，用于将哈希函数生成的大随机数映射到我们需要的特定范围内。</p>
<h1 id="事件event"><a href="#事件event" class="headerlink" title="事件event"></a>事件event</h1><p>Modify the first line of the _createZombie function. You’re going to need the zombie’s id. The array.push() function returns a uint of the new length of the array - and since the first item in an array has index 0, array.push() - 1 will be the index of the zombie we just added. Store the result of zombies.push() - 1 in a uint called id, so you can use this in the NewZombie event in the next line.<br>修改 <code>_createZombie</code> 函数的第一行代码。您需要获取僵尸的id。<code>array.push()</code> 函数会返回一个表示数组新长度的 uint 值——由于数组中的第一项索引为 0，所以 <code>array.push() - 1</code> 将是我们刚刚添加的僵尸的索引。将 <code>zombies.push() - 1</code> 的结果存储在一个名为 <code>id</code> 的 uint 变量中，这样您就可以在下一行的 <code>NewZombie</code> 事件中使用它。</p>
<p>（该翻译保持了技术文档的准确性，同时将英文的被动语态和长句结构转换为中文常见的主动语态和分句表达，使内容更符合中文技术文档的阅读习惯。关键编程概念如”array.push()”、”uint”、”index”等均使用标准译法，确保专业术语的准确性。）</p>
<p>fire the NewZombie event. 这个fire怎么理解?<br>“触发 NewZombie 事件”</p>
<h1 id="web3-js"><a href="#web3-js" class="headerlink" title="web3.js"></a>web3.js</h1><p>我们的 Solidity 合约已经完成！现在我们需要编写一个与合约交互的 JavaScript 前端。</p>
<p>以太坊有一个名为 Web3.js 的 JavaScript 库。</p>
<p>在后续课程中，我们将深入讲解如何部署合约和设置 Web3.js。但现在，让我们先看看 Web3.js 如何与我们已部署合约交互的示例代码。</p>
<p>如果现在还有些不明白，不用担心。我们的 JavaScript 代码会获取上面 zombieDetails 中生成的值，并利用基于浏览器的 JavaScript 技巧（我们使用 Vue.js）来替换图片和应用 CSS 滤镜。您将在后续课程中获得所有这些代码。</p>
<p>试试看吧！<br>在右侧输入框中输入您的名字，看看会得到什么样的僵尸！</p>
<p>当您获得满意的僵尸后，请点击下方的”下一章”来保存您的僵尸并完成第 1 课！</p>
<p>这个链接证明我完成了该solidity课程： <a target="_blank" rel="noopener" href="https://share.cryptozombies.io/en/lesson/1/share/111111111111111111111111?id=Y3p8NjY1NTA4">https://share.cryptozombies.io/en/lesson/1/share/111111111111111111111111?id=Y3p8NjY1NTA4</a></p>
<h1 id="地址和映射"><a href="#地址和映射" class="headerlink" title="地址和映射"></a>地址和映射</h1><p>地址<br>以太坊区块链由账户组成，您可以将其类比为银行账户。每个账户都持有一定余额的以太币（Ethereum区块链上使用的货币），您可以向其他账户发送或接收以太币，就像银行账户可以电汇资金到其他银行账户一样。</p>
<p>每个账户都有一个地址，这类似于银行账号。它是指向该账户的唯一标识符  </p>
<p>我们将在后续课程详细讨论地址的细节，目前您只需理解：每个地址都由特定用户（或智能合约）拥有。</p>
<p>因此，我们可以将地址作为僵尸所有权的唯一标识符。当用户通过与我们的应用交互创建新僵尸时，我们会将这些僵尸的所有权设置为调用该函数的以太坊地址。</p>
<p>映射<br>在第一课中，我们学习了结构体和数组。映射是Solidity中另一种存储组织化数据的方式。</p>
<p>映射本质上是一个键值对存储结构，用于存储和查询数据。在第一个例子中，键是 address 类型，值是 uint 类型；在第二个例子中，键是 uint 类型，值是 string 类型。</p>
<p>实践练习<br>为了存储僵尸的所有权信息，我们将使用两个映射：一个用于记录每个僵尸所属的地址，另一个用于记录每个地址拥有的僵尸数量。</p>
<p>创建一个名为 zombieToOwner 的映射。键的类型为 uint（我们将根据僵尸的 id 来存储和查找），值的类型为 address。请将此映射设为 public。</p>
<p>创建一个名为 ownerZombieCount 的映射，其中键的类型为 address，值的类型为 uint。</p>
<p>mapping (address &#x3D;&gt; uint) public zombieToOwner; 为什么这个写法是错误的？mapping (uint &#x3D;&gt; address) public zombieToOwner;这个写法却是正确的？</p>
<p>好的，这是一个非常关键的理解点。这两个写法的区别在于<strong>映射中键和值的逻辑关系</strong>。</p>
<h3 id="核心原因"><a href="#核心原因" class="headerlink" title="核心原因"></a>核心原因</h3><p><strong><code>zombieToOwner</code> 这个名字的语义是“通过僵尸ID找到其主人”。</strong></p>
<p>让我们来分析一下：</p>
<h3 id="1-错误写法：mapping-address-uint-public-zombieToOwner"><a href="#1-错误写法：mapping-address-uint-public-zombieToOwner" class="headerlink" title="1. 错误写法：mapping (address =&gt; uint) public zombieToOwner;"></a>1. 错误写法：<code>mapping (address =&gt; uint) public zombieToOwner;</code></h3><ul>
<li><strong>键 (Key):</strong> <code>address</code> (一个所有者地址)</li>
<li><strong>值 (Value):</strong> <code>uint</code> (一个僵尸ID)</li>
</ul>
<p><strong>这行代码的实际含义是：</strong><br>“给定一个<strong>所有者地址</strong>，返回他拥有的<strong>某一个僵尸的ID</strong>。”</p>
<p><strong>这为什么是错的？</strong></p>
<ul>
<li>一个所有者（地址）可以拥有<strong>多个</strong>僵尸。</li>
<li>这个映射只能存储 <strong>“一个地址 &#x3D;&gt; 一个僵尸ID”</strong> 的关系。</li>
<li>如果用户拥有第二个僵尸，你存储新ID时就会<strong>覆盖掉第一个僵尸的ID</strong>。</li>
<li>你无法查询一个地址拥有的所有僵尸。</li>
</ul>
<p><strong>这更像是 <code>ownerToSingleZombie</code> 的映射，而不是 <code>zombieToOwner</code>。</strong></p>
<h3 id="2-正确写法：mapping-uint-address-public-zombieToOwner"><a href="#2-正确写法：mapping-uint-address-public-zombieToOwner" class="headerlink" title="2. 正确写法：mapping (uint =&gt; address) public zombieToOwner;"></a>2. 正确写法：<code>mapping (uint =&gt; address) public zombieToOwner;</code></h3><ul>
<li><strong>键 (Key):</strong> <code>uint</code> (一个僵尸ID)</li>
<li><strong>值 (Value):</strong> <code>address</code> (该僵尸的所有者地址)</li>
</ul>
<p><strong>这行代码的实际含义是：</strong><br>“给定一个<strong>僵尸ID</strong>，返回拥有它的<strong>所有者地址</strong>。”</p>
<p><strong>这为什么是正确的？</strong></p>
<ul>
<li>每个僵尸的ID是<strong>全局唯一</strong>的。</li>
<li>一个僵尸在任意时刻只能有一个所有者。</li>
<li>这个映射完美地建立了 <strong>“一个僵尸 &#x3D;&gt; 一个所有者”</strong> 的关系。</li>
<li>这正是 <code>zombieToOwner</code> 这个名字想表达的逻辑。</li>
</ul>
<h3 id="直观类比"><a href="#直观类比" class="headerlink" title="直观类比"></a>直观类比</h3><p>把它想象成一个电话簿：</p>
<ul>
<li><p><strong>错误写法</strong> <code>(address =&gt; uint)</code></p>
<ul>
<li>就像你想通过“人名”去查“电话号码”，但规定每个人只能有一个电话号码。这不符合需求，因为一个人可能有多个僵尸。</li>
</ul>
</li>
<li><p><strong>正确写法</strong> <code>(uint =&gt; address)</code></p>
<ul>
<li>就像你想通过“僵尸ID”这个唯一编号去查它的“主人”是谁。这是一个一对一的完美映射。</li>
</ul>
</li>
</ul>
<h3 id="如何解决“一个用户拥有多个僵尸”的问题？"><a href="#如何解决“一个用户拥有多个僵尸”的问题？" class="headerlink" title="如何解决“一个用户拥有多个僵尸”的问题？"></a>如何解决“一个用户拥有多个僵尸”的问题？</h3><p>这就是为什么你的代码中还需要另一个映射：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">mapping (address =&gt; uint) public ownerZombieCount;<br></code></pre></div></td></tr></table></figure>

<p>这个映射用来记录<strong>每个地址拥有的僵尸数量</strong>，它和 <code>zombieToOwner</code> 映射<strong>协同工作</strong>来完整地管理所有权关系。</p>
<p><strong>总结：映射的键值对设计必须符合你想要查询的逻辑方向。<code>zombieToOwner</code> 的查询起点是僵尸ID，目标是找到其所有者，所以必须是 <code>(uint =&gt; address)</code>。</strong></p>
<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><p>numbers[msg.sender] &#x3D; _num; 这行代码的意思是，把msg.sender指向_num还是把_num指向msg.sender？<br>这是一个很常见的困惑点！让我来帮你彻底搞清楚：</p>
<p><strong>正确答案是：把 <code>_num</code> 的值赋给 <code>msg.sender</code> 在 <code>numbers</code> 映射中的位置。</strong></p>
<p>更准确地说：<strong>将 <code>_num</code> 指向（赋值给）<code>msg.sender</code> 对应的存储位置。</strong></p>
<h2 id="详细解释："><a href="#详细解释：" class="headerlink" title="详细解释："></a>详细解释：</h2><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">numbers[msg.sender] = _num;<br></code></pre></div></td></tr></table></figure>

<p>这行代码的<strong>执行顺序是从右向左</strong>：</p>
<ol>
<li><strong><code>_num</code></strong> - 这是数据源（要存储的值）</li>
<li><strong><code>=</code></strong> - 赋值操作符，表示”将右边的值赋给左边”</li>
<li><strong><code>numbers[msg.sender]</code></strong> - 这是目标位置（要存储的位置）</li>
</ol>
<h2 id="类比理解："><a href="#类比理解：" class="headerlink" title="类比理解："></a>类比理解：</h2><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 类似于其他编程语言中的：</span><br>userScores[<span class="hljs-string">&quot;Alice&quot;</span>] = <span class="hljs-number">95</span>;<br><span class="hljs-comment">// 意思是：把95赋给Alice的分数</span><br></code></pre></div></td></tr></table></figure>

<h2 id="在映射中的具体含义："><a href="#在映射中的具体含义：" class="headerlink" title="在映射中的具体含义："></a>在映射中的具体含义：</h2><ul>
<li><code>numbers</code> 是一个映射（mapping）</li>
<li><code>msg.sender</code> 是键（key），表示一个地址</li>
<li><code>_num</code> 是值（value），要存储的数字</li>
<li>整体意思：<strong>在 numbers 映射中，为 msg.sender 这个地址设置对应的值为 _num</strong></li>
</ul>
<h2 id="举例说明："><a href="#举例说明：" class="headerlink" title="举例说明："></a>举例说明：</h2><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">mapping(address =&gt; uint256) public numbers;<br><br>function setNumber(uint256 _num) public &#123;<br>    numbers[msg.sender] = _num;  // 把 _num 存储到调用者的位置<br>&#125;<br><br>// 如果 Alice 调用 setNumber(100)<br>// 那么 numbers[Alice的地址] 就等于 100<br></code></pre></div></td></tr></table></figure>

<p><strong>简单记法：</strong> 总是 <strong>右边赋值给左边</strong>，就像数学中的 <code>x = 5</code> 是把 5 赋给 x。</p>
<h1 id="msg-sender"><a href="#msg-sender" class="headerlink" title="msg.sender"></a>msg.sender</h1><p>现在我们已建立了用于追踪僵尸所有权的映射，接下来需要更新 _createZombie 方法以使用这些映射。</p>
<p>为此，我们需要使用一个名为 msg.sender 的全局变量。</p>
<p>msg.sender<br>在 Solidity 中，存在一些对所有函数可用的全局变量。其中之一就是 msg.sender，它指向当前函数调用者（个人或智能合约）的地址。</p>
<p>注意：在 Solidity 中，函数的执行始终需要由外部调用者发起。合约只会静静地部署在区块链上，直到有人调用其某个函数时才会执行操作。因此，系统中始终会存在一个 msg.sender。</p>
<p>以下是一个使用 msg.sender 并更新映射的示例：</p>
<figure class="highlight zephir"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs zephir">mapping (address =&gt; <span class="hljs-keyword">uint</span>) favoriteNumber;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setMyNumber</span><span class="hljs-params">(<span class="hljs-keyword">uint</span> _myNumber)</span> <span class="hljs-title">public</span> </span>&#123;<br>  <span class="hljs-comment">// Update our `favoriteNumber` mapping to store `_myNumber` under `msg.sender`</span><br>  favoriteNumber[msg.sender] = _myNumber;<br>  <span class="hljs-comment">// ^ The syntax for storing data in a mapping is just like with arrays</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">whatIsMyNumber</span><span class="hljs-params">()</span> <span class="hljs-title">public</span> <span class="hljs-title">view</span> <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">uint</span>)</span> </span>&#123;<br>  <span class="hljs-comment">// Retrieve the value stored in the sender&#x27;s address</span><br>  <span class="hljs-comment">// Will be `0` if the sender hasn&#x27;t called `setMyNumber` yet</span><br>  <span class="hljs-keyword">return</span> favoriteNumber[msg.sender];<br>&#125;<br></code></pre></div></td></tr></table></figure>


<p>为什么这么写是错误的：zombieToOwner[msg.sender] &#x3D; id;<br>这样写是正确的：zombieToOwner[id] &#x3D; msg.sender;</p>
<p>这是一个非常好的问题，它触及了映射核心逻辑的理解。</p>
<h3 id="核心原因-1"><a href="#核心原因-1" class="headerlink" title="核心原因"></a>核心原因</h3><p>这两种写法的根本区别在于 <strong>“谁作为查询的键(Key)”</strong>。这直接由映射 <code>mapping (uint =&gt; address) public zombieToOwner;</code> 的定义决定。</p>
<h3 id="错误写法分析：zombieToOwner-msg-sender-id"><a href="#错误写法分析：zombieToOwner-msg-sender-id" class="headerlink" title="错误写法分析：zombieToOwner[msg.sender] = id;"></a>错误写法分析：<code>zombieToOwner[msg.sender] = id;</code></h3><ul>
<li><strong>你的意图</strong>：想把僵尸 <code>id</code> 分配给主人 <code>msg.sender</code>。</li>
<li><strong>代码的实际含义</strong>：<strong>把 <code>msg.sender</code> 这个地址当作键，去存储一个僵尸ID</strong>。</li>
</ul>
<p><strong>这为什么是错的？</strong></p>
<ol>
<li><p><strong>类型不匹配</strong>：你的映射定义为 <code>mapping (uint =&gt; address)</code>。这意味着<strong>键必须是 <code>uint</code> 类型</strong>。而 <code>msg.sender</code> 是一个 <code>address</code> 类型，不能用作键。Solidity编译器会直接报类型错误。</p>
</li>
<li><p><strong>逻辑错误（即使类型匹配）</strong>：</p>
<ul>
<li>假设你定义的是 <code>mapping (address =&gt; uint) zombieToOwner</code>。</li>
<li>那么 <code>zombieToOwner[msg.sender] = id;</code> 的含义是：<strong>“地址 <code>msg.sender</code> 现在只拥有僵尸 <code>id</code>”</strong>。</li>
<li>如果同一个用户（<code>msg.sender</code>）创建了第二个僵尸（比如 <code>id=2</code>），执行这行代码就会变成：<code>zombieToOwner[msg.sender] = 2;</code>。</li>
<li><strong>后果</strong>：用户对僵尸 <code>id=1</code> 的所有权记录被<strong>覆盖</strong>了！现在查询 <code>zombieToOwner[msg.sender]</code> 只会返回 <code>2</code>，僵尸1变得“无主”。这完全违背了我们的设计。</li>
</ul>
</li>
</ol>
<h3 id="正确写法分析：zombieToOwner-id-msg-sender"><a href="#正确写法分析：zombieToOwner-id-msg-sender" class="headerlink" title="正确写法分析：zombieToOwner[id] = msg.sender;"></a>正确写法分析：<code>zombieToOwner[id] = msg.sender;</code></h3><ul>
<li><strong>你的意图</strong>：想把僵尸 <code>id</code> 分配给主人 <code>msg.sender</code>。</li>
<li><strong>代码的实际含义</strong>：<strong>把 <code>id</code> 这个数字当作键，去存储一个所有者地址</strong>。</li>
</ul>
<p><strong>这为什么是正确的？</strong></p>
<ol>
<li><p><strong>类型匹配</strong>：映射 <code>mapping (uint =&gt; address)</code> 的键是 <code>uint</code>，值 <code>address</code>。<code>id</code> 是 <code>uint</code>，<code>msg.sender</code> 是 <code>address</code>，完美匹配。</p>
</li>
<li><p><strong>逻辑正确</strong>：</p>
<ul>
<li>每个僵尸的 <code>id</code> 是<strong>全局唯一</strong>且<strong>永不改变</strong>的。</li>
<li>这行代码建立了一个<strong>从僵尸到主人的单向关系</strong>。</li>
<li><strong>查询方式</strong>：当我想知道“僵尸5是谁的？”时，我就可以去查 <code>zombieToOwner[5]</code>，它会返回其主人的地址。</li>
<li>即使用户创建了多个僵尸，每个僵尸ID都会在映射中有一个独立的条目，<strong>互不覆盖</strong>。<ul>
<li><code>zombieToOwner[1] = 0x123...</code> (用户0x123…拥有僵尸1)</li>
<li><code>zombieToOwner[2] = 0x123...</code> (用户0x123…也拥有僵尸2)</li>
<li><code>zombieToOwner[3] = 0x456...</code> (用户0x456…拥有僵尸3)</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="直观类比-1"><a href="#直观类比-1" class="headerlink" title="直观类比"></a>直观类比</h3><p>把它想象成一个学校的<strong>储物柜系统</strong>：</p>
<ul>
<li><strong>每个僵尸ID</strong> 对应一个<strong>储物柜编号</strong>。</li>
<li><strong>每个所有者地址</strong> 对应一个<strong>学生</strong>。</li>
</ul>
<p><code>zombieToOwner[id] = msg.sender</code> 就像是：</p>
<blockquote>
<p>“把 <strong>储物柜编号 <code>id</code></strong> 分配给 <strong>学生 <code>msg.sender</code></strong>。”</p>
</blockquote>
<ul>
<li>你想知道103号柜子是谁的？查一下 <code>zombieToOwner[103]</code> 就知道了。</li>
<li>一个学生可以拥有多个柜子（比如103和105），但一个柜子只能分配给一个学生。</li>
</ul>
<p>而错误的写法 <code>zombieToOwner[msg.sender] = id</code> 就像是：</p>
<blockquote>
<p>“规定 <strong>学生 <code>msg.sender</code></strong> 只能使用 <strong>储物柜 <code>id</code></strong>。”</p>
</blockquote>
<ul>
<li>如果这个学生之前用过5号柜，现在分配他10号柜，那他就失去了5号柜的使用权。</li>
</ul>
<p><strong>结论：映射的设计决定了查询方向。<code>zombieToOwner</code> 的设计目的是“通过僵尸找主人”，所以必须用僵尸ID作为键。</strong></p>
<h1 id="storage-vs-Memory"><a href="#storage-vs-Memory" class="headerlink" title="storage vs Memory"></a>storage vs Memory</h1><p>如果说storage是硬盘存储，那么memory就是RAM<br>状态变量就是在函数外声明的变量。 状态变量会永久存储在区块链上。</p>
<p>为什么solidity里有时候用两个&#x3D;&#x3D;，有时候用一个&#x3D;</p>
<p>好的，这是一个关于 Solidity（以及大多数编程语言）基础语法的核心问题。简单来说：</p>
<ul>
<li><strong>一个 <code>=</code> 是赋值</strong></li>
<li><strong>两个 <code>==</code> 是比较</strong></li>
</ul>
<h3 id="1-一个等号-：赋值运算符"><a href="#1-一个等号-：赋值运算符" class="headerlink" title="1. 一个等号 = ：赋值运算符"></a>1. 一个等号 <code>=</code> ：赋值运算符</h3><p><strong>作用：</strong> 将右边的值<strong>赋予</strong>左边的变量。</p>
<p><strong>可以理解为：“设置为”或“变成”。</strong></p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">uint x = 5; // 声明变量x，并将其值设置为5<br>x = 10;     // 将变量x的值修改为10<br>ownerZombieCount[msg.sender] = 1; // 将该地址的僵尸数量设置为1<br></code></pre></div></td></tr></table></figure>

<p><strong>在这个语境下的例子：</strong><br>你之前写的 <code>zombieToOwner[id] = msg.sender;</code> 就是一个赋值操作。它的意思是：<strong>将 <code>msg.sender</code> 这个地址“赋予”或“设置”为僵尸 <code>id</code> 的主人。</strong></p>
<h3 id="2-两个等号-：比较运算符"><a href="#2-两个等号-：比较运算符" class="headerlink" title="2. 两个等号 == ：比较运算符"></a>2. 两个等号 <code>==</code> ：比较运算符</h3><p><strong>作用：</strong> 检查左右两边的值是否<strong>相等</strong>。</p>
<p><strong>可以理解为：“等于吗？”或“是否相等”。</strong></p>
<p>它会返回一个 <code>bool</code> 类型（布尔值）的结果：<code>true</code>（真&#x2F;相等）或 <code>false</code>（假&#x2F;不相等）。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">function checkValue(uint a, uint b) public pure returns (bool) &#123;<br>    return a == b; // 如果a等于b，返回true；否则返回false<br>&#125;<br><br>// 使用场景<br>if (ownerZombieCount[msg.sender] == 0) &#123;<br>    // 如果用户拥有的僵尸数量等于0，则执行这里的代码<br>&#125;<br></code></pre></div></td></tr></table></figure>


<h3 id="直观类比-2"><a href="#直观类比-2" class="headerlink" title="直观类比"></a>直观类比</h3><p>把它想象成一个办理入住的前台：</p>
<ul>
<li><p><strong>一个等号 <code>=</code> （赋值）</strong></p>
<blockquote>
<p>前台员工<strong>将</strong> 103号房间的钥匙<strong>交给</strong> 张三先生。<br><code>roomToGuest[103] = MrZhang；</code></p>
</blockquote>
</li>
<li><p><strong>两个等号 <code>==</code> （比较）</strong></p>
<blockquote>
<p>前台员工<strong>检查</strong> 想要领取103号房间钥匙的人<strong>是不是</strong> 张三先生。<br><code>if (msg.sender == MrZhang) &#123; // 才给钥匙 &#125;</code></p>
</blockquote>
</li>
</ul>
<h3 id="为什么不能混淆？"><a href="#为什么不能混淆？" class="headerlink" title="为什么不能混淆？"></a>为什么不能混淆？</h3><p>因为编译器无法理解你的意图。</p>
<ul>
<li><p>如果你在需要比较的地方错误地使用了 <code>=</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">if (x = 5) &#123; ... &#125; // 错误！<br></code></pre></div></td></tr></table></figure>
<p>这行代码的意图可能是“如果x等于5”，但它实际做的是“将x的值设为5”，并且整个表达式会返回5。在Solidity中，非0值被视为<code>true</code>，所以这个条件判断永远为真，这很可能是一个严重的逻辑错误。</p>
</li>
<li><p>如果你在需要赋值的地方错误地使用了 <code>==</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">uint x == 5; // 错误！<br></code></pre></div></td></tr></table></figure>
<p>编译器会直接报错，因为它期待的是一个赋值操作，而不是一个比较表达式。</p>
</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>| 运算符 | 名称 | 作用 | 例子 | 结果 |<br>| <strong><code>=</code></strong> | <strong>赋值</strong> | 将右边的值存入左边 | <code>x = 5</code> | <code>x</code> 变成了 <code>5</code> |<br>| <strong><code>==</code></strong> | <strong>等于比较</strong> | 检查两边是否相等 | <code>x == 5</code> | 如果<code>x</code>是<code>5</code>，返回<code>true</code>；否则返回<code>false</code> |</p>
<p><strong>记住这个口诀：一个等号是用来“改变”的，两个等号是用来“询问”的。</strong></p>
<h1 id="interface接口"><a href="#interface接口" class="headerlink" title="interface接口"></a>interface接口</h1><p>与其他合约的交互<br>如果我们的合约需要与区块链上其他非自身所有的合约进行交互，首先需要定义一套接口。</p>
<p>让我们来看一个简单示例。假设在区块链上存在这样一个合约：</p>
<figure class="highlight zephir"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs zephir">contract LuckyNumber &#123;<br>  mapping(address =&gt; <span class="hljs-keyword">uint</span>) numbers;<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setNum</span><span class="hljs-params">(<span class="hljs-keyword">uint</span> _num)</span> <span class="hljs-title">public</span> </span>&#123;<br>    numbers[msg.sender] = _num;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNum</span><span class="hljs-params">(address _myAddress)</span> <span class="hljs-title">public</span> <span class="hljs-title">view</span> <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">uint</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> numbers[_myAddress];<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>这将是一个简单的合约：任何人都可以在此存储他们的幸运数字，该数字会与其以太坊地址关联。之后，其他人便可通过地址查询该用户存储的幸运数字。</p>
<p>假设现在有一个外部合约，希望通过 getNum 函数读取此合约中的数据。</p>
<p>首先，我们需要定义 LuckyNumber 合约的接口：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">contract NumberInterface &#123;<br>  <span class="hljs-keyword">function</span> getNum(address _myAddress) <span class="hljs-built_in">public</span> <span class="hljs-keyword">view</span> <span class="hljs-keyword">returns</span> (uint);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>请注意，接口的定义方式与合约相似，但存在几点关键区别。首先，我们只声明需要交互的函数——本例中的 <code>getNum</code>——而不会涉及合约的其他函数或状态变量。</p>
<p>其次，我们不需要定义函数体。不同于使用花括号（{ 和 }），我们直接用分号（;）结束函数声明。</p>
<p>因此，接口看起来像是一个合约的骨架。编译器正是通过这种形式来识别这是一个接口。</p>
<p>通过在我们的去中心化应用中引入此接口，我们的合约就能了解外部合约的函数形式、调用方式以及预期的返回类型。</p>
<p>我们将在下一课详细讲解如何实际调用外部合约的函数，现在让我们先为 CryptoKitties 合约声明接口。</p>
<p>实践练习<br>我们已为您查阅了 CryptoKitties 的源代码，发现一个名为 <code>getKitty</code> 的函数，它能返回猫咪的所有数据，包括其”基因”（这正是我们的僵尸游戏生成新僵尸所需的素材！）。</p>
<p>该函数的具体定义如下：</p>
<p>（翻译说明：</p>
<ol>
<li>“contract skeleton” 译为”合约骨架”，形象传达接口的本质特征</li>
<li>“dapp” 采用行业通用译法”去中心化应用”，括号内标注英文缩写</li>
<li>“Put it to the test” 延续之前”实践练习”的译法，保持一致性</li>
<li>“genes” 译为”基因”并添加引号，既准确又体现其特殊游戏属性</li>
<li>技术细节翻译精准：函数体声明方式、分号使用等关键区别都明确呈现</li>
<li>语句结构进行合理重组，将英文长句转换为符合中文阅读习惯的短句</li>
<li>保留所有代码元素 <code>getNum</code>、<code>getKitty</code> 的原貌</li>
<li>结尾留出代码示例的衔接空间，保持教程的连贯性）</li>
</ol>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Web3/">Web3</a>
                    
                  </div>
                
              </div>
              
                
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/11/21/44610.html">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">我的生平（二十七）</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/11/20/44609.html">
                        <span class="hidden-mobile">我的生平（二十六）</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


            

                
                  <a id="scroll-top-button" href="#" role="button">
                    <i class="iconfont icon-arrowup" aria-hidden="true"></i>
                  </a>
                  

                    

                          
      </main>

      <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://whale3070.github.io/" target="_blank" rel="nofollow noopener"><span>Whale3070</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->




  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>





  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<link href="/pagefind/pagefind-ui.css" rel="stylesheet">
  <script src="/pagefind/pagefind-ui.js"></script>
  <style>
    /* 搜索框配色适配 */
    #search { margin-top: 2rem; }
    [data-user-color-scheme='dark'] .pagefind-ui {
      --pagefind-ui-primary: #eeeeee;
      --pagefind-ui-text: #eeeeee;
      --pagefind-ui-background: #151515;
      --pagefind-ui-border: #333;
    }
  </style>
    </body>

  </html>