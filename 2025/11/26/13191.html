

  <!DOCTYPE html>
  <html lang="zh-CN" data-default-color-scheme=&#34;dark&#34; >
  <style>
    .text1
    {
    text-shadow: 0px 0px 2px #f2f3f2;
    }
    </style>

  

<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/null">
  <link rel="icon" type="image/png" href="/null">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>cryptozombies5 - whale3070&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"192.168.126.129","root":"/","version":"1.8.7","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 7.3.0"></head>


    <body>
      <header style="height: 70vh;">
        <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>InfoSec learning</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/search/">
                <i class="iconfont icon-search"></i>
                搜索
              </a>
            </li>
          
        
        
        
          
        
      </ul>
    </div>
  </div>
</nav>

          <div class="banner" id="banner" false
            style="background: url('/img/default.png') no-repeat center center;
              background-size: cover;">
              <div class="full-bg-img">
                <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
                  <div class="page-header text-center fade-in-up">
                    <span class="h2 text1" id="subtitle" title="cryptozombies5">
                      
                        cryptozombies5
                      
                    </span>
        
                    
                      <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2025-11-26 14:19" pubdate>
        2025年11月26日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6.1k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      71
       分钟
    </span>
  

  
  
</div>

                    
                  </div>
                    
                  </div>
                  
                </div>
              </div>
          </div>
      </header>

      <main>
        
          

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" data-pagefind-body>
            <!-- SEO header -->
            <h1 style="display: none">cryptozombies5</h1>
            
            <div class="markdown-body">
              <h1 id="第十章：SafeMath-第二部分"><a href="#第十章：SafeMath-第二部分" class="headerlink" title="第十章：SafeMath 第二部分"></a>第十章：SafeMath 第二部分</h1><p>让我们来看看 SafeMath 背后的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">library SafeMath &#123;<br><br>  function mul(uint256 a, uint256 b) internal pure returns (uint256) &#123;<br>    if (a == 0) &#123;<br>      return 0;<br>    &#125;<br>    uint256 c = a * b;<br>    assert(c / a == b);<br>    return c;<br>  &#125;<br><br>  function div(uint256 a, uint256 b) internal pure returns (uint256) &#123;<br>    // assert(b &gt; 0); // Solidity 会在除以 0 时自动抛出错误<br>    uint256 c = a / b;<br>    // assert(a == b * c + a % b); // 这个条件总是成立<br>    return c;<br>  &#125;<br><br>  function sub(uint256 a, uint256 b) internal pure returns (uint256) &#123;<br>    assert(b &lt;= a);<br>    return a - b;<br>  &#125;<br><br>  function add(uint256 a, uint256 b) internal pure returns (uint256) &#123;<br>    uint256 c = a + b;<br>    assert(c &gt;= a);<br>    return c;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>首先，我们看到的是 <code>library</code> 关键字——库与合约类似，但有一些不同。对于我们的用途，库允许我们使用 <code>using</code> 关键字，这会自动将库中的所有方法附加到另一个数据类型上：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">using SafeMath for uint;<br>// 现在我们可以在任何 uint 类型上使用这些方法<br>uint test = 2;<br>test = test.mul(3); // test 现在等于 6<br>test = test.add(5); // test 现在等于 11<br></code></pre></div></td></tr></table></figure>

<p>请注意，<code>mul</code> 和 <code>add</code> 函数每个都需要 2 个参数，但当我们声明 <code>using SafeMath for uint</code> 时，我们调用函数的 <code>uint</code>（<code>test</code>）会自动作为第一个参数传递进去。</p>
<p>让我们看看 <code>add</code> 函数的代码，了解 SafeMath 是如何工作的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">function add(uint256 a, uint256 b) internal pure returns (uint256) &#123;<br>  uint256 c = a + b;<br>  assert(c &gt;= a);<br>  return c;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>基本上，<code>add</code> 就是像 <code>+</code> 一样加两个 <code>uint</code>，但它还包含一个 <code>assert</code> 语句，确保结果大于或等于 <code>a</code>。这可以防止溢出。</p>
<p><code>assert</code> 和 <code>require</code> 类似，都会在条件为 <code>false</code> 时抛出错误。<code>assert</code> 和 <code>require</code> 的区别在于，<code>require</code> 会在函数失败时退还用户的剩余 gas，而 <code>assert</code> 则不会。所以，大多数时候你应该在代码中使用 <code>require</code>；<code>assert</code> 通常用于处理代码出现重大问题的情况（比如 <code>uint</code> 溢出）。</p>
<p>简单来说，SafeMath 的 <code>add</code>、<code>sub</code>、<code>mul</code> 和 <code>div</code> 是执行基本的 4 个数学运算的函数，但如果发生溢出或下溢，它们会抛出错误。</p>
<h3 id="在我们的代码中使用-SafeMath"><a href="#在我们的代码中使用-SafeMath" class="headerlink" title="在我们的代码中使用 SafeMath"></a>在我们的代码中使用 SafeMath</h3><p>为了防止溢出和下溢，我们可以检查代码中使用 <code>+</code>、<code>-</code>、<code>*</code> 或 <code>/</code> 的地方，并将它们替换为 <code>add</code>、<code>sub</code>、<code>mul</code>、<code>div</code>。</p>
<p>例如，替换：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">myUint++;<br></code></pre></div></td></tr></table></figure>

<p>改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">myUint = myUint.add(1);<br></code></pre></div></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在 <code>ZombieOwnership</code> 合约中，我们有两个地方使用了数学运算。让我们将它们替换为 SafeMath 方法。</p>
<ol>
<li>替换 <code>++</code> 为 SafeMath 方法。</li>
<li>替换 <code>--</code> 为 SafeMath 方法。</li>
</ol>
<h1 id="第十三章：注释"><a href="#第十三章：注释" class="headerlink" title="第十三章：注释"></a>第十三章：注释</h1><p>我们的僵尸游戏的 Solidity 代码终于完成了！</p>
<p>在接下来的课程中，我们将学习如何将代码部署到 Ethereum，并如何使用 Web3.js 与它进行交互。</p>
<p>但在我们结束第 5 课之前，有一件最后的事情要说：让我们来谈谈如何注释你的代码。</p>
<h4 id="注释语法"><a href="#注释语法" class="headerlink" title="注释语法"></a>注释语法</h4><p>在 Solidity 中注释的方式和 JavaScript 很相似。在 CryptoZombies 课程中，你已经见过一些单行注释的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">// 这是一个单行注释。就像是给自己（或别人）写的便条<br></code></pre></div></td></tr></table></figure>

<p>只需要在你想注释的地方添加 <code>//</code>，就能进行注释。它非常简单，你应该时常使用它。</p>
<p>但我知道，有时候单行注释是不够的。毕竟，你天生就是个写作者，对吧！</p>
<p>所以我们也有多行注释：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">contract CryptoZombies &#123;<br>  /* 这是一个多行注释。我想感谢所有<br>    花时间尝试这门编程课程的你们。<br>    我知道它对你们来说是免费的，而且会一直免费，<br>    但我们仍然倾注心血，希望它尽可能好。<br><br>    请知道，这仅仅是区块链开发的开始。<br>    我们已经走了很远，但还有许多方法可以让这个<br>    社区变得更好。如果我们哪里有错误，你可以<br>    帮我们打开一个 Pull Request：<br>    https://github.com/loomnetwork/cryptozombie-lessons<br><br>    或者如果你有一些想法、评论，或者只是想说<br>    嗨——欢迎加入我们的 Telegram 社区：https://t.me/loomnetworkdev<br>  */<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>特别是，注释代码来解释每个函数的预期行为是一个好习惯。这样，其他开发者（或者在你休息了 6 个月后回到项目时的你）可以快速浏览并高层次地理解你的代码，而不需要深入阅读代码本身。</p>
<p>在 Solidity 社区中，标准是使用一种叫做 <strong>natspec</strong> 的格式，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">/// @title 基本数学运算合约<br>/// @author H4XF13LD MORRIS 💯💯😎💯💯<br>/// @notice 目前，这个合约仅有一个乘法函数<br>contract Math &#123;<br>  /// @notice 计算两个数字的乘积<br>  /// @param x 第一个 uint。<br>  /// @param y 第二个 uint。<br>  /// @return z (x * y) 的乘积<br>  /// @dev 这个函数目前没有检查溢出<br>  function multiply(uint x, uint y) returns (uint z) &#123;<br>    // 这只是一个普通注释，不会被 natspec 提取<br>    z = x * y;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<ul>
<li><code>@title</code> 和 <code>@author</code> 是直观的。</li>
<li><code>@notice</code> 向用户解释合约&#x2F;函数的功能。</li>
<li><code>@dev</code> 用于向开发者解释额外的细节。</li>
<li><code>@param</code> 和 <code>@return</code> 用于描述函数的每个参数和返回值。</li>
</ul>
<p>请注意，你不必为每个函数都使用所有的标签——这些标签是可选的。但至少，留下一个 <code>@dev</code> 注释来解释每个函数的作用是一个好习惯。</p>
<h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p>如果你现在还没有注意到，CryptoZombies 的答案检查器会忽略注释，当它检查你的答案时。因此，我们不能真正检查你在这一章中添加的 natspec 代码 ;)</p>
<p>不过，既然你已经是一个 Solidity 大神——我们就假设你已经掌握了！</p>
<p>无论如何，尝试一下，尝试为 <code>ZombieOwnership</code> 合约添加一些 natspec 标签：</p>
<ul>
<li><code>@title</code> —— 例如：一个管理僵尸所有权转移的合约</li>
<li><code>@author</code> —— 你的名字！</li>
<li><code>@dev</code> —— 例如：符合 OpenZeppelin 的 ERC721 规范草案</li>
</ul>
<h1 id="第十四章：总结"><a href="#第十四章：总结" class="headerlink" title="第十四章：总结"></a>第十四章：总结</h1><p>恭喜你！这标志着第 5 课的结束。</p>
<p>作为奖励，我们已经将你自己的 10 级 H4XF13LD MORRIS 💯💯😎💯💯 僵尸转交给你了！</p>
<p>（天啊，传说中的 H4XF13LD MORRIS 💯💯😎💯💯 僵尸!!!!111）</p>
<p>现在，你的军队中有 4 只僵尸了。</p>
<p>在你继续之前，如果你愿意，你可以通过点击僵尸并输入新名字来重命名它们。（不过我不明白为什么你会想要重命名 H4XF13LD MORRIS 💯💯😎💯💯，显然这是最棒的名字。）</p>
<p>让我们回顾一下：<br>在本课中，我们学习了：</p>
<ul>
<li>代币、ERC721 标准以及可交易资产&#x2F;僵尸</li>
<li>库及如何使用它们</li>
<li>如何使用 SafeMath 库防止溢出和下溢</li>
<li>注释代码及 natspec 标准</li>
</ul>
<p>这节课结束了我们游戏的 Solidity 代码！（暂时——未来我们可能会添加更多课程）。</p>
<p>在下一节课中，我们将学习如何部署合约并使用 web3.js 与它们交互（这样你就可以为你的 DApp 构建前端了）。</p>
<p>如果你喜欢，可以去重命名你的僵尸，然后继续到下一章以完成课程。</p>
<p><a target="_blank" rel="noopener" href="https://share.cryptozombies.io/en/lesson/5/share/H4XF13LD_MORRIS_%F0%9F%92%AF%F0%9F%92%AF%F0%9F%98%8E%F0%9F%92%AF%F0%9F%92%AF?id=Y3p8NjY1NTA4">https://share.cryptozombies.io/en/lesson/5/share/H4XF13LD_MORRIS_%F0%9F%92%AF%F0%9F%92%AF%F0%9F%98%8E%F0%9F%92%AF%F0%9F%92%AF?id=Y3p8NjY1NTA4</a></p>
<h1 id="第-1-章：Web3-js-简介"><a href="#第-1-章：Web3-js-简介" class="headerlink" title="第 1 章：Web3.js 简介"></a>第 1 章：Web3.js 简介</h1><p>通过完成第 5 课，我们的僵尸 DApp 已经完成。接下来，我们将创建一个基本的网页，让用户能够与它进行交互。</p>
<p>为此，我们将使用一个来自以太坊基金会的 JavaScript 库——<strong>Web3.js</strong>。</p>
<h4 id="什么是-Web3-js？"><a href="#什么是-Web3-js？" class="headerlink" title="什么是 Web3.js？"></a>什么是 Web3.js？</h4><p>记住，以太坊网络由多个节点组成，每个节点都包含一份区块链副本。当你想调用智能合约中的某个函数时，你需要向其中一个节点发送请求，并告诉它以下内容：</p>
<ul>
<li>智能合约的地址</li>
<li>你想调用的函数</li>
<li>你想传递给函数的变量</li>
</ul>
<p>以太坊节点仅支持 JSON-RPC 语言，而这种语言并不适合人类阅读。向节点发送的请求可能类似于下面这样的格式：</p>
<figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json"><span class="hljs-comment">// 是的……祝你好运，手动编写所有的函数调用！</span><br><span class="hljs-comment">// 向右滚动 ==&gt;</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;jsonrpc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2.0&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;method&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;eth_sendTransaction&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;params&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;from&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0xb60e8dd61c5d32be8058bb8eb970870f07233155&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;to&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0xd46e8dd67c5d32be8058bb8eb970870f07244567&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;gas&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0x76c0&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;gasPrice&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0x9184e72a000&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;value&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0x9184e72a&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></div></td></tr></table></figure>

<p>幸运的是，Web3.js 会把这些复杂的查询隐藏在表面之下，你只需要与一个方便且易于阅读的 JavaScript 接口进行交互。</p>
<p>你不需要手动构造上面的请求，调用函数时，你的代码看起来像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">CryptoZombies</span>.<span class="hljs-property">methods</span>.<span class="hljs-title function_">createRandomZombie</span>(<span class="hljs-string">&quot;Vitalik Nakamoto 🤔&quot;</span>)<br>  .<span class="hljs-title function_">send</span>(&#123; <span class="hljs-attr">from</span>: <span class="hljs-string">&quot;0xb60e8dd61c5d32be8058bb8eb970870f07233155&quot;</span>, <span class="hljs-attr">gas</span>: <span class="hljs-string">&quot;3000000&quot;</span> &#125;)<br></code></pre></div></td></tr></table></figure>

<p>我们将在接下来的几章中详细解释语法，但首先让我们用 Web3.js 设置你的项目。</p>
<h4 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h4><p>根据你项目的工作流，你可以通过以下大多数包管理工具将 Web3.js 添加到项目中：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">// 使用 NPM<br>npm install web3<br><br>// 使用 Yarn<br>yarn add web3<br><br>// 使用 Bower<br>bower install web3<br><br>// ...等等<br></code></pre></div></td></tr></table></figure>

<p>或者，你也可以直接从 GitHub 下载 minified 版本的 <code>.js</code> 文件，并将其包含在项目中：</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">language</span>=<span class="hljs-string">&quot;javascript&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;web3.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<p>由于我们不想对你的开发环境和使用的包管理器做太多假设，本教程中我们将简单地通过上述的 <code>&lt;script&gt;</code> 标签将 Web3.js 引入项目。</p>
<h4 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h4><p>我们为你创建了一个 HTML 项目的框架文件 <code>index.html</code>。假设我们将 <code>web3.min.js</code> 文件放在与 <code>index.html</code> 相同的文件夹中。</p>
<p>现在，请将上面的 <code>&lt;script&gt;</code> 标签复制并粘贴到我们的项目中，这样我们就可以开始使用 Web3.js 了。</p>
<h1 id="第二章：Web3-提供者"><a href="#第二章：Web3-提供者" class="headerlink" title="第二章：Web3 提供者"></a>第二章：Web3 提供者</h1><p>太好了！现在我们的项目中已经有了 Web3.js，接下来让我们初始化 Web3 并与区块链进行交互。</p>
<p>我们首先需要的是一个 <strong>Web3 提供者</strong>。</p>
<p>记住，Ethereum 是由多个节点组成的，每个节点都共享一份相同的数据。设置 Web3 提供者会告诉我们的代码，我们应该与哪个节点进行通信，来处理我们的读写请求。这有点像在传统的 Web 应用中，设置 API 调用的远程 Web 服务器 URL。</p>
<p>你可以将自己的 Ethereum 节点作为提供者来托管。然而，有一个第三方服务可以让你的生活变得更轻松，这样你就不需要自己维护一个 Ethereum 节点就能为用户提供 DApp —— <strong>Infura</strong>。</p>
<h3 id="Infura"><a href="#Infura" class="headerlink" title="Infura"></a>Infura</h3><p>Infura 是一个服务，维护了一组 Ethereum 节点，并为快速读取提供了缓存层，你可以通过他们的 API 免费访问。使用 Infura 作为提供者，你可以可靠地向 Ethereum 区块链发送和接收消息，而无需设置和维护自己的节点。</p>
<p>你可以像下面这样设置 Web3，使用 Infura 作为 Web3 提供者：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> web3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Web3</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Web3</span>.<span class="hljs-property">providers</span>.<span class="hljs-title class_">WebsocketProvider</span>(<span class="hljs-string">&quot;wss://mainnet.infura.io/ws&quot;</span>));<br></code></pre></div></td></tr></table></figure>

<p>然而，由于我们的 DApp 将被许多用户使用 —— 而且这些用户不仅仅是读取区块链数据，他们还需要向区块链写入数据 —— 我们需要一种方式让这些用户用他们的私钥签署交易。</p>
<p>注意：Ethereum（以及一般的区块链）使用公钥&#x2F;私钥对来对交易进行数字签名。可以把它看作是一个非常安全的密码，用于数字签名。这样，如果我更改区块链上的某些数据，我可以通过我的公钥证明是我签署了它——但由于没有人知道我的私钥，没人能够伪造我的交易。</p>
<p>加密技术很复杂，所以除非你是安全专家，真的知道自己在做什么，否则最好不要尝试在我们的应用前端自己管理用户的私钥。</p>
<p>幸运的是，你不需要自己管理——已经有服务专门为你处理这些问题。其中最受欢迎的就是 <strong>Metamask</strong>。</p>
<h3 id="Metamask"><a href="#Metamask" class="headerlink" title="Metamask"></a>Metamask</h3><p>Metamask 是一个适用于 Chrome 和 Firefox 的浏览器扩展，允许用户安全地管理他们的 Ethereum 账户和私钥，并使用这些账户与使用 Web3.js 的网站进行交互。（如果你以前没有使用过它，你绝对需要去安装它——这样你的浏览器就启用了 Web3，你现在可以与任何与 Ethereum 区块链通信的网站进行交互！）</p>
<p>作为开发者，如果你希望用户通过网站与你的 DApp 进行交互（就像我们在 CryptoZombies 游戏中做的那样），你肯定希望让它兼容 Metamask。</p>
<p>注意：Metamask 在底层使用 Infura 的服务器作为 Web3 提供者，就像我们上面做的那样——但它也给用户提供了选择自己的 Web3 提供者的选项。所以，通过使用 Metamask 的 Web3 提供者，你给了用户选择权，也减少了你在应用中需要处理的事情。</p>
<h3 id="使用-Metamask-的-Web3-提供者"><a href="#使用-Metamask-的-Web3-提供者" class="headerlink" title="使用 Metamask 的 Web3 提供者"></a>使用 Metamask 的 Web3 提供者</h3><p>Metamask 将它的 Web3 提供者注入到浏览器中的全局 JavaScript 对象 <code>web3</code>。所以，你的应用可以检查是否存在 <code>web3</code>，如果存在，就使用 <code>web3.currentProvider</code> 作为提供者。</p>
<p>下面是 Metamask 提供的模板代码，用于检测用户是否安装了 Metamask，如果没有安装，则告诉他们需要安装 Metamask 才能使用我们的应用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;load&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><br>  <span class="hljs-comment">// 检查浏览器是否注入了 Web3（Mist/MetaMask）</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> web3 !== <span class="hljs-string">&#x27;undefined&#x27;</span>) &#123;<br>    <span class="hljs-comment">// 使用 Mist/MetaMask 的提供者</span><br>    web3js = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Web3</span>(web3.<span class="hljs-property">currentProvider</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 处理用户没有 web3 的情况。通常</span><br>    <span class="hljs-comment">// 向他们展示一条消息，告诉他们需要安装 Metamask</span><br>    <span class="hljs-comment">// 才能使用我们的应用。</span><br>  &#125;<br><br>  <span class="hljs-comment">// 现在你可以开始你的应用并自由访问 web3js：</span><br>  <span class="hljs-title function_">startApp</span>()<br><br>&#125;)<br></code></pre></div></td></tr></table></figure>

<p>你可以在你创建的所有应用中使用这段模板代码，要求用户必须安装 Metamask 才能使用你的 DApp。</p>
<p>注意：除了 Metamask，用户可能还在使用其他私钥管理程序，如 Mist 浏览器。但是，它们都实现了一个共同的模式，即注入 <code>web3</code> 变量，因此我们在这里描述的检测用户 Web3 提供者的方法也适用于这些程序。</p>
<h2 id="测试-3"><a href="#测试-3" class="headerlink" title="测试"></a>测试</h2><p>我们已经在 HTML 文件的 <code>&lt;/body&gt;</code> 标签之前创建了一些空的 <code>&lt;script&gt;</code> 标签。我们可以在这里编写本课的 JavaScript 代码。</p>
<p>请将上面检测 Metamask 的模板代码复制并粘贴到我们的项目中。这段代码从 <code>window.addEventListener</code> 开始。</p>
<h1 id="第-3-章：与合约交互"><a href="#第-3-章：与合约交互" class="headerlink" title="第 3 章：与合约交互"></a>第 3 章：与合约交互</h1><p>现在我们已经通过 MetaMask 的 Web3 提供者初始化了 Web3.js，接下来让我们设置它与智能合约进行交互。</p>
<p>Web3.js 需要两样东西才能与合约进行交互：<strong>合约地址</strong>和<strong>合约 ABI</strong>。</p>
<h2 id="合约地址"><a href="#合约地址" class="headerlink" title="合约地址"></a>合约地址</h2><p>在你编写完智能合约后，你需要将它编译并部署到 Ethereum 上。我们将在下一课讲解如何部署，但由于这是一个与编写代码完全不同的过程，我们决定先讲解 Web3.js。</p>
<p>部署完合约后，它会获得一个在 Ethereum 上永久存在的固定地址。回想一下第 2 课，CryptoKitties 合约在 Ethereum 主网上的地址是 <code>0x06012c8cf97BEaD5deAe237070F9587f8E7A266d</code>。</p>
<p>你需要在部署后复制这个地址，以便与智能合约进行交互。</p>
<h2 id="合约-ABI"><a href="#合约-ABI" class="headerlink" title="合约 ABI"></a>合约 ABI</h2><p>Web3.js 需要的另一样东西是合约的 <strong>ABI</strong>。</p>
<p>ABI 代表应用程序二进制接口（Application Binary Interface）。基本上，它是合约方法的 JSON 格式表示，告诉 Web3.js 如何格式化函数调用，以便合约可以理解。</p>
<p>当你将合约编译并部署到 Ethereum（我们将在第 7 课讲解如何部署）时，Solidity 编译器会生成 ABI，因此你需要在部署合约时同时复制和保存 ABI。</p>
<p>由于我们还没有讲解如何部署，在这一课中，我们已经为你编译好了 ABI，并将其保存在名为 <code>cryptozombies_abi.js</code> 的文件中，并将其存储在名为 <code>cryptoZombiesABI</code> 的变量中。</p>
<p>如果我们将 <code>cryptozombies_abi.js</code> 包含到项目中，就可以通过该变量访问 CryptoZombies 的 ABI。</p>
<h2 id="实例化-Web3-js-合约"><a href="#实例化-Web3-js-合约" class="headerlink" title="实例化 Web3.js 合约"></a>实例化 Web3.js 合约</h2><p>一旦你有了合约的地址和 ABI，就可以像下面这样在 Web3 中实例化它：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 实例化我的合约</span><br><span class="hljs-keyword">var</span> myContract = <span class="hljs-keyword">new</span> web3js.<span class="hljs-property">eth</span>.<span class="hljs-title class_">Contract</span>(myABI, myContractAddress);<br></code></pre></div></td></tr></table></figure>

<h2 id="测试-4"><a href="#测试-4" class="headerlink" title="测试"></a>测试</h2><p>在我们文档的 <code>&lt;head&gt;</code> 中，包含另一个 <code>&lt;script&gt;</code> 标签，引入 <code>cryptozombies_abi.js</code>，这样就能把 ABI 定义导入到我们的项目中。</p>
<p>在 <code>&lt;body&gt;</code> 标签中的 <code>&lt;script&gt;</code> 部分开头，声明一个名为 <code>cryptoZombies</code> 的变量，但不要赋值。稍后我们将用这个变量来存储我们实例化的合约。</p>
<p>接下来，创建一个名为 <code>startApp()</code> 的函数。我们将在接下来的两步中填充这个函数的内容。</p>
<p><code>startApp()</code> 函数的第一件事是声明一个名为 <code>cryptoZombiesAddress</code> 的变量，并将其设置为字符串 <code>&quot;YOUR_CONTRACT_ADDRESS&quot;</code>（这是 CryptoZombies 合约在主网的地址）。</p>
<p>最后，实例化合约。将 <code>cryptoZombies</code> 设置为一个新的 <code>web3js.eth.Contract</code>，就像我们在上面的示例代码中所做的那样。（使用 <code>cryptoZombiesABI</code>，它通过 <code>&lt;script&gt;</code> 标签导入，并使用上面声明的 <code>cryptoZombiesAddress</code>）。</p>
<h1 id="第4章：调用合约函数calling-contract-functions"><a href="#第4章：调用合约函数calling-contract-functions" class="headerlink" title="第4章：调用合约函数calling contract functions"></a>第4章：调用合约函数calling contract functions</h1><p>我们的合约已经设置好了！现在我们可以使用 Web3.js 与它进行交互。</p>
<p>Web3.js 有两个方法可以用来调用合约中的函数：<code>call</code> 和 <code>send</code>。</p>
<h2 id="Call"><a href="#Call" class="headerlink" title="Call"></a><strong>Call</strong></h2><p><code>call</code> 用于view和pure函数。它只在本地节点上运行，不会在区块链上创建交易。</p>
<p>回顾：<code>view</code> 和 <code>pure</code> 函数是只读的，不会更改区块链上的状态。它们也不需要支付任何 gas，用户也不会被提示在 MetaMask 中签署交易。</p>
<p>使用 Web3.js，你可以像下面这样调用名为 <code>myMethod</code> 的函数，并传递参数 <code>123</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">myContract.<span class="hljs-property">methods</span>.<span class="hljs-title function_">myMethod</span>(<span class="hljs-number">123</span>).<span class="hljs-title function_">call</span>()<br></code></pre></div></td></tr></table></figure>

<h2 id="Send"><a href="#Send" class="headerlink" title="Send"></a><strong>Send</strong></h2><p><code>send</code> 会创建一笔交易并更改区块链上的数据。对于任何非 <code>view</code> 或 <code>pure</code> 的函数，你都需要使用 <code>send</code>。</p>
<p>注意：发送交易将要求用户支付 gas，并且会弹出 MetaMask 提示他们签署交易。当我们使用 MetaMask 作为 Web3 提供者时，所有这些都会在调用 <code>send()</code> 时自动完成，我们的代码不需要做任何特殊处理。很酷吧！</p>
<p>使用 Web3.js，你可以像下面这样发送交易，调用名为 <code>myMethod</code> 的函数，并传递参数 <code>123</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">myContract.<span class="hljs-property">methods</span>.<span class="hljs-title function_">myMethod</span>(<span class="hljs-number">123</span>).<span class="hljs-title function_">send</span>()<br></code></pre></div></td></tr></table></figure>

<p>语法几乎和 <code>call()</code> 一模一样。</p>
<h2 id="获取僵尸数据"><a href="#获取僵尸数据" class="headerlink" title="获取僵尸数据"></a><strong>获取僵尸数据</strong></h2><p>现在，让我们看一个使用 <code>call</code> 来访问合约数据的实际例子。</p>
<p>回想一下，我们将僵尸数组声明为 public：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">Zombie[] public zombies;<br></code></pre></div></td></tr></table></figure>

<p>在 Solidity 中，当你声明一个变量为 public 时，它会自动创建一个具有相同名称的公共“getter”函数。因此，如果你想查找 ID 为 15 的僵尸，你可以像调用函数一样使用 <code>zombies(15)</code>。</p>
<p>下面是我们如何在前端编写一个 JavaScript 函数，接受一个僵尸 ID，查询合约中的该僵尸，并返回结果：</p>
<p>注意：我们在本节中使用的所有代码示例都是基于 Web3.js 1.0 版本，该版本使用的是 Promise 而非回调函数。许多在线教程使用的是旧版本的 Web3.js。版本 1.0 的语法变化很大，所以如果你从其他教程复制代码，请确保它们与你使用的版本一致！</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getZombieDetails</span>(<span class="hljs-params">id</span>) &#123;<br>  <span class="hljs-keyword">return</span> cryptoZombies.<span class="hljs-property">methods</span>.<span class="hljs-title function_">zombies</span>(id).<span class="hljs-title function_">call</span>()<br>&#125;<br><br><span class="hljs-comment">// 调用函数并处理结果：</span><br><span class="hljs-title function_">getZombieDetails</span>(<span class="hljs-number">15</span>)<br>.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Zombie 15: &quot;</span> + <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(result));<br>&#125;);<br></code></pre></div></td></tr></table></figure>

<p>让我们一起分析一下这里发生了什么。</p>
<p><code>cryptoZombies.methods.zombies(id).call()</code> 会与 Web3 提供者节点通信，告诉它返回我们合约中 <code>Zombie[] public zombies</code> 数组中的 ID 为 <code>id</code> 的僵尸。</p>
<p>请注意，这是异步的，类似于调用外部服务器的 API。因此，Web3 返回一个 Promise（如果你不熟悉 JavaScript 中的 Promise……在继续之前最好做一些额外的学习！）。</p>
<p>一旦 Promise 被解析（这意味着我们从 Web3 提供者那里收到了响应），我们的示例代码会继续执行 <code>then</code> 语句，并将结果打印到控制台。</p>
<p><code>result</code> 将是一个 JavaScript 对象，类似于下面这样：</p>
<figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;H4XF13LD MORRIS&#x27;S COOLER OLDER BROTHER&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;dna&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1337133713371337&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;level&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;9999&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;readyTime&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1522498671&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;winCount&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;999999999&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;lossCount&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0&quot;</span> <span class="hljs-comment">// 毫无疑问</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></div></td></tr></table></figure>

<p>然后，我们可以在前端逻辑中解析这个对象，并以有意义的方式将它显示出来。</p>
<h2 id="动手实践"><a href="#动手实践" class="headerlink" title="动手实践"></a><strong>动手实践</strong></h2><p>我们已经将 <code>getZombieDetails</code> 函数复制到你的代码中。</p>
<ol>
<li>让我们创建一个类似的函数来获取 <code>zombieToOwner</code>。如果你还记得在 <code>ZombieFactory.sol</code> 中，我们有一个像这样的映射：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">mapping (uint =&gt; address) public zombieToOwner;<br></code></pre></div></td></tr></table></figure>

<p>定义一个名为 <code>zombieToOwner</code> 的 JavaScript 函数。与上面的 <code>getZombieDetails</code> 类似，它将接受一个 <code>id</code> 作为参数，并返回对我们合约中 <code>zombieToOwner</code> 的 Web3.js 调用。</p>
<ol start="2">
<li>接下来，创建第三个函数 <code>getZombiesByOwner</code>。如果你还记得在 <code>ZombieHelper.sol</code> 中，函数定义看起来像这样：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">function getZombiesByOwner(address _owner)<br></code></pre></div></td></tr></table></figure>

<p>我们的 <code>getZombiesByOwner</code> 函数将接受 <code>owner</code> 作为参数，并返回对 <code>getZombiesByOwner</code> 的 Web3.js 调用。</p>
<h1 id="JavaScript-中的-Promise是什么？"><a href="#JavaScript-中的-Promise是什么？" class="headerlink" title="JavaScript 中的 Promise是什么？"></a>JavaScript 中的 Promise是什么？</h1><p>在 JavaScript 中，<strong><code>Promise</code></strong> 是一种用于处理异步操作的机制。它表示一个可能在未来某个时间点完成的操作（异步操作）的结果。可以将其理解为一个“承诺”，即某个操作将在未来完成，并且它会有一个结果（成功或失败）。</p>
<h3 id="Promise-的三个状态"><a href="#Promise-的三个状态" class="headerlink" title="Promise 的三个状态"></a>Promise 的三个状态</h3><p>一个 Promise 对象可以处于以下三种状态之一：</p>
<ol>
<li><strong>Pending（等待中）</strong>：初始状态，表示异步操作尚未完成。</li>
<li><strong>Fulfilled（已完成）</strong>：异步操作已成功完成，并且返回一个结果。</li>
<li><strong>Rejected（已拒绝）</strong>：异步操作失败，返回一个错误原因。</li>
</ol>
<h3 id="Promise-的基本用法"><a href="#Promise-的基本用法" class="headerlink" title="Promise 的基本用法"></a>Promise 的基本用法</h3><h4 id="创建一个-Promise"><a href="#创建一个-Promise" class="headerlink" title="创建一个 Promise"></a>创建一个 Promise</h4><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> myPromise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>  <span class="hljs-keyword">let</span> success = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 模拟一个异步操作的结果</span><br><br>  <span class="hljs-keyword">if</span> (success) &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;操作成功!&quot;</span>);  <span class="hljs-comment">// 如果操作成功，调用 resolve()</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;操作失败!&quot;</span>);  <span class="hljs-comment">// 如果操作失败，调用 reject()</span><br>  &#125;<br>&#125;);<br></code></pre></div></td></tr></table></figure>

<h4 id="使用-then-和-catch-处理-Promise"><a href="#使用-then-和-catch-处理-Promise" class="headerlink" title="使用 .then() 和 .catch() 处理 Promise"></a>使用 <code>.then()</code> 和 <code>.catch()</code> 处理 Promise</h4><ol>
<li><strong><code>.then()</code></strong> 用于处理异步操作成功时的结果。</li>
<li><strong><code>.catch()</code></strong> 用于处理异步操作失败时的错误。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">myPromise<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);  <span class="hljs-comment">// &quot;操作成功!&quot;</span><br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);  <span class="hljs-comment">// 如果 Promise 被拒绝，将打印 &quot;操作失败!&quot;</span><br>  &#125;);<br></code></pre></div></td></tr></table></figure>

<h3 id="示例：使用-Promise-实现异步操作"><a href="#示例：使用-Promise-实现异步操作" class="headerlink" title="示例：使用 Promise 实现异步操作"></a>示例：使用 Promise 实现异步操作</h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncOperation</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">const</span> success = <span class="hljs-literal">true</span>;<br>      <span class="hljs-keyword">if</span> (success) &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;操作完成！&quot;</span>);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;发生错误&quot;</span>);<br>      &#125;<br>    &#125;, <span class="hljs-number">1000</span>);  <span class="hljs-comment">// 模拟一个 1 秒钟后完成的异步操作</span><br>  &#125;);<br>&#125;<br><br><span class="hljs-title function_">asyncOperation</span>()<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">message</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message);  <span class="hljs-comment">// &quot;操作完成！&quot;</span><br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);  <span class="hljs-comment">// 如果失败，将打印 &quot;发生错误&quot;</span><br>  &#125;);<br></code></pre></div></td></tr></table></figure>

<h3 id="Promise-链式调用"><a href="#Promise-链式调用" class="headerlink" title="Promise 链式调用"></a>Promise 链式调用</h3><p>一个常见的用法是将多个异步操作链式调用。每次 <code>.then()</code> 返回一个新的 Promise，可以继续进行处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title function_">asyncOperation</span>()<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">message</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;继续操作&quot;</span>;  <span class="hljs-comment">// 返回一个新的值</span><br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">nextMessage</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nextMessage);  <span class="hljs-comment">// &quot;继续操作&quot;</span><br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);<br>  &#125;);<br></code></pre></div></td></tr></table></figure>

<h3 id="Promise-all-和-Promise-race"><a href="#Promise-all-和-Promise-race" class="headerlink" title="Promise.all() 和 Promise.race()"></a>Promise.all() 和 Promise.race()</h3><ul>
<li><strong><code>Promise.all()</code></strong>：接受一个数组中的多个 Promise，只有所有 Promise 都成功时，才会触发 <code>.then()</code>。如果任何一个 Promise 失败，<code>.catch()</code> 会被触发。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([<span class="hljs-title function_">asyncOperation</span>(), <span class="hljs-title function_">asyncOperation</span>()])<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">results</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(results);  <span class="hljs-comment">// 如果两个异步操作都成功</span><br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);  <span class="hljs-comment">// 如果任何一个异步操作失败</span><br>  &#125;);<br></code></pre></div></td></tr></table></figure>

<ul>
<li><strong><code>Promise.race()</code></strong>：接受多个 Promise，并返回第一个完成的 Promise 的结果，无论是成功还是失败。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([<span class="hljs-title function_">asyncOperation</span>(), <span class="hljs-title function_">asyncOperation</span>()])<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);  <span class="hljs-comment">// 返回第一个完成的 Promise 的结果</span><br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);  <span class="hljs-comment">// 返回第一个失败的 Promise 的错误</span><br>  &#125;);<br></code></pre></div></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>Promise</code> 使得异步操作的代码更加简洁和易于管理，通过 <code>.then()</code>、<code>.catch()</code> 等方法可以更清晰地处理成功或失败的结果，避免了回调地狱（callback hell）问题。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Web3/">Web3</a>
                    
                  </div>
                
              </div>
              
                
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/11/27/12999.html">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">cryptozombies6-总结、感谢与建议</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/11/25/62278.html">
                        <span class="hidden-mobile">cryptozombies4</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


            

                
                  <a id="scroll-top-button" href="#" role="button">
                    <i class="iconfont icon-arrowup" aria-hidden="true"></i>
                  </a>
                  

                    

                          
      </main>

      <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://whale3070.github.io/" target="_blank" rel="nofollow noopener"><span>Whale3070</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<link href="/pagefind/pagefind-ui.css" rel="stylesheet">
  <script src="/pagefind/pagefind-ui.js"></script>
  <style>
    /* 搜索框配色适配 */
    #search { margin-top: 2rem; }
    [data-user-color-scheme='dark'] .pagefind-ui {
      --pagefind-ui-primary: #eeeeee;
      --pagefind-ui-text: #eeeeee;
      --pagefind-ui-background: #151515;
      --pagefind-ui-border: #333;
    }
  </style>
    </body>

  </html>