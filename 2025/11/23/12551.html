

  <!DOCTYPE html>
  <html lang="zh-CN" data-default-color-scheme=&#34;dark&#34; >
  <style>
    .text1
    {
    text-shadow: 0px 0px 2px #f2f3f2;
    }
    </style>

  

<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/null">
  <link rel="icon" type="image/png" href="/null">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>cryptozombies3 - whale3070&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"192.168.126.129","root":"/","version":"1.8.7","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 7.3.0"></head>


    <body>
      <header style="height: 70vh;">
        <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>InfoSec learning</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/search/">
                <i class="iconfont icon-search"></i>
                搜索
              </a>
            </li>
          
        
        
        
          
        
      </ul>
    </div>
  </div>
</nav>

          <div class="banner" id="banner" false
            style="background: url('/img/default.png') no-repeat center center;
              background-size: cover;">
              <div class="full-bg-img">
                <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
                  <div class="page-header text-center fade-in-up">
                    <span class="h2 text1" id="subtitle" title="cryptozombies3">
                      
                        cryptozombies3
                      
                    </span>
        
                    
                      <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2025-11-23 02:04" pubdate>
        2025年11月23日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6.2k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      69
       分钟
    </span>
  

  
  
</div>

                    
                  </div>
                    
                  </div>
                  
                </div>
              </div>
          </div>
      </header>

      <main>
        
          

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" data-pagefind-body>
            <!-- SEO header -->
            <h1 style="display: none">cryptozombies3</h1>
            
            <div class="markdown-body">
              <h1 id="第十章：用view函数节省燃料"><a href="#第十章：用view函数节省燃料" class="headerlink" title="第十章：用view函数节省燃料"></a>第十章：用<code>view</code>函数节省燃料</h1><p>太棒了！现在我们的高级僵尸拥有特殊能力了，这能激励主人给它们升级。以后我们还可以添加更多这类功能。</p>
<p>让我们再添加一个函数：我们的DApp需要一个查看用户所有僵尸军团的方法，就命名为<code>getZombiesByOwner</code>吧。</p>
<p>这个函数只需从区块链读取数据，因此可以设为<code>view</code>函数。这正好引出了关于燃料优化的重要知识点：</p>
<h2 id="view函数不消耗燃料"><a href="#view函数不消耗燃料" class="headerlink" title="view函数不消耗燃料"></a>view函数不消耗燃料</h2><p>当用户外部调用<code>view</code>函数时，不需要支付任何燃料。</p>
<p>这是因为<code>view</code>函数不会真正改变区块链上的任何数据——它们只是读取数据。所以用<code>view</code>修饰函数时，相当于告诉web3.js只需查询本地以太坊节点即可运行该函数，而无需在区块链上创建交易（交易需要每个节点共同验证且消耗燃料）。</p>
<p>后续我们会讲解如何用自有节点配置web3.js。现在关键要记住：尽量使用只读的外部<code>view</code>函数，可以为用户优化DApp的燃料消耗。</p>
<p>注意：如果<code>view</code>函数在合约内部被非<code>view</code>函数调用，仍会消耗燃料。因为调用它的函数正在创建以太坊交易，仍需所有节点验证。所以唯有外部调用时<code>view</code>函数才是免费的。</p>
<h2 id="实践环节"><a href="#实践环节" class="headerlink" title="实践环节"></a>实践环节</h2><p>我们将实现返回用户全部僵尸军团的功能。后续可以在web3.js中调用此功能，在用户资料页展示其完整军团。</p>
<p>该函数逻辑较为复杂，需要分几个章节完成。</p>
<ol>
<li>创建名为<code>getZombiesByOwner</code>的新函数，参数为<code>_owner</code>（地址类型）</li>
<li>将其设为<code>external view</code>函数，以便通过web3.js免燃料调用</li>
<li>函数返回类型声明为<code>uint[]</code>（动态数组），数据位置设置为<code>memory</code></li>
<li>函数体暂时留空，下一章我们再完善实现</li>
</ol>
<p>答案： </p>
<figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> getZombiesByOwner(address _owner) <span class="hljs-keyword">external</span> <span class="hljs-keyword">view</span> <span class="hljs-keyword">returns</span>(uint[] memory)<br></code></pre></div></td></tr></table></figure>

<p>returns返回值要放在view的后面，而不是function的下面，为什么？</p>
<p>您说得对！这个语法确实容易混淆。让我来解释一下Solidity函数声明的结构顺序：</p>
<p><strong>正确的语法顺序是：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">function 函数名(参数) 可见性 状态可变性 returns (返回值类型) &#123;<br>    // 函数体<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><strong>具体到您的例子：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">function getZombiesByOwner(address _owner) external view returns (uint[] memory)<br></code></pre></div></td></tr></table></figure>

<p><strong>为什么是这个顺序？</strong></p>
<ol>
<li><strong><code>function</code></strong> - 函数声明关键字</li>
<li><strong><code>getZombiesByOwner</code></strong> - 函数名</li>
<li><strong><code>(address _owner)</code></strong> - 参数列表</li>
<li><strong><code>external</code></strong> - 可见性修饰符（函数能被谁调用）</li>
<li><strong><code>view</code></strong> - 状态可变性（函数对状态变量的操作权限）</li>
<li><strong><code>returns (uint[] memory)</code></strong> - 返回类型声明</li>
</ol>
<p><strong>逻辑解释：</strong></p>
<ul>
<li>先定义函数的<strong>身份</strong>（名字、参数）</li>
<li>再定义函数的<strong>行为特性</strong>（谁能调用、能做什么操作）</li>
<li>最后定义函数的<strong>产出结果</strong>（返回什么）</li>
</ul>
<p>这种语法设计让函数声明更加清晰：先说明函数是什么，再说明函数能做什么，最后说明函数返回什么。</p>
<p>您提出的问题很好，这确实是Solidity初学者经常困惑的地方！</p>
<h1 id="第十一章：存储操作十分昂贵"><a href="#第十一章：存储操作十分昂贵" class="headerlink" title="第十一章：存储操作十分昂贵"></a>第十一章：存储操作十分昂贵</h1><p>在Solidity中，使用存储（storage）是成本最高的操作之一——尤其是写入操作。</p>
<p>这是因为每次写入或修改数据时，该数据都会被永久记录到区块链上。永远存在！全球成千上万的节点都需要将这份数据存储在他们的硬盘上，而且随着区块链的增长，数据量会持续扩大。因此进行存储操作需要付出代价。</p>
<p>为了控制成本，除非绝对必要，否则应避免向存储中写入数据。有时这可能需要采用看似低效的程序逻辑——例如每次函数调用时在内存中重建数组，而不是将数组保存在变量中以便快速查找。</p>
<p>在大多数编程语言中，遍历大型数据集的成本很高。但在Solidity中，如果是在外部view函数中执行此操作，其成本远低于使用存储操作，因为view函数不会让用户支付任何燃料费（而燃料消耗直接关系到用户的真实金钱支出）。</p>
<p>我们将在下一章详细讨论循环语句，不过首先来学习如何在内存中声明数组。</p>
<h2 id="在内存中声明数组"><a href="#在内存中声明数组" class="headerlink" title="在内存中声明数组"></a>在内存中声明数组</h2><p>你可以对数组使用memory关键字，以便在函数内部创建一个新数组，而无需向存储中写入任何内容。该数组仅在函数调用期间存在，从燃料成本角度看，这比更新存储中的数组要便宜得多——如果是在外部调用的view函数中，则完全免费。</p>
<p>以下是在内存中声明数组的方法：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> getArray() <span class="hljs-keyword">external</span> pure <span class="hljs-keyword">returns</span>(uint[] memory) &#123;<br>  // Instantiate a <span class="hljs-built_in">new</span> <span class="hljs-keyword">array</span> <span class="hljs-keyword">in</span> memory <span class="hljs-keyword">with</span> a length <span class="hljs-keyword">of</span> <span class="hljs-number">3</span><br>  uint[] memory <span class="hljs-keyword">values</span> = <span class="hljs-built_in">new</span> uint[](<span class="hljs-number">3</span>);<br><br>  // Put <span class="hljs-keyword">some</span> <span class="hljs-keyword">values</span> <span class="hljs-keyword">to</span> it<br>  <span class="hljs-keyword">values</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">values</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">values</span>[<span class="hljs-number">2</span>] = <span class="hljs-number">3</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">values</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>这只是一个简单的语法示例，在下一章中我们将结合循环语句来探讨实际应用场景。</p>
<p>注意：内存数组创建时必须指定长度参数（本例中为3）。目前它们不能像存储数组那样使用array.push()来调整大小，不过这个特性可能在未来的Solidity版本中有所改变。</p>
<h2 id="实践环节-1"><a href="#实践环节-1" class="headerlink" title="实践环节"></a>实践环节</h2><p>在我们的getZombiesByOwner函数中，需要返回一个uint[]数组，包含特定用户拥有的所有僵尸。</p>
<ol>
<li>声明一个名为result的uint[] memory变量</li>
<li>将其初始化为一个新的uint数组。数组长度应该是该_owner拥有的僵尸数量，我们可以通过映射关系查询：ownerZombieCount[_owner]</li>
<li>在函数末尾返回result。目前这还是个空数组，下一章我们将完善其内容。</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-built_in">uint</span>[] memory result = <span class="hljs-keyword">new</span> <span class="hljs-built_in">uint</span>[](ownerZombieCount[_owner]);<br></code></pre></div></td></tr></table></figure>

<h1 id="第十二章：For-循环"><a href="#第十二章：For-循环" class="headerlink" title="第十二章：For 循环"></a>第十二章：For 循环</h1><p>在上一章我们提到，有时候您会希望在函数中使用 for 循环来构建数组内容，而不是简单地将数组存入存储。</p>
<p>让我们来看看具体原因。</p>
<p>对于我们的 getZombiesByOwner 函数，一个简单的实现方式是在 ZombieFactory 合约中存储一个所有者到僵尸军团的映射：</p>
<p>mapping (address &#x3D;&gt; uint[]) public ownerToZombies</p>
<p>这样每次创建新僵尸时，我们只需使用 ownerToZombies[owner].push(zombieId) 将其添加到该所有者的僵尸数组中。而 getZombiesByOwner 函数就会变得非常简单直接：</p>
<figure class="highlight ada"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">getZombiesByOwner</span>(address _owner) external view returns (uint[] memory) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">ownerToZombies[_owner]</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="这种方法的缺陷"><a href="#这种方法的缺陷" class="headerlink" title="这种方法的缺陷"></a>这种方法的缺陷</h2><p>这种方法因其简洁性而颇具吸引力。但设想一下，如果我们后续要添加转移僵尸所有权的功能（在后续课程中肯定会实现！），会发生什么情况？</p>
<p>这个转移函数需要：</p>
<ol>
<li>将僵尸添加到新主人的 ownerToZombies 数组</li>
<li>从原主人的 ownerToZombies 数组中移除该僵尸</li>
<li>将原主人数组中剩余的所有僵尸向前移动一位以填补空缺</li>
<li>将数组长度减1</li>
</ol>
<p>其中第3步在燃气消耗方面代价极高，因为我们需要为每个移动位置的僵尸执行写入操作。如果一个主人拥有20个僵尸并交易掉第一个，我们就需要进行19次写入来维持数组顺序。</p>
<p>由于存储写入是 Solidity 中最耗燃气的操作之一，每次调用这个转移函数都会产生极高的燃气成本。更糟糕的是，根据用户拥有的僵尸数量和被交易僵尸的索引位置，每次调用的燃气消耗量都不相同，导致用户无法预知需要支付多少燃气。</p>
<p>注意：当然，我们可以用数组末尾的僵尸来填补空缺位置，再将数组长度减1。但这样做会导致每次交易都会改变僵尸军团的排序顺序。</p>
<p>由于视图函数在外部调用时不会消耗燃气，我们可以在 getZombiesByOwner 中使用 for 循环遍历整个僵尸数组，构建属于特定主人的僵尸列表。这样我们的转移函数将变得经济很多，因为不需要重组存储中的任何数组——虽然看似绕远路，实际上这种方案的整体成本反而更低。</p>
<p>for 循环的使用<br>Solidity 中 for 循环的语法与 JavaScript 类似。</p>
<p>来看一个创建偶数数组的示例：</p>
<figure class="highlight zephir"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs zephir"><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getEvens</span><span class="hljs-params">()</span> <span class="hljs-title">pure</span> <span class="hljs-title">external</span> <span class="hljs-title">returns</span><span class="hljs-params">(<span class="hljs-keyword">uint</span>[] memory)</span> </span>&#123;<br>  <span class="hljs-keyword">uint</span>[] memory evens = <span class="hljs-keyword">new</span> <span class="hljs-keyword">uint</span>[](<span class="hljs-number">5</span>);<br>  <span class="hljs-comment">// Keep track of the index in the new array:</span><br>  <span class="hljs-keyword">uint</span> counter = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// Iterate 1 through 10 with a for loop:</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>    <span class="hljs-comment">// If `i` is even...</span><br>    <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// Add it to our array</span><br>      evens[counter] = i;<br>      <span class="hljs-comment">// Increment counter to the next empty index in `evens`:</span><br>      counter++;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> evens;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>该函数将返回一个包含 [2, 4, 6, 8, 10] 的数组。</p>
<p>实践演练<br>让我们通过编写一个 for 循环来完成 getZombiesByOwner 函数，该循环将遍历 DApp 中的所有僵尸，比对它们的所有者是否匹配，并将匹配的僵尸添加到结果数组中返回。</p>
<ol>
<li><p>声明一个名为 counter 的 uint 变量并初始化为 0。我们将用这个变量来跟踪结果数组的索引位置。</p>
</li>
<li><p>声明一个 for 循环，从 uint i &#x3D; 0 开始，直到 i &lt; zombies.length。这将遍历数组中的每个僵尸。</p>
</li>
<li><p>在 for 循环内部，使用 if 语句检查 zombieToOwner[i] 是否等于 _owner。这将通过比较两个地址来判断是否匹配。</p>
</li>
<li><p>在 if 语句中：</p>
<ul>
<li>通过设置 result[counter] &#x3D; i 将僵尸 ID 添加到结果数组</li>
<li>将 counter 递增 1（参考上文 for 循环示例）</li>
</ul>
</li>
</ol>
<p>至此，这个函数将返回 _owner 拥有的所有僵尸，且不会消耗任何燃气。</p>
<h1 id="第13章：总结收尾"><a href="#第13章：总结收尾" class="headerlink" title="第13章：总结收尾"></a>第13章：总结收尾</h1><p>恭喜你！第3课到此结束。</p>
<p>让我们回顾一下：</p>
<ul>
<li>我们实现了 CryptoKitties 合约的更新方案</li>
<li>学习了使用 <code>onlyOwner</code> 修饰符保护核心函数</li>
<li>了解了 Gas（燃气费）及 Gas 优化相关知识</li>
<li>为僵尸添加了等级（levels）和冷却时间（cooldowns）机制</li>
<li>实现了僵尸达到特定等级后可更新名称（name）和 DNA 的函数</li>
<li>最终完成了返回用户僵尸军团的查询函数</li>
</ul>
<p>领取你的奖励<br>作为完成第3课的奖励，你的两只僵尸均已升级！</p>
<p>现在，你在第2课创建的猫咪僵尸「无名」（NoName）已升级至2级，你可以调用 <code>changeName</code> 函数为它命名。从此告别「无名」啦！</p>
<p>快去给你的「无名」僵尸起个名字，然后进入下一章完成本课程的全部内容吧。</p>
<p><a target="_blank" rel="noopener" href="https://share.cryptozombies.io/en/lesson/3/share/111111111111111111111111?id=Y3p8NjY1NTA4">https://share.cryptozombies.io/en/lesson/3/share/111111111111111111111111?id=Y3p8NjY1NTA4</a></p>
<h1 id="第1章：Payable（可接收ETH修饰符）"><a href="#第1章：Payable（可接收ETH修饰符）" class="headerlink" title="第1章：Payable（可接收ETH修饰符）"></a>第1章：Payable（可接收ETH修饰符）</h1><p>到目前为止，我们已经介绍了多种函数修饰符。要记住所有内容可能有些困难，因此我们快速回顾一下：</p>
<p>首先是<strong>可见性修饰符</strong>，用于控制函数的调用时机和范围：</p>
<ul>
<li><code>private</code>（私有）：仅能被合约内部的其他函数调用；</li>
<li><code>internal</code>（内部）：类似<code>private</code>，但继承自该合约的子合约也可调用；</li>
<li><code>external</code>（外部）：仅能从合约外部调用；</li>
<li><code>public</code>（公开）：可在任意位置调用（内部、外部均可）。</li>
</ul>
<p>其次是<strong>状态修饰符</strong>，用于说明函数与区块链的交互方式：</p>
<ul>
<li><code>view</code>（只读）：调用函数不会保存或修改区块链上的任何数据；</li>
<li><code>pure</code>（纯函数）：函数不仅不会向区块链写入数据，也不会从区块链读取数据。<blockquote>
<p>注意：如果这两种修饰符的函数从合约外部调用，不会消耗任何Gas（燃气费）；但如果被合约内部的其他函数调用，则会产生Gas消耗。</p>
</blockquote>
</li>
</ul>
<p>最后是<strong>自定义修饰符</strong>（我们在第3课中学习过），例如<code>onlyOwner</code>（仅所有者可调用）和<code>aboveLevel</code>（等级达标可调用）等。我们可以通过自定义逻辑来定义这些修饰符对函数的限制规则。</p>
<p>这些修饰符可以在函数定义时叠加使用，示例如下：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> test() <span class="hljs-keyword">external</span> <span class="hljs-keyword">view</span> onlyOwner anotherModifier &#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></div></td></tr></table></figure>

<p>在本章中，我们将介绍另一个函数修饰符：payable（可支付）。</p>
<h2 id="payable-修饰符"><a href="#payable-修饰符" class="headerlink" title="payable 修饰符"></a>payable 修饰符</h2><p>payable函数正是体现 Solidity 与以太坊独特魅力的关键——它们是一种能够接收以太币的特殊函数。</p>
<p>请仔细思考这一点。当您在普通网络服务器上调用 API 函数时，您无法在调用函数的同时发送美元——也无法发送比特币。</p>
<p>但在以太坊中，由于货币（以太币）、数据（交易负载）和合约代码本身都共存于以太坊网络，这使得您在调用函数的同时向合约支付资金成为可能。</p>
<p>这为实现各种精彩逻辑创造了条件，例如要求必须向合约支付特定金额才能执行某个函数。</p>
<p>让我们通过示例来具体理解：</p>
<figure class="highlight scss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scss">contract OnlineStore &#123;<br>  function <span class="hljs-built_in">buySomething</span>() external payable &#123;<br>    <span class="hljs-comment">// Check to make sure 0.001 ether was sent to the function call:</span><br>    <span class="hljs-built_in">require</span>(msg.value == <span class="hljs-number">0.001</span> ether);<br>    <span class="hljs-comment">// If so, some logic to transfer the digital item to the caller of the function:</span><br>    <span class="hljs-built_in">transferThing</span>(msg.sender);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>这里的 msg.value 是用于查看向合约转入 ETH 数量的内置属性，而 ether 是 Solidity 中的原生单位（1 ether &#x3D; 10¹⁸ wei）。<br>具体操作逻辑是：用户会通过 web3.js（即 DApp 的 JavaScript 前端）调用该函数，示例代码如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-comment">// Assuming `OnlineStore` points to your contract on Ethereum:</span><br>OnlineStore<span class="hljs-selector-class">.buySomething</span>(&#123;from: web3<span class="hljs-selector-class">.eth</span><span class="hljs-selector-class">.defaultAccount</span>, value: web3<span class="hljs-selector-class">.utils</span><span class="hljs-selector-class">.toWei</span>(<span class="hljs-number">0.001</span>)&#125;)<br></code></pre></div></td></tr></table></figure>

<p>注意 <code>value</code> 字段——JavaScript函数调用通过它指定要发送的ETH数量（此处为0.001）。<br>如果你把交易比作一个<strong>信封</strong>，函数调用的参数是你放在信封里的<strong>信件内容</strong>，那么添加 <code>value</code> 就像是在信封里放<strong>现金</strong>——信件和钱会一起送达收件人（合约）。</p>
<blockquote>
<p>注意：如果函数没有标记 <code>payable</code>，却尝试像上面那样发送ETH，该函数会<strong>拒绝你的交易</strong>。</p>
</blockquote>
<h3 id="实战练习"><a href="#实战练习" class="headerlink" title="实战练习"></a>实战练习</h3><p>让我们在僵尸游戏中创建一个 <code>payable</code> 函数。  </p>
<p>假设游戏有个功能：用户可以支付ETH来提升僵尸等级。这些ETH会存储在你拥有的合约中——这是一个简单的例子，展示了如何在游戏中赚钱！</p>
<p>请按以下步骤实现：  </p>
<ol>
<li>定义一个 <code>uint</code> 类型的变量 <code>levelUpFee</code>，赋值为 <code>0.001 ether</code>；  </li>
<li>创建一个名为 <code>levelUp</code> 的函数，参数为 <code>_zombieId</code>（<code>uint</code> 类型），函数可见性为 <code>external</code> 且标记 <code>payable</code>；  </li>
<li>函数内部首先通过 <code>require</code> 检查 <code>msg.value</code> 是否等于 <code>levelUpFee</code>；  </li>
<li>然后将对应僵尸的等级加1：<code>zombies[_zombieId].level++</code>。</li>
</ol>
<h3 id="关键技术点说明"><a href="#关键技术点说明" class="headerlink" title="关键技术点说明"></a>关键技术点说明</h3><ol>
<li><p><strong><code>value</code> 字段的作用</strong>：<br>在Web3.js调用合约函数时，<code>value</code> 是额外传递的交易参数，用于指定伴随交易发送的ETH数量（单位默认是 wei，需显式用 <code>ether</code> 单位时要确保Web3库支持单位转换）。  </p>
</li>
<li><p><strong><code>payable</code> 修饰符的必要性</strong>：<br>合约函数必须标记 <code>payable</code> 才能接收ETH，否则会触发 <code>revert</code> 操作，交易失败且ETH会退回发送者。  </p>
</li>
<li><p><strong><code>msg.value</code> 与 <code>levelUpFee</code> 的关系</strong>：<br><code>msg.value</code> 是实际传入的ETH数量，<code>levelUpFee</code> 是合约规定的“升级费用”，通过 <code>require</code> 强制两者相等，确保用户支付正确金额才能执行升级逻辑。  </p>
</li>
<li><p><strong>状态修改逻辑</strong>：<br><code>zombies[_zombieId].level++</code> 会修改合约存储的僵尸状态，因此该函数不能标记 <code>view</code> 或 <code>pure</code>，且会消耗Gas（由交易发送者支付）。</p>
</li>
</ol>
<h1 id="第-2-章：提款（Withdraws）"><a href="#第-2-章：提款（Withdraws）" class="headerlink" title="第 2 章：提款（Withdraws）"></a>第 2 章：提款（Withdraws）</h1><p>在上一章中，我们学习了如何向合约发送以太币（Ether）。那么，在你发送之后，这些以太币会发生什么呢？<br>当你向合约发送以太币后，它会被存储在该合约的以太坊账户中，并且会被困在那里—— 除非你添加一个函数来从合约中 ** 提取（withdraw）** 以太币。<br>你可以通过编写如下函数来从合约中提取以太币：</p>
<figure class="highlight isbl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs isbl"><span class="hljs-variable">contract</span> <span class="hljs-variable">GetPaid</span> <span class="hljs-variable">is</span> <span class="hljs-variable">Ownable</span> &#123;<br>  <span class="hljs-variable">function</span> <span class="hljs-function"><span class="hljs-title">withdraw</span>() <span class="hljs-variable">external</span> <span class="hljs-variable">onlyOwner</span> &#123;</span><br><span class="hljs-function">    <span class="hljs-variable">address</span> <span class="hljs-variable">payable</span> <span class="hljs-variable">_owner</span> = <span class="hljs-title">address</span>(<span class="hljs-title">uint160</span>(<span class="hljs-title">owner</span>()));</span><br><span class="hljs-function">    <span class="hljs-variable">_owner.transfer</span>(<span class="hljs-title">address</span>(<span class="hljs-variable">this</span>).balance);</span><br><span class="hljs-function">  &#125;</span><br><span class="hljs-function">&#125;</span><br></code></pre></div></td></tr></table></figure>

<p>注意，我们在此使用了 Ownable 合约中的 owner() 函数和 onlyOwner 修饰符，前提是该合约已被导入。<br>需要重点注意的是：你无法向一个地址转账 ETH，除非该地址是 address payable 类型。但 _owner 变量的类型是 uint160（这是 Ownable 合约中对所有者地址的底层存储类型），这意味着我们必须显式地将其转换为 address payable 类型。<br>一旦你将地址从 uint160 转换为 address payable，就可以使用 .transfer() 函数向该地址转账 ETH 了。其中，address(this).balance 会返回当前合约中存储的 ETH 总余额。例如，如果有 100 个用户各向我们的合约支付了 1 个 ETH，那么 address(this).balance 的值就会等于 100 个 ETH。<br>你可以使用 .transfer() 函数向任何以太坊地址发送资金。例如，你可以编写一个函数，当用户为某个物品多支付了费用时，将多付的部分退还给 msg.sender：</p>
<figure class="highlight abnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs abnf">uint itemFee <span class="hljs-operator">=</span> <span class="hljs-number">0.001</span> ether<span class="hljs-comment">;</span><br>msg.sender.transfer(msg.value - itemFee)<span class="hljs-comment">;</span><br></code></pre></div></td></tr></table></figure>

<p>或者在一个包含买家和卖家的合约中，你可以将卖家的地址存储起来，当有人购买他的物品时，就将买家支付的费用转账给卖家：seller.transfer(msg.value)。<br>这些例子充分展现了以太坊编程的魅力所在 —— 你可以构建这样的去中心化市场，它们不受任何人控制。</p>
<h2 id="实战练习-1"><a href="#实战练习-1" class="headerlink" title="实战练习"></a>实战练习</h2><p>在我们的合约中创建一个提款函数，功能与上面的「GetPaid」示例完全相同；<br>过去一年，ETH 的价格上涨了超过 10 倍。因此，虽然在撰写本文时 0.001 ETH 大约价值 1 美元，但如果再上涨 10 倍，0.001 ETH 就会变成 10 美元，我们的游戏成本就会变得高得多。<br>所以，创建一个允许合约所有者设置 levelUpFee 的函数是个好主意。<br>请按以下要求实现：</p>
<p>a. 创建一个名为 setLevelUpFee 的函数，参数为 _fee（uint 类型），函数可见性为 external，并使用 onlyOwner 修饰符；</p>
<p>b. 函数内部将 levelUpFee 的值设置为 _fee。</p>
<h1 id="第-3-章：僵尸对战"><a href="#第-3-章：僵尸对战" class="headerlink" title="第 3 章：僵尸对战"></a>第 3 章：僵尸对战</h1><p>第 3 章：僵尸对战(Zombie Battles)现在我们已经学习了可支付函数（payable functions）和合约余额（contract balances），是时候为我们的僵尸游戏添加对战功能了！<br>按照前几章的格式，我们将通过创建一个新文件 &#x2F; 合约来组织代码，这个新合约将导入（import）之前的合约，并实现攻击功能。</p>
<h2 id="实战练习-Put-it-to-the-test"><a href="#实战练习-Put-it-to-the-test" class="headerlink" title="实战练习 (Put it to the test)"></a>实战练习 (Put it to the test)</h2><p>让我们回顾一下如何创建一个新合约。重复有助于精通！<br>如果不记得具体的语法，可以参考 zombiehelper.sol 文件 —— 但请先尝试独立完成，以此来检验你的知识掌握程度。<br>在文件顶部声明本合约使用的 Solidity 版本为 &gt;&#x3D;0.5.0 &lt;0.6.0。<br>从 zombiehelper.sol 导入合约。<br>声明一个名为 ZombieAttack 的新合约，它继承自 ZombieHelper。目前，让合约体保持为空。</p>
<h1 id="第-4-章：随机数-Random-Numbers"><a href="#第-4-章：随机数-Random-Numbers" class="headerlink" title="第 4 章：随机数 (Random Numbers)"></a>第 4 章：随机数 (Random Numbers)</h1><p>很好！现在让我们来设计战斗逻辑。<br>所有优秀的游戏都需要一定程度的随机性。那么，我们如何在 Solidity 中生成随机数呢？<br>真正的答案是：你无法生成真正安全的随机数。嗯，至少无法安全地做到这一点。<br>让我们来看看为什么。<br>通过 keccak256 生成随机数在 Solidity 中，我们能获取的最好的 “随机性” 来源是 keccak256 哈希函数。<br>我们可以通过类似下面的方式来 “生成” 一个随机数：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-comment">// Generate a random number between 1 and 100:</span><br><span class="hljs-built_in">uint</span> randNonce = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">uint</span> random = <span class="hljs-built_in">uint</span>(keccak256(abi.encodePacked(now, msg.sender, randNonce))) % <span class="hljs-number">100</span>;<br>randNonce++;<br><span class="hljs-built_in">uint</span> random2 = <span class="hljs-built_in">uint</span>(keccak256(abi.encodePacked(now, msg.sender, randNonce))) % <span class="hljs-number">100</span>;<br></code></pre></div></td></tr></table></figure>

<p>这个函数的工作原理如下：它会获取当前的时间戳（now）、消息发送者地址（msg.sender）和一个递增的随机数种子（nonce，一个只使用一次的数字，确保我们不会对相同的输入参数两次执行相同的哈希函数）。</p>
<p>然后，它会将这些输入 <strong>“打包”</strong>（pack）在一起，并使用 keccak 函数将它们转换为一个随机哈希值（random hash）。接下来，它会将这个哈希值转换为一个无符号整数（uint），然后使用取模运算符 % 100 来获取其最后两位。这将为我们提供一个介于 0 和 99 之间的完全随机数。</p>
<h2 id="这种方法容易受到恶意节点的攻击"><a href="#这种方法容易受到恶意节点的攻击" class="headerlink" title="这种方法容易受到恶意节点的攻击"></a>这种方法容易受到恶意节点的攻击</h2><p>在以太坊中，当你调用合约的某个函数时，你会将这个调用作为一笔交易广播到网络中的一个或多个节点。网络中的节点随后会收集大量交易，尝试率先解决一个计算密集型的数学问题（即 “工作量证明”，Proof of Work），然后将这组交易连同其工作量证明一起打包成一个区块，发布到整个网络。<br>一旦某个节点解决了工作量证明，其他节点就会停止尝试，转而验证该节点的交易列表是否有效，然后接受这个区块，并继续尝试解决下一个区块。<br>这就使得我们的随机数函数存在被利用的漏洞。<br>假设我们有一个猜硬币合约 —— 猜对（ heads ）你就能翻倍资金，猜错（ tails ）你就输掉所有。假设它使用上述的随机函数来决定正反面（随机数 &gt;&#x3D; 50 为正面， &lt; 50 为反面）。<br>如果我正在运行一个节点，我可以只将我的交易发布到我自己的节点，而不分享给其他节点。然后我可以调用猜硬币函数，看看自己是否赢了 —— 如果输了，我就选择不将这笔交易包含在我正在打包的下一个区块中。我可以无限次地这样做，直到我最终赢得猜硬币游戏，并且成功打包下一个区块，从而获利。</p>
<h2 id="那么，我们如何在以太坊中安全地生成随机数呢？"><a href="#那么，我们如何在以太坊中安全地生成随机数呢？" class="headerlink" title="那么，我们如何在以太坊中安全地生成随机数呢？"></a>那么，我们如何在以太坊中安全地生成随机数呢？</h2><p>由于区块链的全部内容对所有参与者都是可见的，这是一个难题，其解决方案超出了本教程的范围。你可以阅读这个 StackOverflow 帖子获取一些思路。其中一个想法是使用 “预言机（oracle）” 来访问以太坊区块链之外的随机数函数。<br>当然，由于网络上有数万个以太坊节点在竞争打包下一个区块，我成功打包下一个区块的概率极低。我需要花费大量时间或计算资源才能通过这种方式获利 —— 但如果回报足够高（比如我可以在猜硬币函数上下注 1 亿美元），那么对我来说发动攻击就是值得的。<br>因此，尽管这种随机数生成方法在以太坊上并非绝对安全，但在实践中，除非我们的随机函数涉及大量资金，否则你的游戏用户可能没有足够的资源来攻击它。<br>由于我们在本教程中只是为了演示目的构建一个简单的游戏，并且不涉及真实资金，所以我们将接受使用这种易于实现的随机数生成器的 tradeoffs（权衡取舍），同时清楚它并非完全安全。<br>在未来的课程中，我们可能会介绍使用预言机（一种从以太坊外部获取数据的安全方式）来从区块链之外生成安全的随机数。</p>
<h2 id="实战练习-2"><a href="#实战练习-2" class="headerlink" title="实战练习"></a>实战练习</h2><p>让我们实现一个随机数函数，用于决定我们游戏中战斗的结果，尽管它并非完全不会受到攻击。</p>
<ol>
<li><p>给我们的合约添加一个 uint 类型的变量 randNonce，并将其值设置为 0。</p>
</li>
<li><p>创建一个名为 randMod（随机取模）的函数。它是一个 internal（内部）函数，接收一个名为 _modulus 的 uint 参数，并返回一个 uint。</p>
</li>
<li><p>函数内部首先要递增 randNonce（使用 randNonce++ 语法）。</p>
</li>
<li><p>最后，它需要（在一行代码中）计算 abi.encodePacked(now, msg.sender, randNonce) 的 keccak256 哈希值，并将其类型转换为 uint，然后返回该值对 _modulus 取模的结果（… % _modulus）。<br>（呼！这有点拗口。如果没跟上，只需回顾一下我们之前生成随机数的例子 —— 逻辑非常相似。）</p>
</li>
</ol>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Web3/">Web3</a>
                    
                  </div>
                
              </div>
              
                
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/11/23/44611.html">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">我的生平（二十九）</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/11/22/45235.html">
                        <span class="hidden-mobile">我的生平（二十八）</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


            

                
                  <a id="scroll-top-button" href="#" role="button">
                    <i class="iconfont icon-arrowup" aria-hidden="true"></i>
                  </a>
                  

                    

                          
      </main>

      <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://whale3070.github.io/" target="_blank" rel="nofollow noopener"><span>Whale3070</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<link href="/pagefind/pagefind-ui.css" rel="stylesheet">
  <script src="/pagefind/pagefind-ui.js"></script>
  <style>
    /* 搜索框配色适配 */
    #search { margin-top: 2rem; }
    [data-user-color-scheme='dark'] .pagefind-ui {
      --pagefind-ui-primary: #eeeeee;
      --pagefind-ui-text: #eeeeee;
      --pagefind-ui-background: #151515;
      --pagefind-ui-border: #333;
    }
  </style>
    </body>

  </html>