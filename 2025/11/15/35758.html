

  <!DOCTYPE html>
  <html lang="zh-CN" data-default-color-scheme=&#34;dark&#34; >
  <style>
    .text1
    {
    text-shadow: 0px 0px 2px #f2f3f2;
    }
    </style>

  <script>
    // 强制内网 IP 识别为安全上下文
    if (window.location.hostname !== 'localhost' && window.location.protocol === 'http:') {
        // 尝试手动映射 crypto 属性
        if (!window.crypto.subtle && window.crypto.webkitSubtle) {
            window.crypto.subtle = window.crypto.webkitSubtle;
        }
    }
    
    // 终极补丁：如果还是没有 subtle，则创建一个占位符避免报错
    // 提示：这通常能解决加载报错，但如果插件强依赖原生加密，建议执行下面的“降级”预判
    if (!window.isSecureContext) {
        console.warn('当前环境非安全上下文，正在尝试兼容内网加密解密...');
    }
</script>


<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/null">
  <link rel="icon" type="image/png" href="/null">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>remix编译运行solidity10 - whale3070&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.4.0/styles/github-gist.min.css" />
    
  

  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"whale3070.github.io","root":"/","version":"1.8.7","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":false,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 7.3.0"></head>


    <body>
      <header style="height: 70vh;">
        <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>InfoSec learning</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/search/">
                <i class="iconfont icon-search"></i>
                搜索
              </a>
            </li>
          
        
        
        
          
        
      </ul>
    </div>
  </div>
</nav>

          <div class="banner" id="banner" false
            style="background: url('/img/default.png') no-repeat center center;
              background-size: cover;">
              <div class="full-bg-img">
                <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
                  <div class="page-header text-center fade-in-up">
                    <span class="h2 text1" id="subtitle" title="remix编译运行solidity10">
                      
                        remix编译运行solidity10
                      
                    </span>
        
                    
                      <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2025-11-15 11:25" pubdate>
        2025年11月15日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      4.7k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      54
       分钟
    </span>
  

  
  
</div>

                    
                  </div>
                    
                  </div>
                  
                </div>
              </div>
          </div>
      </header>

      <main>
        
          

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" data-pagefind-body>
            <!-- SEO header -->
            <h1 style="display: none">remix编译运行solidity10</h1>
            
            <div class="markdown-body">
              <h2 id="③-为什么-mint-和-burn-都-emit-Transfer？"><a href="#③-为什么-mint-和-burn-都-emit-Transfer？" class="headerlink" title="③ 为什么 mint 和 burn 都 emit Transfer？"></a><strong>③ 为什么 mint 和 burn 都 emit Transfer？</strong></h2><p>提示：address(0) 在 ERC20 标准中的意义是什么？</p>
<p>mint和burn我都是第一次听说。从代码上看，mint是从totalSupply添加amount，而burn是从totalSupply减去amount<br>address(0)我也没听过，我猜是地址为空的意思。<br>在这一行：<br>event Transfer(address indexed from, address indexed to, uint value);<br>Transfer是一个事件，当地址为0，就会引发报错，调用了transfer事件，就会有日志生成。</p>
<p>你对 <strong>mint&#x2F;burn</strong> 的理解方向对，但对 <strong>address(0) 的作用</strong>和 <strong>为什么要 emit Transfer</strong> 还不完全准确，我帮你梳理成专业理解。</p>
<h3 id="✅-ERC20-中-mint-burn-与-Transfer-的关系"><a href="#✅-ERC20-中-mint-burn-与-Transfer-的关系" class="headerlink" title="✅ ERC20 中 mint&#x2F;burn 与 Transfer 的关系"></a>✅ <strong>ERC20 中 mint&#x2F;burn 与 Transfer 的关系</strong></h3><h6 id="1️⃣-mint-是增加代币总量"><a href="#1️⃣-mint-是增加代币总量" class="headerlink" title="1️⃣ mint 是增加代币总量"></a><strong>1️⃣ mint 是增加代币总量</strong></h6><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">function _mint(address to, uint amount) internal &#123;<br>    totalSupply += amount;<br>    balances[to] += amount;<br>    emit Transfer(address(0), to, amount);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>解释：</p>
<ul>
<li><code>totalSupply</code> 增加 → 代币被创造出来</li>
<li><code>balances[to]</code> 增加 → 代币分配给某个地址</li>
<li><strong>为什么 emit Transfer(address(0), to, amount)？</strong></li>
</ul>
<blockquote>
<p>ERC20 标准规定：<code>Transfer</code> event 不仅用于普通转账，也用于表示代币生成（mint）和销毁（burn）。<br>address(0) 在这里表示“代币来源于无处（系统生成）”。</p>
</blockquote>
<h6 id="2️⃣-burn-是销毁代币"><a href="#2️⃣-burn-是销毁代币" class="headerlink" title="2️⃣ burn 是销毁代币"></a><strong>2️⃣ burn 是销毁代币</strong></h6><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">function _burn(address from, uint amount) internal &#123;<br>    balances[from] -= amount;<br>    totalSupply -= amount;<br>    emit Transfer(from, address(0), amount);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>解释：</p>
<ul>
<li><code>balances[from]</code> 减少 → 用户的代币被销毁</li>
<li><code>totalSupply</code> 减少 → 总量减少</li>
<li><strong>为什么 emit Transfer(from, address(0), amount)？</strong></li>
</ul>
<blockquote>
<p>address(0) 表示“代币去向为空（销毁）”，通过 event 让前端&#x2F;区块浏览器知道代币被销毁了。</p>
</blockquote>
<h6 id="3️⃣-address-0-不是报错，也不是空地址错误"><a href="#3️⃣-address-0-不是报错，也不是空地址错误" class="headerlink" title="3️⃣ address(0) 不是报错，也不是空地址错误"></a><strong>3️⃣ address(0) 不是报错，也不是空地址错误</strong></h6><ul>
<li>address(0) 是 Solidity 里一个合法地址，十六进制全 0：</li>
</ul>
<figure class="highlight dns"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dns"><span class="hljs-number">0</span>x00000000000000000000000000000<span class="hljs-number">00000000000</span><br></code></pre></div></td></tr></table></figure>

<ul>
<li>mint: from &#x3D; 0 → 代币从无处生成</li>
<li>burn: to &#x3D; 0 → 代币销毁</li>
<li>前端和 The Graph 都通过观察 Transfer(address(0), …) 或 Transfer(…, address(0)) 来追踪 mint 和 burn</li>
</ul>
<h6 id="4️⃣-为什么-mint-burn-都要-emit-Transfer？"><a href="#4️⃣-为什么-mint-burn-都要-emit-Transfer？" class="headerlink" title="4️⃣ 为什么 mint&#x2F;burn 都要 emit Transfer？"></a><strong>4️⃣ 为什么 mint&#x2F;burn 都要 emit Transfer？</strong></h6><ul>
<li>ERC20 标准要求前端监听 <strong>Transfer event</strong> 来更新余额和总量</li>
<li>如果不 emit event，前端就无法知道总量发生变化</li>
<li>所有钱包、DEX、统计工具、区块浏览器都依赖 Transfer event 来显示代币状态</li>
<li>这是 ERC20 规范设计上的“统一接口”，方便数据同步</li>
</ul>
<h3 id="🎯-总结"><a href="#🎯-总结" class="headerlink" title="🎯 总结"></a>🎯 <strong>总结</strong></h3><p>| 操作       | from    | to      | 含义    |<br>| transfer | 用户地址    | 用户地址    | 普通转账  |<br>| mint     | 0x000…0 | 用户地址    | 新代币生成 |<br>| burn     | 用户地址    | 0x000…0 | 代币销毁  |</p>
<ul>
<li><strong>address(0)</strong> 不会报错，是标准约定的“无地址”</li>
<li><strong>Transfer event</strong> 不仅仅是日志，也是 <strong>前端&#x2F;工具追踪总量和余额的信号</strong></li>
</ul>
<h2 id="④-为什么-decimals-默认写在合约里面，而不是动态决定？"><a href="#④-为什么-decimals-默认写在合约里面，而不是动态决定？" class="headerlink" title="④ 为什么 decimals 默认写在合约里面，而不是动态决定？"></a><strong>④ 为什么 decimals 默认写在合约里面，而不是动态决定？</strong></h2><p>我把这一行注释了<br><code>//uint8 public decimals = 18;</code><br>然后编译部署合约，发现deployed contract没有decimals这个按钮。<br>该合约正常运行了，似乎没有报错。<br>因此我不明白decimals 默认写在合约里面的必要性是什么？ 为什么要画蛇添足写这个东西？</p>
<p>ERC20 是一个标准，所有钱包、交易所都依赖 decimals 来显示金额。</p>
<p>如果动态决定 decimals：<br>用户可能在不同时间看到不同显示<br>钱包和交易所可能解析错误<br>写死在合约里，部署后就是固定值，保证生态一致性。</p>
<h3 id="decimals是什么"><a href="#decimals是什么" class="headerlink" title="decimals是什么"></a>decimals是什么</h3><p>简单来说，<code>decimals</code> 是 <strong>代币的小数精度</strong>，用来告诉前端或钱包软件，代币在显示给用户时应该除以多少倍的 10。</p>
<p>1️⃣ 基本概念</p>
<ul>
<li><strong>链上存储</strong>：ERC20 代币的余额都是整数，没有小数。</li>
<li><strong>decimals</strong>：告诉前端，整数要除以 (10^{decimals}) 才是真正显示的金额。</li>
</ul>
<p><strong>公式：</strong></p>
<p>[<br>\text{显示的代币数量} &#x3D; \frac{\text{合约存储的整数数量}}{10^{decimals}}<br>]</p>
<p>2️⃣ 示例</p>
<p>假设：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">uint8 public decimals = 18;<br>uint256 public totalSupply = 1000000000000000000; // 1 个 token 实际上是 10^18 个最小单位<br></code></pre></div></td></tr></table></figure>

<ul>
<li><strong>存储在链上</strong>：<code>1_000_000_000_000_000_000</code>（整数）</li>
<li><strong>前端显示</strong>：<code>1.0</code>（因为 1_000_000_000_000_000_000 ÷ 10^18 &#x3D; 1）</li>
</ul>
<p>如果 <code>decimals = 6</code>：</p>
<ul>
<li>链上存储 1,000,000</li>
<li>前端显示 1.0（1,000,000 ÷ 10^6）</li>
</ul>
<p> 3️⃣ 关键点</p>
<ul>
<li><strong>不是链上必需</strong>：ERC20 合约运行不依赖 decimals。</li>
<li><strong>前端&#x2F;生态必需</strong>：钱包、交易所、DEX 需要它来显示金额。</li>
<li><strong>通常写死</strong>：为了标准化，通常在合约里固定，比如 <code>uint8 public decimals = 18;</code></li>
</ul>
<p>✅ <strong>总结</strong>：<br><code>decimals</code> 就是告诉大家“代币的最小单位有多小”，它不影响链上逻辑，只影响显示和计算习惯。</p>
<p>如果你愿意，我可以画一张图，把 <strong>整数余额 ↔ decimals ↔ 用户显示</strong> 的关系可视化，一眼就明白。</p>
<p>你想看吗？</p>
<h2 id="⑤-allowance-from-msg-sender-的-msg-sender-在-transferFrom-中指的是谁？"><a href="#⑤-allowance-from-msg-sender-的-msg-sender-在-transferFrom-中指的是谁？" class="headerlink" title="⑤ allowance[from][msg.sender] 的 msg.sender 在 transferFrom 中指的是谁？"></a><strong>⑤ allowance[from][msg.sender] 的 msg.sender 在 transferFrom 中指的是谁？</strong></h2><p>msg.sender 在 transferFrom 指的是合约的所有者，也就是调用transforFrom的这个from的eth地址。</p>
<p>你这个理解需要纠正一下，<code>transferFrom</code> 中的 <code>msg.sender</code> 并 <strong>不是 from 的地址</strong>，而是 <strong>调用这个函数的人</strong>。我来详细解释。</p>
<h3 id="1️⃣-ERC20-transferFrom-原型"><a href="#1️⃣-ERC20-transferFrom-原型" class="headerlink" title="1️⃣ ERC20 transferFrom 原型"></a>1️⃣ ERC20 <code>transferFrom</code> 原型</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">function transferFrom(<br>    address from,<br>    address to,<br>    uint256 amount<br>) public returns (bool)<br></code></pre></div></td></tr></table></figure>

<ul>
<li><code>from</code>：代币原本的持有者</li>
<li><code>to</code>：代币接收者</li>
<li><code>amount</code>：转账数量</li>
<li><code>msg.sender</code>：调用 <code>transferFrom</code> 的地址（通常是被授权的 spender）</li>
</ul>
<h3 id="2️⃣-授权和-allowance-的关系"><a href="#2️⃣-授权和-allowance-的关系" class="headerlink" title="2️⃣ 授权和 allowance 的关系"></a>2️⃣ 授权和 allowance 的关系</h3><p>ERC20 内部通常写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">require(_balances[from] &gt;= amount, &quot;balance too low&quot;);<br>require(_allowances[from][msg.sender] &gt;= amount, &quot;allowance too low&quot;);<br><br>_balances[from] -= amount;<br>_balances[to] += amount;<br>_allowances[from][msg.sender] -= amount;<br><br>emit Transfer(from, to, amount);<br></code></pre></div></td></tr></table></figure>

<p>解释：</p>
<ul>
<li><p><code>_allowances[from][msg.sender]</code>：</p>
<ul>
<li><code>from</code> &#x3D; 代币持有人</li>
<li><code>msg.sender</code> &#x3D; 调用 <code>transferFrom</code> 的人（即 spender）</li>
<li>这个值就是你之前 <code>approve(spender, amount)</code> 设置的额度</li>
</ul>
</li>
</ul>
<h3 id="3️⃣-举个例子"><a href="#3️⃣-举个例子" class="headerlink" title="3️⃣ 举个例子"></a>3️⃣ 举个例子</h3><ol>
<li>Alice 有 100 个 token</li>
<li>Alice 调用：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">approve(Bob, 50);<br></code></pre></div></td></tr></table></figure>

<ul>
<li><code>_allowances[Alice][Bob] = 50</code></li>
</ul>
<ol start="3">
<li>Bob 调用：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">transferFrom(Alice, Charlie, 20);<br></code></pre></div></td></tr></table></figure>

<ul>
<li><p>这里：</p>
<ul>
<li><code>from = Alice</code></li>
<li><code>to = Charlie</code></li>
<li><code>msg.sender = Bob</code></li>
<li>检查 <code>_allowances[Alice][Bob] &gt;= 20</code> ✅</li>
<li>扣 Alice 的余额，增加 Charlie 的余额</li>
<li>扣 Bob 的 allowance 20 → 30 剩余</li>
</ul>
</li>
</ul>
<h3 id="4️⃣-关键点总结"><a href="#4️⃣-关键点总结" class="headerlink" title="4️⃣ 关键点总结"></a>4️⃣ 关键点总结</h3><p>| 参数                            | 指向                             |<br>| from                          | 代币原持有人（Alice）                  |<br>| to                            | 接收代币的人（Charlie）                |<br>| msg.sender                    | 调用 transferFrom 的地址（Bob，被授权的人） |<br>| _allowances[from][msg.sender] | 从 <code>from</code> 到 <code>msg.sender</code> 的授权额度  |</p>
<blockquote>
<p>结论：<code>msg.sender</code> <strong>永远是当前调用函数的人</strong>，不是 <code>from</code> 的地址。</p>
</blockquote>
<p>如果你愿意，我可以画一张 <strong>approve → allowance → transferFrom 的流程图</strong>，把 msg.sender、from、to 的关系直观展示出来。</p>
<p>你想让我画吗？</p>
<h2 id="⑥-“授权后再调用-transferFrom”-这个流程适用于哪些-DeFi-场景？请举两个例子。"><a href="#⑥-“授权后再调用-transferFrom”-这个流程适用于哪些-DeFi-场景？请举两个例子。" class="headerlink" title="⑥ “授权后再调用 transferFrom” 这个流程适用于哪些 DeFi 场景？请举两个例子。"></a><strong>⑥ “授权后再调用 transferFrom” 这个流程适用于哪些 DeFi 场景？请举两个例子。</strong></h2><ol>
<li>质押</li>
<li>借贷</li>
</ol>
<p>完全正确！“<strong>先 approve 授权，再 transferFrom</strong>”是 ERC20 里经典的代币托管模式，DeFi 中应用非常广泛。我给你详细举例并说明流程。</p>
<h3 id="1️⃣-质押（Staking）"><a href="#1️⃣-质押（Staking）" class="headerlink" title="1️⃣ 质押（Staking）"></a>1️⃣ 质押（Staking）</h3><p><strong>场景：</strong> 用户想把 ERC20 代币质押到某个质押合约，获取奖励。</p>
<p><strong>流程：</strong></p>
<ol>
<li><p>用户持有代币 AliceToken。</p>
</li>
<li><p>用户调用合约 <code>approve(StakingContract, 100)</code>，授权质押合约可以花最多 100 个代币。</p>
</li>
<li><p>用户调用 <code>StakingContract.stake(50)</code>：</p>
<ul>
<li>合约内部使用 <code>transferFrom(Alice, StakingContract, 50)</code> 把代币从用户账户转到质押池。</li>
</ul>
</li>
<li><p>质押池记录用户余额和奖励。</p>
</li>
</ol>
<p><strong>特点：</strong></p>
<ul>
<li>用户不用把代币直接发送给合约，减少失误风险。</li>
<li>合约只能动被授权的额度。</li>
</ul>
<h3 id="2️⃣-借贷（Lending-Borrowing）"><a href="#2️⃣-借贷（Lending-Borrowing）" class="headerlink" title="2️⃣ 借贷（Lending&#x2F;Borrowing）"></a>2️⃣ 借贷（Lending&#x2F;Borrowing）</h3><p><strong>场景：</strong> 用户想把代币存入借贷协议（如 Aave&#x2F;Compound），或者用代币作为抵押借贷。</p>
<p><strong>流程：</strong></p>
<ol>
<li><p>用户调用 <code>approve(LendingProtocol, 200)</code>，授权借贷合约可以转 200 个代币。</p>
</li>
<li><p>用户调用 <code>deposit(200)</code> 或 <code>supply(200)</code>：</p>
<ul>
<li>合约内部使用 <code>transferFrom(user, LendingProtocol, 200)</code> 转入代币。</li>
</ul>
</li>
<li><p>协议记录用户存入的余额，发放利息或 cToken&#x2F;vToken 代币。</p>
</li>
</ol>
<p><strong>特点：</strong></p>
<ul>
<li>用户代币仍然安全控制在授权额度内</li>
<li>协议无需直接持有用户私钥即可管理代币</li>
</ul>
<h3 id="3️⃣-总结"><a href="#3️⃣-总结" class="headerlink" title="3️⃣ 总结"></a>3️⃣ 总结</h3><p>| 场景          | 作用            | ERC20 功能               |<br>| 质押          | 用户把代币放到合约获取奖励 | approve → transferFrom |<br>| 借贷          | 用户存入或抵押代币     | approve → transferFrom |<br>| 兑换&#x2F;交易（额外例子） | 在 DEX 上交易代币   | approve → transferFrom |</p>
<p>💡 <strong>核心思想</strong>：</p>
<blockquote>
<p>“用户先授权 → 合约调用 transferFrom 扣代币” 是安全托管模式，保证用户可控，又方便 DeFi 合约操作。</p>
</blockquote>
<p>如果你愿意，我可以画一张 <strong>DeFi 场景下 approve → transferFrom 流程图</strong>，把质押、借贷都放进去，让你一眼看懂。</p>
<p>你想让我画吗？</p>
<h2 id="⑦-你在代码里看到哪些可能导致漏洞的点？（越多越好）"><a href="#⑦-你在代码里看到哪些可能导致漏洞的点？（越多越好）" class="headerlink" title="⑦ 你在代码里看到哪些可能导致漏洞的点？（越多越好）"></a><strong>⑦ 你在代码里看到哪些可能导致漏洞的点？（越多越好）</strong></h2><p>（不要求你说得专业，我会帮你升级成审计思维）<br>transfer和transferFrom函数只需要输入eth地址和amount，或者from，to的eth地址，点击transact就可以转账，不需要密码<br>所以可能会被攻击者转走代币。</p>
<p>非常好，你已经开始进入“审计思维”的核心第一步：<br><strong>看到任何可以转账的函数，就要问：谁能调用？会不会被别人乱用？有没有访问控制？有没有检查？</strong></p>
<p>你提到的点是正确的方向，但还不够准确，我来帮你升级成更专业的“漏洞意识”。</p>
<p>下面我假设的是<strong>你之前写的那个非常简化的 ERC20 合约</strong>（无权限控制、自己写 balance 映射、transfer&#x2F;transferFrom 简单实现）。<br>在这种代码里，确实可能存在许多典型漏洞。</p>
<h3 id="✅-【⑦-你的这段简单-ERC20-代码里可能的漏洞（越多越好版）】"><a href="#✅-【⑦-你的这段简单-ERC20-代码里可能的漏洞（越多越好版）】" class="headerlink" title="✅ 【⑦ 你的这段简单 ERC20 代码里可能的漏洞（越多越好版）】"></a>✅ <strong>【⑦ 你的这段简单 ERC20 代码里可能的漏洞（越多越好版）】</strong></h3><p>我来给你列一个“审计清单式”的答案，每一点我都用你能理解的语言来讲。</p>
<h3 id="1️⃣-transfer-transferFrom-没有权限控制（误解澄清）"><a href="#1️⃣-transfer-transferFrom-没有权限控制（误解澄清）" class="headerlink" title="1️⃣ transfer &#x2F; transferFrom 没有权限控制（误解澄清）"></a><strong>1️⃣ transfer &#x2F; transferFrom 没有权限控制（误解澄清）</strong></h3><p>你说的：</p>
<blockquote>
<p>transfer只要输入地址和金额就能转走别人的代币，不需要密码→所以会被盗</p>
</blockquote>
<p>这其实不是漏洞。<br>因为：</p>
<ul>
<li><strong>只有 msg.sender 的余额会被扣</strong>，你输入别人的地址是没有意义的</li>
<li>你无法用 UI 假装“从别人账户转”，你永远只能从你自己的余额扣</li>
</ul>
<p>真正的漏洞并不是这个，而是：</p>
<h3 id="2️⃣-transferFrom-没有限制：任何人都能调用，导致代币被盗"><a href="#2️⃣-transferFrom-没有限制：任何人都能调用，导致代币被盗" class="headerlink" title="2️⃣ transferFrom 没有限制：任何人都能调用，导致代币被盗"></a><strong>2️⃣ transferFrom 没有限制：任何人都能调用，导致代币被盗</strong></h3><p>如果<strong>allowance 检查写错了、遗漏了、顺序错了</strong>，攻击者可以做到以下攻击：</p>
<ul>
<li>在没有被 approve 的情况下直接转别人代币</li>
<li>或者 amount 下溢&#x2F;上溢绕过检查</li>
</ul>
<p>只要 transferFrom 内部逻辑写得不好，就会有严重漏洞。</p>
<h3 id="3️⃣-没有对-0-地址做检查（经典漏洞）"><a href="#3️⃣-没有对-0-地址做检查（经典漏洞）" class="headerlink" title="3️⃣ 没有对 0 地址做检查（经典漏洞）"></a><strong>3️⃣ 没有对 0 地址做检查（经典漏洞）</strong></h3><ul>
<li>转账到 <code>address(0)</code> 相当于销毁代币</li>
<li>如果没有 <code>require(to != address(0))</code>，攻击者可以把别人的代币全销毁</li>
<li>如果 transferFrom 没防止 from&#x3D;0x0，用得不当会凭空 mint</li>
</ul>
<h3 id="4️⃣-mint-burn-没有权限控制"><a href="#4️⃣-mint-burn-没有权限控制" class="headerlink" title="4️⃣ mint &#x2F; burn 没有权限控制"></a><strong>4️⃣ mint &#x2F; burn 没有权限控制</strong></h3><p>如果你合约里有 mint：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">function mint(address to, uint amount) public &#123;<br>    balances[to] += amount;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>没有加 owner 控制 → 攻击者可以无限 mint → 代币归零。</p>
<h3 id="5️⃣-没有安全数学（溢出-下溢漏洞）"><a href="#5️⃣-没有安全数学（溢出-下溢漏洞）" class="headerlink" title="5️⃣ 没有安全数学（溢出 &#x2F; 下溢漏洞）"></a><strong>5️⃣ 没有安全数学（溢出 &#x2F; 下溢漏洞）</strong></h3><p>如果使用的是 Solidity &lt;0.8，没有 SafeMath：</p>
<ul>
<li><code>balance[from] -= amount</code> 可以变成巨额数字（下溢）</li>
<li>攻击者可以用一个小数制造一个巨量余额</li>
</ul>
<p>经典漏洞：<strong>整数下溢造成代币无限铸造</strong></p>
<h3 id="6️⃣-allowance-减少逻辑可能出现-Double-Spend（双花漏洞）"><a href="#6️⃣-allowance-减少逻辑可能出现-Double-Spend（双花漏洞）" class="headerlink" title="6️⃣ allowance 减少逻辑可能出现 Double-Spend（双花漏洞）"></a><strong>6️⃣ allowance 减少逻辑可能出现 Double-Spend（双花漏洞）</strong></h3><p>如果是这种写法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">_allowance[from][spender] -= amount;<br></code></pre></div></td></tr></table></figure>

<p>而你没有检查：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">require(_allowance[from][spender] &gt;= amount);<br></code></pre></div></td></tr></table></figure>

<p>攻击者可以多次调用 transferFrom，从而花超额度（双花）。</p>
<h3 id="7️⃣-transfer-transferFrom-没有返回值或返回值不规范"><a href="#7️⃣-transfer-transferFrom-没有返回值或返回值不规范" class="headerlink" title="7️⃣ transfer&#x2F;transferFrom 没有返回值或返回值不规范"></a><strong>7️⃣ transfer&#x2F;transferFrom 没有返回值或返回值不规范</strong></h3><p>ERC20 标准要求：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br></code></pre></div></td></tr></table></figure>

<p>如果没有返回值，某些钱包或 DEX 解析失败，可能导致用户资产卡住或无法取回。</p>
<h3 id="8️⃣-没有事件（event）会导致所有交易不透明"><a href="#8️⃣-没有事件（event）会导致所有交易不透明" class="headerlink" title="8️⃣ 没有事件（event）会导致所有交易不透明"></a><strong>8️⃣ 没有事件（event）会导致所有交易不透明</strong></h3><ul>
<li>交易所无法索引 Transfer</li>
<li>钱包无法显示余额变化</li>
<li>审计工具无法跟踪资金流向</li>
<li>攻击发生后难以排查</li>
</ul>
<p>这是安全性 + 可观测性的共同问题。</p>
<h3 id="9️⃣-totalSupply-没有更新或更新不规范"><a href="#9️⃣-totalSupply-没有更新或更新不规范" class="headerlink" title="9️⃣ totalSupply 没有更新或更新不规范"></a><strong>9️⃣ totalSupply 没有更新或更新不规范</strong></h3><p>常见漏洞：</p>
<ul>
<li>mint 时没有增加 totalSupply</li>
<li>burn 时没有减少 totalSupply</li>
<li>导致链上代币逻辑和实际总量不一致，DEX 定价会出现巨大偏差，可以被套利攻击</li>
</ul>
<h3 id="🔟-approve-重复授权修改逻辑错误（授权竞争攻击）"><a href="#🔟-approve-重复授权修改逻辑错误（授权竞争攻击）" class="headerlink" title="🔟 approve 重复授权修改逻辑错误（授权竞争攻击）"></a><strong>🔟 approve 重复授权修改逻辑错误（授权竞争攻击）</strong></h3><p>正确方式是：</p>
<figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">approve</span><span class="hljs-params">(spender, <span class="hljs-number">0</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">approve</span><span class="hljs-params">(spender, newAmount)</span></span><br></code></pre></div></td></tr></table></figure>

<p>如果你写：</p>
<figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">approve</span><span class="hljs-params">(spender, newAmount)</span></span><br></code></pre></div></td></tr></table></figure>

<p>攻击者可能利用 race-condition（前端不同步）造成双花。</p>
<h3 id="1️⃣1️⃣-没有限制重复调用-constructor-或初始化（可重入部署漏洞）"><a href="#1️⃣1️⃣-没有限制重复调用-constructor-或初始化（可重入部署漏洞）" class="headerlink" title="1️⃣1️⃣ 没有限制重复调用 constructor 或初始化（可重入部署漏洞）"></a><strong>1️⃣1️⃣ 没有限制重复调用 constructor 或初始化（可重入部署漏洞）</strong></h3><p>如果你的代码是代理（Proxy）风格但写错：</p>
<ul>
<li>constructor 逻辑在 initialize 中</li>
<li>initialize 可以被重复调用</li>
<li>攻击者可以把自己设置为 owner</li>
<li>这是一个真实存在的大漏洞（很多项目中招）</li>
</ul>
<h3 id="1️⃣2️⃣-没有-Reentrancy-Guard（重入攻击风险）"><a href="#1️⃣2️⃣-没有-Reentrancy-Guard（重入攻击风险）" class="headerlink" title="1️⃣2️⃣ 没有 Reentrancy Guard（重入攻击风险）"></a><strong>1️⃣2️⃣ 没有 Reentrancy Guard（重入攻击风险）</strong></h3><p>如果 transfer 调用了外部合约（比如 payable、token callback），可能出现：</p>
<ul>
<li>攻击者在 callback 中重新调用 transfer</li>
<li>导致多次扣款不正确</li>
<li>典型的“DAO Hack” 重入攻击</li>
</ul>
<h3 id="1️⃣3️⃣-没有检查-msg-sender-to（自转导致状态异常）"><a href="#1️⃣3️⃣-没有检查-msg-sender-to（自转导致状态异常）" class="headerlink" title="1️⃣3️⃣ 没有检查 msg.sender !&#x3D; to（自转导致状态异常）"></a><strong>1️⃣3️⃣ 没有检查 msg.sender !&#x3D; to（自转导致状态异常）</strong></h3><p>不常见但可能导致：</p>
<ul>
<li>某些业务逻辑写错时产生无限循环</li>
<li>或者触发奖励逻辑 Bug（某些质押合约发生过）</li>
</ul>
<h3 id="1️⃣4️⃣-没检查-amount-0（Zero-value-transfer）"><a href="#1️⃣4️⃣-没检查-amount-0（Zero-value-transfer）" class="headerlink" title="1️⃣4️⃣ 没检查 amount &gt; 0（Zero-value transfer）"></a><strong>1️⃣4️⃣ 没检查 amount &gt; 0（Zero-value transfer）</strong></h3><p>0 值转账可能用于：</p>
<ul>
<li>清洗 transaction history</li>
<li>攻击某些前端逻辑</li>
<li>减慢链上索引</li>
</ul>
<p>因此许多 ERC20 标准都会限制 amount &gt; 0。</p>
<h3 id="⭐-总结：你的合约里可能存在的漏洞清单（审计视角）"><a href="#⭐-总结：你的合约里可能存在的漏洞清单（审计视角）" class="headerlink" title="⭐ 总结：你的合约里可能存在的漏洞清单（审计视角）"></a>⭐ <strong>总结：你的合约里可能存在的漏洞清单（审计视角）</strong></h3><p>| 类别     | 风险                             |<br>| 权限控制   | mint&#x2F;burn&#x2F;transferFrom 无权限导致被盗 |<br>| 访问控制   | transferFrom 写错可直接盗取代币         |<br>| 溢出&#x2F;下溢  | balance -&#x3D; amount 下溢后余额巨量      |<br>| 总量不一致  | mint&#x2F;burn 未更新 totalSupply      |<br>| 授权漏洞   | approve 竞态攻击、双花                |<br>| 重入攻击   | 外部调用导致余额被重复扣                   |<br>| 0 地址攻击 | to&#x3D;0 销毁他人资产                    |<br>| 事件缺失   | 无法审计、钱包解析异常                    |<br>| 不规范实现  | 返回值不符合 ERC20 标准                |</p>
<p>如果你愿意，我可以把这些安全点整理成：</p>
<ul>
<li><strong>ERC20 安全审计清单（Checklist）</strong></li>
<li><strong>表格 + 代码示例 + 风险解释</strong></li>
<li><strong>附带你自己的合约逐条分析</strong></li>
</ul>
<p>你想继续升级成“审计模式”吗？我可以一步步带你进入专业审计思维。</p>
<h2 id="函数名前加上-符号"><a href="#函数名前加上-符号" class="headerlink" title="函数名前加上 _ 符号"></a>函数名前加上 <code>_</code> 符号</h2><p>在 Solidity 中，函数名前加上 <code>_</code> 符号通常表示这是一个内部使用的函数，或者是“私有”的辅助函数，并不是直接供外部用户调用的接口。</p>
<p>具体来说：</p>
<ul>
<li><p>函数名以 <code>_</code> 开头的，如 <code>_mint</code> 和 <code>_burn</code>，通常表示这些是内部的、辅助性的函数，用于合约内部的逻辑。它们并不打算暴露给合约外部的用户直接调用，而是被其他公开的函数调用来实现某些操作。</p>
<p>比如，<code>_mint</code> 和 <code>_burn</code> 这两个函数分别是用来增发和销毁代币的，它们是 ERC20 合约内部的一部分，并且不会直接暴露给外部用户，而是通过公开函数（比如 <code>mint</code>）间接调用。</p>
</li>
<li><p>而没有下划线的函数名，如 <code>approve</code> 和 <code>allowance</code>，是公开接口，允许外部用户与合约交互。这些函数会被用户调用，执行诸如批准和查询余额等操作。</p>
</li>
</ul>
<p>总结来说， <code>_</code> 符号的使用是一种约定俗成的规范，用来标识函数的作用域和访问权限，帮助开发者区分公开和内部函数。</p>
<p>你的意思是不加_也可以，但是加上会方便看出内外部函数？</p>
<p>是的，你理解得完全正确！不加下划线 (<code>_</code>) 也是可以的，Solidity 语法本身并不会强制要求使用下划线。但是，加上下划线是一种编码约定，帮助开发者更清晰地区分函数的用途：</p>
<ul>
<li><strong>没有下划线的函数</strong>：通常是公开的接口，供外部用户或者合约与其他合约交互时调用。</li>
<li><strong>有下划线的函数</strong>：通常是内部使用的辅助函数，仅供合约内部逻辑调用，不暴露给外部用户。</li>
</ul>
<p>这种做法可以提高代码的可读性和可维护性，帮助开发者理解哪些函数是公共接口，哪些是内部实现细节。所以，虽然加下划线不是强制性的，但它确实是一个方便标识的好习惯。</p>
<h2 id="erc20代币是什么，和eth有什么区别"><a href="#erc20代币是什么，和eth有什么区别" class="headerlink" title="erc20代币是什么，和eth有什么区别"></a>erc20代币是什么，和eth有什么区别</h2><p><strong>ERC20代币</strong>和<strong>ETH</strong>是两种不同类型的加密资产，虽然它们都运行在以太坊网络上，但它们有一些显著的区别。让我详细解释一下：</p>
<h3 id="1-ERC20代币"><a href="#1-ERC20代币" class="headerlink" title="1. ERC20代币"></a>1. <strong>ERC20代币</strong></h3><ul>
<li><p><strong>ERC20</strong>是以太坊网络上的一种标准，指的是遵循特定规则和接口的代币。</p>
</li>
<li><p>这些代币是智能合约的产物，可以在以太坊区块链上创建、转移和管理。</p>
</li>
<li><p>ERC20标准定义了一些必须实现的函数和事件，使得不同的代币能够在以太坊生态系统中互操作。例如，<code>transfer</code>、<code>approve</code>、<code>balanceOf</code>、<code>transferFrom</code>等都是ERC20代币的标准函数。</p>
</li>
<li><p>ERC20代币可以代表任何类型的资产或权益，如公司股权、游戏货币、去中心化金融（DeFi）中的奖励等。</p>
<p><strong>例子</strong>：</p>
<ul>
<li>DAI（一个稳定币）</li>
<li>USDT（Tether，一种稳定币）</li>
<li>UNI（Uniswap的治理代币）</li>
</ul>
<p><strong>关键特点</strong>：</p>
<ul>
<li>ERC20代币是以太坊智能合约的实现，必须遵守ERC20标准。</li>
<li>它们并不直接由以太坊网络控制，而是通过智能合约管理的代币。</li>
</ul>
</li>
</ul>
<h3 id="2-ETH（以太币）"><a href="#2-ETH（以太币）" class="headerlink" title="2. ETH（以太币）"></a>2. <strong>ETH（以太币）</strong></h3><ul>
<li><p><strong>ETH</strong>是以太坊网络的原生加密货币，通常也被称为“以太币”。</p>
</li>
<li><p>它是以太坊区块链的燃料，用于支付交易费用（即“Gas费”）以及激励矿工（或验证者）验证交易和执行智能合约。</p>
</li>
<li><p>ETH是去中心化的，不需要依赖任何智能合约来进行管理，它直接由以太坊协议控制。</p>
<p><strong>关键特点</strong>：</p>
<ul>
<li>ETH是以太坊网络的原生资产，用于支付交易费用和执行合约。</li>
<li>ETH可以用作价值存储、转账、抵押等功能。</li>
</ul>
<p><strong>区别于ERC20</strong>：</p>
<ul>
<li>以太币（ETH）是以太坊的基础加密货币，而ERC20代币是运行在以太坊网络上的标准代币。</li>
<li>ETH的创建和管理是由以太坊协议本身决定的，而ERC20代币是通过智能合约创建和管理的。</li>
</ul>
</li>
</ul>
<h3 id="主要区别总结："><a href="#主要区别总结：" class="headerlink" title="主要区别总结："></a>主要区别总结：</h3><p>| 特性       | ERC20代币             | ETH (以太币)            |<br>| <strong>定义</strong>   | 通过以太坊智能合约创建的代币标准    | 以太坊网络的原生加密货币         |<br>| <strong>用途</strong>   | 作为资产、服务或权益的表示       | 用于支付交易费用、执行智能合约、存储价值 |<br>| <strong>创建方式</strong> | 由开发者通过部署ERC20智能合约创建 | 由以太坊协议本身发行和管理        |<br>| <strong>示例</strong>   | DAI、USDT、UNI等       | ETH                  |</p>
<h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><ul>
<li><strong>ETH</strong>是以太坊的基础加密货币，用于支付交易费用并执行合约。</li>
<li><strong>ERC20代币</strong>是遵循ERC20标准的代币，可以代表任何类型的资产或权益，并通过智能合约在以太坊区块链上创建和管理。</li>
</ul>
<p>希望这些解释能帮助你更好地理解它们之间的区别！</p>
<h2 id="ERC20-transfer-mint-burn-流程图"><a href="#ERC20-transfer-mint-burn-流程图" class="headerlink" title="ERC20 transfer&#x2F;mint&#x2F;burn 流程图"></a>ERC20 transfer&#x2F;mint&#x2F;burn 流程图</h2><p>画一张 ERC20 transfer&#x2F;mint&#x2F;burn 流程图，让 mint、burn、transfer 以及 Transfer event 的作用一目了然</p>
<p><img src="/2025/11/15/35758/1.png"></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Web3/">Web3</a>
                    
                  </div>
                
              </div>
              
                
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/11/16/60846.html">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">remix编译运行solidity11</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/11/15/43476.html">
                        <span class="hidden-mobile">remix编译运行solidity9</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


            

                
                  <a id="scroll-top-button" href="#" role="button">
                    <i class="iconfont icon-arrowup" aria-hidden="true"></i>
                  </a>
                  

                    

                          
      </main>

      <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://whale3070.github.io/" target="_blank" rel="nofollow noopener"><span>Whale3070</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->




  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>





  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<link href="/pagefind/pagefind-ui.css" rel="stylesheet">
  <script src="/pagefind/pagefind-ui.js"></script>
  <style>
    /* 搜索框配色适配 */
    #search { margin-top: 2rem; }
    [data-user-color-scheme='dark'] .pagefind-ui {
      --pagefind-ui-primary: #eeeeee;
      --pagefind-ui-text: #eeeeee;
      --pagefind-ui-background: #151515;
      --pagefind-ui-border: #333;
    }
  </style>
    </body>

  </html>