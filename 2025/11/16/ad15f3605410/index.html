

  <!DOCTYPE html>
  <html lang="en" data-default-color-scheme=&#34;dark&#34; >
  <style>
    .text1
    {
    text-shadow: 0px 0px 2px #f2f3f2;
    }
    </style>

  

<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/null">
  <link rel="icon" type="image/png" href="/null">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>remix编译运行solidity11 - whale3070&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.7","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


    <body>
      <header style="height: 70vh;">
        <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>InfoSec learning</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          
        
      </ul>
    </div>
  </div>
</nav>

          <div class="banner" id="banner" false
            style="background: url('/img/default.png') no-repeat center center;
              background-size: cover;">
              <div class="full-bg-img">
                <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
                  <div class="page-header text-center fade-in-up">
                    <span class="h2 text1" id="subtitle" title="remix编译运行solidity11">
                      
                        remix编译运行solidity11
                      
                    </span>
        
                    
                      <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2025-11-16 04:53" pubdate>
        November 16, 2025 am
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      5.8k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      64
       分钟
    </span>
  

  
  
</div>

                    
                  </div>
                    
                  </div>
                  
                </div>
              </div>
          </div>
      </header>

      <main>
        
          

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">remix编译运行solidity11</h1>
            
            <div class="markdown-body">
              <p>真正理解 ERC20 每个函数在做什么，以及它们之间的调用关系。</p>
<h2 id="🚀-ERC20-标准代码（结构拆解）"><a href="#🚀-ERC20-标准代码（结构拆解）" class="headerlink" title="🚀 ERC20 标准代码（结构拆解）"></a>🚀 <strong>ERC20 标准代码（结构拆解）</strong></h2><p>OpenZeppelin 的 ERC20 分为几部分（所有代币项目都这样组织）：</p>
<p><strong>外部接口（给用户）</strong></p>
<ul>
<li><code>balanceOf</code></li>
<li><code>transfer</code></li>
<li><code>allowance</code></li>
<li><code>approve</code></li>
<li><code>transferFrom</code></li>
</ul>
<p><strong>内部逻辑（核心实现）</strong></p>
<ul>
<li><code>_transfer</code></li>
<li><code>_mint</code></li>
<li><code>_burn</code></li>
<li><code>_approve</code></li>
<li><code>_spendAllowance</code></li>
</ul>
<p>你要理解：</p>
<blockquote>
<p><strong>外部函数不写核心逻辑，所有逻辑在内部函数完成</strong></p>
</blockquote>
<p>为什么？<br>答：方便子合约 override，也避免重复写逻辑（你昨天已经理解）。</p>
<hr>
<p>✅ <strong>【第一步】理解 transfer 的真实行为</strong></p>
<p>OpenZeppelin 代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">function transfer(address to, uint256 amount) public returns (bool) &#123;<br>    address owner = _msgSender();<br>    _transfer(owner, to, amount);<br>    return true;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>重点：</p>
<ul>
<li><code>transfer</code> 是用户直接转账给别人</li>
<li>它<strong>永远扣 msg.sender 的余额</strong></li>
<li>真正逻辑在 <code>_transfer</code> 执行</li>
</ul>
<p>👇 <strong>你现在回答问题 1：</strong></p>
<h2 id="❓-问题-1：为什么-transfer-直接用-msg-sender，而不需要-from？"><a href="#❓-问题-1：为什么-transfer-直接用-msg-sender，而不需要-from？" class="headerlink" title="❓ 问题 1：为什么 transfer 直接用 msg.sender，而不需要 from？"></a>❓ <strong>问题 1：为什么 transfer 直接用 msg.sender，而不需要 from？</strong></h2><p>请用你自己的话回答。<br>（回答不用完美，我会帮你修正。）</p>
<p>答：trasferFrom函数，被授权者（msg.sender）从别人账户 from 转代币到 to。而transfer函数是转账自己账户里的余额，所以不需要from</p>
<p>完美，你对 <strong>transfer 与 transferFrom 的区别</strong>已经掌握得非常清晰、标准答案级别。<br>我们继续深入任务一的第二部分。</p>
<hr>
<h2 id="✅-【第二步】深入理解-transferFrom（ERC20-最核心函数）"><a href="#✅-【第二步】深入理解-transferFrom（ERC20-最核心函数）" class="headerlink" title="✅ 【第二步】深入理解 transferFrom（ERC20 最核心函数）"></a>✅ <strong>【第二步】深入理解 transferFrom（ERC20 最核心函数）</strong></h2><p>OpenZeppelin 代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">function transferFrom(<br>    address from,<br>    address to,<br>    uint256 amount<br>) public returns (bool) &#123;<br><br>    address spender = _msgSender();<br>    _spendAllowance(from, spender, amount);<br>    _transfer(from, to, amount);<br>    return true;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>流程拆解非常关键：</p>
<hr>
<h4 id="🔥-transferFrom-的真实流程（3-步）"><a href="#🔥-transferFrom-的真实流程（3-步）" class="headerlink" title="🔥 transferFrom 的真实流程（3 步）"></a>🔥 <strong>transferFrom 的真实流程（3 步）</strong></h4><h6 id="①-spender（msg-sender）代表用户-from-操作"><a href="#①-spender（msg-sender）代表用户-from-操作" class="headerlink" title="① spender（msg.sender）代表用户 from 操作"></a><strong>① spender（msg.sender）代表用户 from 操作</strong></h6><p>spender = 被授权者<br>from = 代扣的用户地址<br>to = 接收代币的地址</p>
<hr>
<h6 id="②-spendAllowance：检查额度并扣除-allowance"><a href="#②-spendAllowance：检查额度并扣除-allowance" class="headerlink" title="② _spendAllowance：检查额度并扣除 allowance"></a><strong>② _spendAllowance：检查额度并扣除 allowance</strong></h6><p>核心代码（简化版）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">uint256 currentAllowance = allowance[from][spender];<br>require(currentAllowance &gt;= amount, &quot;Not enough allowance&quot;);<br>_allowances[from][spender] = currentAllowance - amount;<br></code></pre></div></td></tr></table></figure>

<p>作用：</p>
<ul>
<li>确认 spender 是否有权限</li>
<li>扣除授权额度</li>
</ul>
<hr>
<h6 id="③-transfer：执行真正的转账"><a href="#③-transfer：执行真正的转账" class="headerlink" title="③ _transfer：执行真正的转账"></a><strong>③ _transfer：执行真正的转账</strong></h6><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">balances[from] -= amount;<br>balances[to]   += amount;<br>emit Transfer(from, to, amount);<br></code></pre></div></td></tr></table></figure>

<hr>
<p>🌟 到这里你学会了：</p>
<ul>
<li>transfer → 扣自己的余额</li>
<li>transferFrom → 扣别人的余额，需要 allowance</li>
</ul>
<p>你理解非常好。</p>
<h2 id="❓-问题-2：为什么-transferFrom-不能直接写逻辑，而必须先执行-spendAllowance-再-transfer？"><a href="#❓-问题-2：为什么-transferFrom-不能直接写逻辑，而必须先执行-spendAllowance-再-transfer？" class="headerlink" title="❓ 问题 2：为什么 transferFrom 不能直接写逻辑，而必须先执行 _spendAllowance 再 _transfer？"></a>❓ <strong>问题 2：为什么 transferFrom 不能直接写逻辑，而必须先执行 <code>_spendAllowance</code> 再 <code>_transfer</code>？</strong></h2><p>你可以从下面角度思考：</p>
<ul>
<li>安全性？</li>
<li>逻辑顺序？</li>
<li>一步做 vs 两步做？</li>
<li>为什么不直接写在一起？</li>
</ul>
<p>随便怎么答都行，我会逐句帮你修正成最专业理解。</p>
<p>答：<br><code>从安全性角度考虑，需要先确定能够转账多少钱，才可以转账。否则会出现让用户存款归零的情况，非常不安全。从逻辑顺序看，这是状态机，所以要有先后顺序。需要两步做，如果写到一起，就不符合合约的编程规范。具体编程规范我忘记了，只记得，可组合，可继承，类似于积木。</code></p>
<p>你已经回答得非常好，而且方向完全正确。我帮你把你的答案<strong>提升成专业级理解</strong>（是你未来写代码审计、面试、写文章都能用的版本）。<br>✅ <strong>问题 2 —— 标准答案（根据你的思路升级版）</strong></p>
<h6 id="你的核心思想总结成一句话："><a href="#你的核心思想总结成一句话：" class="headerlink" title="你的核心思想总结成一句话："></a><strong>你的核心思想总结成一句话：</strong></h6><blockquote>
<p>transferFrom 必须先扣授权额度（_spendAllowance），再执行实际转账（_transfer），这样才能保证安全性和逻辑一致性。</p>
</blockquote>
<p>下面是专业拆解：</p>
<p>🔒 <strong>1. 安全性：必须先确认权限</strong></p>
<p>如果不先检查 allowance，而直接扣余额，会出现严重漏洞：</p>
<ul>
<li>spender 可以无限次代扣</li>
<li>用户余额可能被一次性清空</li>
<li>第三方合约有可能恶意循环扣款</li>
</ul>
<p>所以第一步必须是：</p>
<figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">确认用户愿意给你扣多少钱（授权额度）<br></code></pre></div></td></tr></table></figure>

<p>否则 transferFrom 就会变成攻击工具。</p>
<p>🔄 <strong>2. 状态机逻辑：先扣授权 → 扣余额</strong></p>
<p>ERC20 的状态变化顺序必须是：</p>
<p>1）授权额度减少（用户允许你扣多少钱）<br>2）扣用户余额（真正发生转账）</p>
<p>如果你把两者混在一起，前端和区块浏览器会看不到正常的状态变化。</p>
<p>🧱 <strong>3. 合约必须模块化（可继承、可组合）</strong></p>
<p>你提到的“像积木一样”非常对。</p>
<ul>
<li><code>_spendAllowance</code> 是“检查授权+扣授权额度”的积木</li>
<li><code>_transfer</code> 是“更新余额 + emit Transfer”的积木</li>
</ul>
<p>为什么要分开？</p>
<p>因为不同项目可以重写其中一个：</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>典型需求</th>
</tr>
</thead>
<tbody><tr>
<td>MakerDAO</td>
<td>希望自定义授权逻辑</td>
</tr>
<tr>
<td>AAVE</td>
<td>想免费（permit）授权，不走 approve</td>
</tr>
<tr>
<td>Uniswap</td>
<td>在 Router 里重写 transfer 行为</td>
</tr>
<tr>
<td>ZK / L2 token</td>
<td>改变余额存储方式（如 slot 优化）</td>
</tr>
</tbody></table>
<p>模块化让大型 DeFi 可以灵活 extend ERC20 行为。</p>
<p>你昨天说过：</p>
<blockquote>
<p>“调用内部函数可以复用逻辑和节省 gas。”</p>
</blockquote>
<p>完全正确，而且这就是 ERC20 的设计哲学。</p>
<p>🎯 <strong>4. 一步写 vs 两步写：可组合性</strong></p>
<p>如果把所有逻辑写在 transferFrom 里：</p>
<ul>
<li>没法 override 某一部分逻辑</li>
<li>改一个地方需要改全部</li>
<li>不利于安全审计</li>
<li>不利于升级</li>
<li>代码耦合太高</li>
</ul>
<p>所以拆分成两个内部 function：</p>
<figure class="highlight isbl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">_spendAllowance</span>()</span><br><span class="hljs-function"><span class="hljs-title">_transfer</span>()</span><br></code></pre></div></td></tr></table></figure>

<p>这是“大型 Solidity 开发”的代码规范。</p>
<p>🌟 你的理解已经非常扎实。</p>
<p>现在我们进入任务一的第 3 部分。</p>
<hr>
<p>🚀 <strong>任务一 · 第 3 步：理解 mint / burn 和 address(0) 的底层规则</strong></p>
<p>下面是你的新问题：</p>
<h2 id="❓-问题-3：为什么-mint-要-emit-Transfer-address-0-to-amount-，而-burn-要-emit-Transfer-from-address-0-amount-？"><a href="#❓-问题-3：为什么-mint-要-emit-Transfer-address-0-to-amount-，而-burn-要-emit-Transfer-from-address-0-amount-？" class="headerlink" title="❓ 问题 3：为什么 mint 要 emit Transfer(address(0), to, amount)，而 burn 要 emit Transfer(from, address(0), amount)？"></a>❓ <strong>问题 3：为什么 mint 要 emit Transfer(address(0), to, amount)，而 burn 要 emit Transfer(from, address(0), amount)？</strong></h2><p>你可以从这些方向思考：</p>
<ul>
<li>address(0) 在标准里代表什么？</li>
<li>wallets / 浏览器为什么依赖这个？</li>
<li>如果不 emit Transfer，有什么具体后果？</li>
</ul>
<hr>
<p>你随便回答，我来帮你优化成专业级版本。</p>
<p>答：<br>address(0)是一个合法的eth20地址代表0x0000000000000000（18个0），burn函数用来销毁代币。如果不emit transfer，代币会无限超发，在经济学中会引起通货膨胀最终导致经济崩溃，所以必须引入销毁机制。</p>
<p>你的回答非常有想象力，但还不完全贴合 ERC20 标准本身，我来帮你把你的理解提升为真正的 <strong>区块链底层标准级别</strong>。</p>
<p>我们一起把逻辑拆清楚：</p>
<hr>
<h2 id="✅-address-0-的真正意义（比你想象得更关键）"><a href="#✅-address-0-的真正意义（比你想象得更关键）" class="headerlink" title="✅ address(0) 的真正意义（比你想象得更关键）"></a>✅ <strong>address(0) 的真正意义（比你想象得更关键）</strong></h2><p><code>address(0)</code> 在 ERC20 标准里不是因为“它是一个合法地址”才用。<br>它的用途是 <strong>表示代币的来源或去向是“无”</strong>。</p>
<p>也就是：</p>
<ul>
<li><strong>mint：代币从无到有</strong></li>
<li><strong>burn：代币从有到无</strong></li>
</ul>
<p>它不是因为“经济学上的通胀控制”，而是 ERC20 协议层的一个约定信号。</p>
<hr>
<p>🔥 <strong>下面是标准答案（结合你的理解优化后的版本）</strong></p>
<h4 id="🟦-mint-Transfer-from-0-地址"><a href="#🟦-mint-Transfer-from-0-地址" class="headerlink" title="🟦 mint = Transfer(from = 0 地址)"></a>🟦 <strong>mint = Transfer(from = 0 地址)</strong></h4><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">emit <span class="hljs-constructor">Transfer(<span class="hljs-params">address</span>(0)</span>, <span class="hljs-keyword">to</span>, amount);<br></code></pre></div></td></tr></table></figure>

<p>表示：</p>
<blockquote>
<p>“代币从不存在的地方被创造出来。”</p>
</blockquote>
<p>所有钱包、浏览器、分析工具都通过<br><strong>from = address(0)</strong><br>判断这是一次 <strong>mint</strong>。</p>
<hr>
<h4 id="🟥-burn-Transfer-to-0-地址"><a href="#🟥-burn-Transfer-to-0-地址" class="headerlink" title="🟥 burn = Transfer(to = 0 地址)"></a>🟥 <strong>burn = Transfer(to = 0 地址)</strong></h4><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">emit <span class="hljs-constructor">Transfer(<span class="hljs-params">from</span>, <span class="hljs-params">address</span>(0)</span>, amount);<br></code></pre></div></td></tr></table></figure>

<p>表示：</p>
<blockquote>
<p>“代币被销毁，去向是虚无。”</p>
</blockquote>
<p>所有工具都通过<br><strong>to = address(0)</strong><br>判断这是一次 <strong>burn</strong>。</p>
<hr>
<p>🧠 <strong>你之前说的“否则代币会无限超发导致崩溃”是逻辑上的推测，但 ERC20 标准不是因为经济学才这样设计。</strong></p>
<p>它的真正原因是：</p>
<hr>
<p>📌 <strong>1. 统一事件格式（保持唯一的事件 Type）</strong></p>
<p>ERC20 标准规定：</p>
<blockquote>
<p>所有转账行为（包括 mint 和 burn）都必须通过 emit Transfer 通知。</p>
</blockquote>
<p>为什么？</p>
<ul>
<li>钱包依靠 Transfer 显示余额变化</li>
<li>区块浏览器依靠 Transfer 统计历史</li>
<li>The Graph 等工具依靠 Transfer 追踪代币行为</li>
<li>交易监控系统依靠 Transfer 分析代币流通</li>
</ul>
<p>如果 mint/burn 不 emit Transfer：</p>
<ul>
<li>钱包余额不会刷新</li>
<li>Etherscan 不会识别 mint/burn</li>
<li>总量变动不会被任何人发现</li>
</ul>
<p>这是一个<strong>严重标准不兼容问题</strong>。</p>
<hr>
<p>📌 <strong>2. address(0) 是“合法但永不可用”的地址</strong></p>
<p>它不是普通用户地址：</p>
<ul>
<li>没有私钥</li>
<li>没人能控制</li>
<li>因此最安全地代表“无”与“销毁”</li>
</ul>
<p>设计上非常巧妙。</p>
<hr>
<p>📌 <strong>3. mint/burn 必须发 Transfer，否则违反 ERC20 标准</strong></p>
<p>经济学不是标准的考虑因素。<br>标准是技术规范：</p>
<blockquote>
<p>所有代币总量变化必须使用 Transfer 事件公告出来。</p>
</blockquote>
<hr>
<p>🎯 <strong>高质量总结</strong></p>
<p>你可以这样理解：</p>
<blockquote>
<p><strong>Transfer 是 ERC20 世界的一种“信号语言”。<br>mint 和 burn 只是用 from/to = address(0) 来告诉全世界：<br>这是创造 or 销毁。</strong></p>
</blockquote>
<hr>
<h2 id="❓-问题-4：为什么-approve-和-allowance-必须分离，而不能在-transferFrom-里同时授权-代扣？"><a href="#❓-问题-4：为什么-approve-和-allowance-必须分离，而不能在-transferFrom-里同时授权-代扣？" class="headerlink" title="❓ 问题 4：为什么 approve 和 allowance 必须分离，而不能在 transferFrom 里同时授权 + 代扣？"></a>❓ <strong>问题 4：为什么 approve 和 allowance 必须分离，而不能在 transferFrom 里同时授权 + 代扣？</strong></h2><p>提示你思考：</p>
<ul>
<li>去中心化交易所（DEX）</li>
<li>NFT 平台（OpenSea）</li>
<li>某个 DeFi 协议代扣你的资产</li>
<li>用户体验 vs 安全</li>
</ul>
<p>随便回答，我帮你优化成专业级别。</p>
<p>答：<br>approve 是授权， allowance查询，必须分离的原因是不同的功能要分离成不同的函数。从dex来看，授权和查询分来是理所当然的。从NFT平台看，我不了解。某个defi协议代扣你的资产，不清楚。用户体验和安全来看，用户可能希望只查询，不授权或者只授权不查询。</p>
<p>你的方向完全正确，我现在帮你把你的回答升级成 <strong>专业级 ERC20 设计理念</strong>，这是面试、写文章、审计都能直接用的标准答案。</p>
<p>🧱 1. <strong>职责分离（Separation of Concerns）—— 智能合约的核心原则</strong></p>
<p>你说的非常准确：</p>
<blockquote>
<p>“不同功能分离成不同函数。”</p>
</blockquote>
<p>这是智能合约设计最重要的原则：</p>
<ul>
<li><code>approve</code>：授权</li>
<li><code>allowance</code>：查询授权</li>
<li><code>transferFrom</code>：代扣</li>
</ul>
<p>三个函数分别做一件事，便于：</p>
<ul>
<li>重用</li>
<li>审计</li>
<li>组合</li>
<li>子合约 override</li>
<li>防止各种安全漏洞</li>
</ul>
<p>合在一起会变成“巨石函数”，高度耦合，非常容易出错。</p>
<hr>
<p>🏦 2. <strong>DeFi 协议必须先授权再操作（这是行业铁律）</strong></p>
<p>举例：</p>
<p>● Uniswap Swap</p>
<p>用户把代币换成另一种代币。</p>
<p>流程是：</p>
<figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">用户 approve Uniswap Router<br>Uniswap Router 调用 transferFrom 扣走用户的代币<br></code></pre></div></td></tr></table></figure>

<p>如果 transferFrom 里自动授权，就会发生灾难：</p>
<ul>
<li>恶意合约可以自己“自动授权” → 无限扣款</li>
<li>用户没有确认授权额度 → 任意代扣所有余额</li>
<li>授权过程不可追踪 → 钱被偷还不知道怎么偷的</li>
</ul>
<p>这是典型的安全灾难。</p>
<hr>
<p>🎨 3. <strong>NFT 平台（OpenSea 例子）必须长期保持授权状态</strong></p>
<p>在 NFT 平台上，用户卖一个 NFT，流程是：</p>
<figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">approve</span><span class="hljs-params">(marketplace)</span></span>  <span class="hljs-comment">// 授权平台能转移 NFT</span><br>marketplace 调用 transferFrom 转移你的 NFT 给买家<br></code></pre></div></td></tr></table></figure>

<p>如果 transferFrom 自带授权，会出现：</p>
<ul>
<li>卖家在不知道的情况下授权平台</li>
<li>平台可以转走你的所有 NFT</li>
<li>用户没法取消授权</li>
<li>安全不可控</li>
</ul>
<p>所以授权必须由用户主动做。</p>
<hr>
<p>🔥 4. <strong>防止 “无限代扣” 漏洞（DeFi 最常见攻击模型）</strong></p>
<p>如果 transferFrom 自带自动授权：</p>
<p>攻击者可以写一个合约这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">transferFrom(victim, attacker, victimBalance)<br></code></pre></div></td></tr></table></figure>

<p>因为 transferFrom 会自动授权，那么攻击者可以：</p>
<ul>
<li>自己授权给自己</li>
<li>直接扣款</li>
<li>一行代码清空用户全部余额</li>
</ul>
<p>这是历史上最常见的“ERC20 代扣漏洞”。</p>
<hr>
<p>🧪 5. <strong>用户体验：approve/allowance = “主动授权”</strong></p>
<p>Web3 本质上是：</p>
<blockquote>
<p>用户自己掌控资产，所有授权行为必须可见、可确认。</p>
</blockquote>
<p>如果 transferFrom 自动授权：</p>
<ul>
<li>钱包不会弹授权窗口</li>
<li>用户看不到授权额度</li>
<li>用户无法限制授权量</li>
<li>用户无法撤销授权</li>
</ul>
<p>这是严重背离 Web3 的设计原则。</p>
<hr>
<p>🔍 6. <strong>allowance 是一个独立状态，需要被查询</strong></p>
<p>很多前端逻辑需要 allowance：</p>
<ul>
<li>Uniswap 看 allowance 是否足够，否则提示用户“请先授权”</li>
<li>钱包 UI 显示你授权了哪些合约</li>
<li>审计工具追踪风险授权</li>
</ul>
<p>如果把 allowance 糊在 transferFrom 里：</p>
<ul>
<li>前端系统不知道现在的授权是多少</li>
<li>不知道要不要弹授权窗口</li>
<li>用户体验完全混乱</li>
</ul>
<hr>
<p>🎯 <strong>最终总结（你可以背下来）</strong></p>
<blockquote>
<p><strong>approve、allowance、transferFrom 之所以分离，是因为 ERC20 要求清晰的授权流程：<br>用户主动授权 → 第三方代扣 → 前端可查询 → 用户可撤销。</strong></p>
</blockquote>
<p>如果写成一个函数（自动授权+代扣），会导致：</p>
<ul>
<li>安全灾难（无限代扣）</li>
<li>用户无法控制授权</li>
<li>前端无法管理授权流程</li>
<li>无法审计，也无法追踪授权历史</li>
<li>所有 DeFi 流程会彻底崩溃</li>
</ul>
<hr>
<p>🎉 现在你已经完整理解 ERC20 的授权系统，这是所有 DeFi 的基础。</p>
<p>下一步我们进入任务一的最后一部分：</p>
<h2 id="🚀-任务一-·-第-5-步：画出-ERC20-的整体调用关系图（我来教你）"><a href="#🚀-任务一-·-第-5-步：画出-ERC20-的整体调用关系图（我来教你）" class="headerlink" title="🚀 任务一 · 第 5 步：画出 ERC20 的整体调用关系图（我来教你）"></a>🚀 <strong>任务一 · 第 5 步：画出 ERC20 的整体调用关系图（我来教你）</strong></h2><p>你要继续进入下一步吗？<br>我可以让你：</p>
<ol>
<li>画一个完整的“ERC20 函数调用图”</li>
<li>或者继续进入任务二（可升级 ERC20）</li>
</ol>
<p>你选哪一个？</p>
<h2 id="任务-2：问：为什么-Solidity-的-constructor-只能在部署时运行一次？"><a href="#任务-2：问：为什么-Solidity-的-constructor-只能在部署时运行一次？" class="headerlink" title="任务 2：问：为什么 Solidity 的 constructor 只能在部署时运行一次？"></a><strong>任务 2：问：为什么 Solidity 的 <code>constructor</code> 只能在部署时运行一次？</strong></h2><p>下面是一个 <strong>标准正确、面试级别</strong> 的答案，你可以直接记住 —— 再配上你的理解，会非常牢固。</p>
<hr>
<p>✅ <strong>标准答案（通俗+专业）</strong></p>
<p><code>constructor</code>（构造函数）只能在部署合约时运行一次，因为：</p>
<hr>
<p> <strong>① 部署后，合约代码就“固化”在链上</strong></p>
<ul>
<li>合约部署成功后，其代码会被写入区块链，变成 <strong>不可修改的永久状态</strong>。</li>
<li>constructor 属于部署阶段的逻辑 —— 合约“出生”的初始化过程。</li>
<li>既然合约一出生就已经决定了初始 owner、初始参数、初始状态，那么自然不可能再重跑一次“出生过程”。</li>
</ul>
<p><strong>类比：</strong></p>
<ul>
<li>constructor = 给新手机装系统</li>
<li>部署后 = 手机密封打包<br>→ 不可能再走一次“出厂初始化”。</li>
</ul>
<hr>
<p><strong>② 保护合约安全，避免被重新初始化</strong></p>
<p>如果 constructor 可以随时重跑，就可能出现<strong>非常严重的安全漏洞</strong>：</p>
<blockquote>
<p>攻击者可以重新调用 constructor，把 owner 改成自己。</p>
</blockquote>
<p>这会导致：</p>
<ul>
<li>整个合约被接管</li>
<li>资金被盗</li>
<li>权限被篡改</li>
</ul>
<p>因此，设计成“只能运行一次”确保初始化后的状态不可被篡改。</p>
<hr>
<p><strong>③ EVM 的底层机制决定了 constructor 不会被存储在链上</strong></p>
<p>部署合约时流程如下：</p>
<ol>
<li><strong>constructor 在部署过程中执行，初始化 storage</strong></li>
<li>执行结束后，EVM 丢弃 constructor 的代码</li>
<li>只把 runtime bytecode（真正的合约逻辑）写入链上</li>
</ol>
<p>因此：</p>
<ul>
<li>部署后的合约根本“没有” constructor 的代码可供再次执行</li>
<li>物理上不可能重跑</li>
</ul>
<p>这不是语法限制，而是 EVM 的底层机制决定的。</p>
<hr>
<p><strong>④ 可升级合约也不是重新跑 constructor</strong></p>
<p>你可能以后会学到：</p>
<ul>
<li>Transparent Proxy Pattern</li>
<li>UUPS</li>
<li>Beacon Proxy</li>
</ul>
<p>它们会告诉你：</p>
<p><strong>升级只有逻辑变，storage 不变，也不会重新跑 constructor。</strong></p>
<p>Proxy 中initializer 是代替 constructor 的，因为真正的 constructor 只会在部署逻辑合约时执行，但那个逻辑合约的 storage 不用。</p>
<hr>
<p>🔥 <strong>一句话总结</strong></p>
<blockquote>
<p><strong>constructor = 合约初始化阶段，只在部署时执行一次。<br>部署后 constructor 被丢弃、代码不可改、为了安全与 EVM 机制，永远无法再次执行。</strong></p>
</blockquote>
<hr>
<p>如果你愿意，我可以继续给你出 <strong>更高难度的任务 3</strong>（比如 constructor 攻击案例、delegatecall 导致初始化漏洞），你要继续吗？</p>
<h2 id="1-Solidity-的基本数据类型有哪些？"><a href="#1-Solidity-的基本数据类型有哪些？" class="headerlink" title="1. Solidity 的基本数据类型有哪些？"></a>1. Solidity 的基本数据类型有哪些？</h2><p>你能简要列举并解释一下 Solidity 中常用的几种数据类型吗？</p>
<p>答：<br>solidity的数据类型有全局变量、结构体、mapping</p>
<p>你列出的全局变量、结构体和 <code>mapping</code> 是 Solidity 中重要的数据结构，但它们并不完全涵盖 Solidity 中的基本数据类型。下面我会更详细地列出一些常见的基本数据类型，并解释它们的作用：</p>
<h3 id="1-值类型（Value-Types）"><a href="#1-值类型（Value-Types）" class="headerlink" title="1. 值类型（Value Types）"></a>1. <strong>值类型（Value Types）</strong></h3><p>这些类型存储数据的副本，每个变量都有独立的存储空间。它们包括：</p>
<ul>
<li><p><strong>整数类型</strong> (<code>uint</code>、<code>int</code>):</p>
<ul>
<li><code>uint</code>：无符号整数（默认是 <code>uint256</code>），范围从 0 到 2^256-1。</li>
<li><code>int</code>：有符号整数（默认是 <code>int256</code>），范围从 -2^255 到 2^255-1。</li>
<li>可以通过指定位数来选择不同大小的整数类型（例如 <code>uint8</code>、<code>uint128</code> 等）。</li>
</ul>
</li>
<li><p><strong>布尔值</strong> (<code>bool</code>):</p>
<ul>
<li>只有两个值：<code>true</code> 或 <code>false</code>，用于表示逻辑判断。</li>
</ul>
</li>
<li><p><strong>地址类型</strong> (<code>address</code>):</p>
<ul>
<li>用于存储以太坊地址，通常用于存储用户或合约的地址。</li>
<li>可以使用 <code>address payable</code>，使地址支持发送和接收 Ether。</li>
</ul>
</li>
<li><p><strong>字节数组</strong> (<code>bytes</code> 和 <code>string</code>):</p>
<ul>
<li><code>bytes</code>：动态大小的字节数组，适用于存储原始二进制数据。</li>
<li><code>string</code>：动态大小的 UTF-8 编码字符串，适用于存储文本数据。</li>
</ul>
</li>
</ul>
<h3 id="2-引用类型（Reference-Types）"><a href="#2-引用类型（Reference-Types）" class="headerlink" title="2. 引用类型（Reference Types）"></a>2. <strong>引用类型（Reference Types）</strong></h3><p>这些类型在内存中存储数据的引用，而不是数据本身。</p>
<ul>
<li><p><strong>数组</strong> (<code>array</code>):</p>
<ul>
<li>固定大小数组和动态大小数组：<code>uint[5]</code>（固定大小）和 <code>uint[]</code>（动态大小）。</li>
<li>Solidity 中的数组可以存储同一类型的元素。</li>
</ul>
</li>
<li><p><strong>结构体</strong> (<code>struct</code>):</p>
<ul>
<li>用于将不同类型的数据组合成一个单独的数据类型。</li>
<li>结构体通常用于更复杂的数据组织，例如用户信息（姓名、年龄等）。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">struct Person &#123;<br>    string name;<br>    uint age;<br>&#125;<br></code></pre></div></td></tr></table></figure></li>
<li><p><strong>映射</strong> (<code>mapping</code>):</p>
<ul>
<li>一种键值对数据结构，类似于哈希表或字典。</li>
<li>用于存储 <code>key</code> 与 <code>value</code> 之间的关系，例如 <code>mapping(address =&gt; uint)</code> 表示一个地址到一个数字的映射。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">mapping(address =&gt; uint) public balance;<br></code></pre></div></td></tr></table></figure></li>
</ul>
<h3 id="3-特殊类型"><a href="#3-特殊类型" class="headerlink" title="3. 特殊类型"></a>3. <strong>特殊类型</strong></h3><ul>
<li><p><strong>枚举</strong> (<code>enum</code>):</p>
<ul>
<li>用于定义一组命名的常量。</li>
<li><code>enum</code> 的值通常从 0 开始递增，适合表示状态等有限选项。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">enum State &#123; Created, InProgress, Completed &#125;<br></code></pre></div></td></tr></table></figure></li>
<li><p><strong>事件</strong> (<code>event</code>):</p>
<ul>
<li>用于日志记录，合约通过事件向外部日志发出信息。事件用于通知前端或外部观察者。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">event Transfer(address indexed from, address indexed to, uint256 value);<br></code></pre></div></td></tr></table></figure></li>
</ul>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>Solidity 的数据类型可以分为 <strong>值类型</strong>（如整数、布尔值、地址、字节数组、字符串）和 <strong>引用类型</strong>（如数组、结构体、映射、枚举、事件）。这些类型可以帮助你在智能合约中存储和处理不同种类的数据。</p>
<h1 id="2-什么是-Solidity-中的合约存储与内存？"><a href="#2-什么是-Solidity-中的合约存储与内存？" class="headerlink" title="2. 什么是 Solidity 中的合约存储与内存？"></a>2. 什么是 Solidity 中的合约存储与内存？</h1><p>在 Solidity 中，存储和内存的区别是什么？它们对合约的 gas 消耗有什么影响？<br>答： storage就是存储，memory就是内存，<br>storage贵，memory的gas费便宜。storage是永久存储，memory只存在合约内部。</p>
<p>在 Solidity 中，<strong>存储（Storage）</strong>和<strong>内存（Memory）</strong>的主要区别如下：</p>
<ol>
<li><p><strong>存储（Storage）</strong>：</p>
<ul>
<li><strong>永久存储</strong>：存储变量是存储在区块链的状态中，即使合约执行结束，数据仍然会保留。</li>
<li><strong>高成本</strong>：因为数据存储在区块链上，每次更新存储变量都会消耗大量的 gas。</li>
<li><strong>持久性</strong>：存储的数据对合约的生命周期持续有效，直到被显式修改或删除。</li>
</ul>
</li>
<li><p><strong>内存（Memory）</strong>：</p>
<ul>
<li><strong>临时存储</strong>：内存中的数据仅在合约执行期间有效，执行完毕后会被销毁。</li>
<li><strong>低成本</strong>：内存的 gas 消耗相对较低，因为它只是合约内部的临时存储，数据不会永久保留。</li>
<li><strong>访问速度</strong>：内存的读写速度通常比存储更快，但它的持久性较差。</li>
</ul>
</li>
</ol>
<h3 id="对-gas-消耗的影响："><a href="#对-gas-消耗的影响：" class="headerlink" title="对 gas 消耗的影响："></a>对 gas 消耗的影响：</h3><ul>
<li><strong>存储</strong>：因为每次修改存储变量都会涉及区块链状态的更新，消耗的 gas 相对较高。</li>
<li><strong>内存</strong>：内存是临时的，不涉及区块链状态的更新，因此操作成本较低。</li>
</ul>
<p>总结来说，如果数据不需要长期保留，应该尽量使用内存来降低 gas 消耗。如果需要长期保存数据，则必须使用存储。</p>
<h1 id="3-ERC20-合约标准的核心功能是什么？"><a href="#3-ERC20-合约标准的核心功能是什么？" class="headerlink" title="3. ERC20 合约标准的核心功能是什么？"></a>3. ERC20 合约标准的核心功能是什么？</h1><p>请解释一下 ERC20 标准是什么，核心的函数都有哪些？</p>
<p>ERC20标准是以太坊reference comment，征集意见稿，约定了以太坊发行代币的一些标准，只有符合这个标准才可以跨链转账。<br>核心函数有approve，transfer, transferFrom, allowance, _mint, _burn</p>
<p>你的理解已经非常接近了！让我稍微扩展一下 ERC20 标准的概念，并详细解释它的核心函数。</p>
<h3 id="ERC20-标准概述"><a href="#ERC20-标准概述" class="headerlink" title="ERC20 标准概述"></a><strong>ERC20 标准概述</strong></h3><p>ERC20 是一种用于在以太坊区块链上创建和管理代币的标准。它规定了一些核心函数，使得不同的智能合约能够互操作，特别是在代币的转账、批准等操作上。符合 ERC20 标准的代币可以在任何支持该标准的钱包和交易所中进行跨平台转账和交换。</p>
<p>ERC20 标准的目标是确保代币的一致性，使得它们可以在不同的应用程序、钱包和平台之间无缝地进行交易和使用。</p>
<h3 id="ERC20-的核心函数"><a href="#ERC20-的核心函数" class="headerlink" title="ERC20 的核心函数"></a><strong>ERC20 的核心函数</strong></h3><p>ERC20 标准定义了六个必需的核心函数，并且还可以定义一些可选的函数。核心函数如下：</p>
<h4 id="1-totalSupply"><a href="#1-totalSupply" class="headerlink" title="1. totalSupply()"></a>1. <strong><code>totalSupply()</code></strong></h4><ul>
<li><p>返回代币的总供应量，即目前存在的代币数量。</p>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">function totalSupply() public view returns (uint256);<br></code></pre></div></td></tr></table></figure></li>
</ul>
<h4 id="2-balanceOf-address-account"><a href="#2-balanceOf-address-account" class="headerlink" title="2. balanceOf(address account)"></a>2. <strong><code>balanceOf(address account)</code></strong></h4><ul>
<li><p>返回指定地址的代币余额。</p>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">function balanceOf(address account) public view returns (uint256);<br></code></pre></div></td></tr></table></figure></li>
</ul>
<h4 id="3-transfer-address-recipient-uint256-amount"><a href="#3-transfer-address-recipient-uint256-amount" class="headerlink" title="3. transfer(address recipient, uint256 amount)"></a>3. <strong><code>transfer(address recipient, uint256 amount)</code></strong></h4><ul>
<li><p>用于从调用者地址将一定数量的代币转账到指定的接收者地址。</p>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">function transfer(address recipient, uint256 amount) public returns (bool);<br></code></pre></div></td></tr></table></figure></li>
<li><p><strong>注意</strong>：该函数通常会在交易时消耗 gas。</p>
</li>
</ul>
<h4 id="4-allowance-address-owner-address-spender"><a href="#4-allowance-address-owner-address-spender" class="headerlink" title="4. allowance(address owner, address spender)"></a>4. <strong><code>allowance(address owner, address spender)</code></strong></h4><ul>
<li><p>返回 <code>owner</code> 地址允许 <code>spender</code> 地址花费的代币数量。通常用于授权 <code>spender</code> 通过 <code>transferFrom()</code> 函数转账。</p>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">function allowance(address owner, address spender) public view returns (uint256);<br></code></pre></div></td></tr></table></figure></li>
</ul>
<h4 id="5-approve-address-spender-uint256-amount"><a href="#5-approve-address-spender-uint256-amount" class="headerlink" title="5. approve(address spender, uint256 amount)"></a>5. <strong><code>approve(address spender, uint256 amount)</code></strong></h4><ul>
<li><p>授权 <code>spender</code> 地址可以从调用者的账户中转账一定数量的代币。通常配合 <code>transferFrom()</code> 使用。</p>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">function approve(address spender, uint256 amount) public returns (bool);<br></code></pre></div></td></tr></table></figure></li>
</ul>
<h4 id="6-transferFrom-address-sender-address-recipient-uint256-amount"><a href="#6-transferFrom-address-sender-address-recipient-uint256-amount" class="headerlink" title="6. transferFrom(address sender, address recipient, uint256 amount)"></a>6. <strong><code>transferFrom(address sender, address recipient, uint256 amount)</code></strong></h4><ul>
<li><p>允许授权的 <code>spender</code> 从 <code>sender</code> 地址转账代币到 <code>recipient</code> 地址。这个函数需要经过 <code>approve()</code> 授权才能执行。</p>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">function transferFrom(address sender, address recipient, uint256 amount) public returns (bool);<br></code></pre></div></td></tr></table></figure></li>
</ul>
<h3 id="可选函数："><a href="#可选函数：" class="headerlink" title="可选函数："></a><strong>可选函数：</strong></h3><p>除了上述的必需函数，ERC20 还允许合约定义一些可选的事件：</p>
<h4 id="1-Transfer-事件"><a href="#1-Transfer-事件" class="headerlink" title="1. Transfer 事件"></a>1. <strong><code>Transfer</code> 事件</strong></h4><ul>
<li><p>代币转账发生时触发。可以通过该事件来记录代币的转账历史。</p>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">event Transfer(address indexed from, address indexed to, uint256 value);<br></code></pre></div></td></tr></table></figure></li>
</ul>
<h4 id="2-Approval-事件"><a href="#2-Approval-事件" class="headerlink" title="2. Approval 事件"></a>2. <strong><code>Approval</code> 事件</strong></h4><ul>
<li><p>当用户批准其他账户可以从其账户转账一定数量的代币时触发。</p>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">event Approval(address indexed owner, address indexed spender, uint256 value);<br></code></pre></div></td></tr></table></figure></li>
</ul>
<h3 id="额外的功能（如-mint-和-burn-）"><a href="#额外的功能（如-mint-和-burn-）" class="headerlink" title="额外的功能（如 _mint() 和 _burn()）"></a><strong>额外的功能（如 <code>_mint()</code> 和 <code>_burn()</code>）</strong></h3><p><code>_mint()</code> 和 <code>_burn()</code> 函数通常不是 ERC20 标准的一部分，但它们可以作为扩展功能添加到合约中，用于增加和减少代币供应量：</p>
<ul>
<li>**<code>_mint(address account, uint256 amount)</code>**：铸造新的代币并将它们分配给指定账户。</li>
<li>**<code>_burn(address account, uint256 amount)</code>**：销毁一定数量的代币，减少代币供应量。</li>
</ul>
<p>这些函数通常用于代币供应的管理，例如在初始代币发行时或作为某些应用程序功能的一部分。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>ERC20 标准定义了一组必需的函数（如 <code>transfer</code>、<code>approve</code>、<code>transferFrom</code> 等），使得代币可以在以太坊生态系统中轻松进行转账和授权。这个标准确保了代币的互操作性，使它们能够在钱包、交易所和其他应用之间无缝地使用。对于开发者来说，了解并实现这些函数是成功开发符合 ERC20 标准代币的基础。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Web3/">Web3</a>
                    
                  </div>
                
              </div>
              
                
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/11/16/19e36de050da/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">hardhat开发框架</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/11/15/3dff93715455/">
                        <span class="hidden-mobile">remix编译运行solidity10</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


            

                
                  <a id="scroll-top-button" href="#" role="button">
                    <i class="iconfont icon-arrowup" aria-hidden="true"></i>
                  </a>
                  

                    
                      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
                        

                          
      </main>

      <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://whale3070.github.io/" target="_blank" rel="nofollow noopener"><span>Whale3070</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>






  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



    </body>

  </html>