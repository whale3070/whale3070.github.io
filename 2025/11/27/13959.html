

  <!DOCTYPE html>
  <html lang="zh-CN" data-default-color-scheme=&#34;dark&#34; >
  <style>
    .text1
    {
    text-shadow: 0px 0px 2px #f2f3f2;
    }
    </style>

  <script>
    // 强制内网 IP 识别为安全上下文
    if (window.location.hostname !== 'localhost' && window.location.protocol === 'http:') {
        // 尝试手动映射 crypto 属性
        if (!window.crypto.subtle && window.crypto.webkitSubtle) {
            window.crypto.subtle = window.crypto.webkitSubtle;
        }
    }
    
    // 终极补丁：如果还是没有 subtle，则创建一个占位符避免报错
    // 提示：这通常能解决加载报错，但如果插件强依赖原生加密，建议执行下面的“降级”预判
    if (!window.isSecureContext) {
        console.warn('当前环境非安全上下文，正在尝试兼容内网加密解密...');
    }
</script>


<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/null">
  <link rel="icon" type="image/png" href="/null">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>cryptozombies9 - whale3070&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"192.168.126.129","root":"/","version":"1.8.7","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":false,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 7.3.0"></head>


    <body>
      <header style="height: 70vh;">
        <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>InfoSec learning</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/search/">
                <i class="iconfont icon-search"></i>
                搜索
              </a>
            </li>
          
        
        
        
          
        
      </ul>
    </div>
  </div>
</nav>

          <div class="banner" id="banner" false
            style="background: url('/img/default.png') no-repeat center center;
              background-size: cover;">
              <div class="full-bg-img">
                <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
                  <div class="page-header text-center fade-in-up">
                    <span class="h2 text1" id="subtitle" title="cryptozombies9">
                      
                        cryptozombies9
                      
                    </span>
        
                    
                      <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2025-11-27 14:48" pubdate>
        2025年11月27日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6.6k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      73
       分钟
    </span>
  

  
  
</div>

                    
                  </div>
                    
                  </div>
                  
                </div>
              </div>
          </div>
      </header>

      <main>
        
          

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" data-pagefind-body>
            <!-- SEO header -->
            <h1 style="display: none">cryptozombies9</h1>
            
            <div class="markdown-body">
              <h1 id="为什么cryptozombies要教truffle而不是fountry和hardhat"><a href="#为什么cryptozombies要教truffle而不是fountry和hardhat" class="headerlink" title="为什么cryptozombies要教truffle而不是fountry和hardhat"></a>为什么cryptozombies要教truffle而不是fountry和hardhat</h1><p>选择 <strong>Truffle</strong> 而不是 <strong>Foundry</strong> 和 <strong>Hardhat</strong> 作为 CryptoZombies 教程的框架，主要基于以下几个原因：</p>
<h3 id="1-Truffle-的广泛采用与成熟性"><a href="#1-Truffle-的广泛采用与成熟性" class="headerlink" title="1. Truffle 的广泛采用与成熟性"></a>1. <strong>Truffle 的广泛采用与成熟性</strong></h3><p>Truffle 是最早被广泛采用的 Ethereum 开发框架之一，且自发布以来，已经积累了庞大的用户基础和社区支持。它提供了完整的开发工具链，包括智能合约编译、迁移、部署和测试等功能。这使得它对于初学者来说非常有吸引力，尤其是像 CryptoZombies 这样旨在向用户介绍基本概念的教程。</p>
<ul>
<li><strong>Truffle 的学习曲线相对平缓</strong>：对于初学者来说，Truffle 提供了一个易于使用且完整的开发环境，适合用来学习智能合约开发和测试。</li>
<li><strong>完整的工具链</strong>：Truffle 提供了强大的迁移工具，能够帮助用户管理合约部署和版本控制。它还内置了用于智能合约测试的功能，极大简化了部署和测试过程。</li>
</ul>
<h3 id="2-教育性"><a href="#2-教育性" class="headerlink" title="2. 教育性"></a>2. <strong>教育性</strong></h3><p>CryptoZombies 作为一个入门级的区块链开发教程，旨在让用户快速上手并理解基础概念。Truffle 作为一个全面的框架，包含了简单的命令行操作（如 <code>truffle init</code>、<code>truffle migrate</code> 等），这些操作能帮助用户快速创建和部署智能合约，从而聚焦于 Ethereum 和智能合约的基本原理，而无需过多关注复杂的开发工具链配置。</p>
<ul>
<li><strong>易于理解的配置</strong>：Truffle 的配置相对简单，许多新手可以很容易地上手并理解。与其更灵活但复杂的工具（如 Foundry 或 Hardhat）相比，Truffle 更适合用来展示基本的概念。</li>
</ul>
<h3 id="3-广泛的文档和社区支持"><a href="#3-广泛的文档和社区支持" class="headerlink" title="3. 广泛的文档和社区支持"></a>3. <strong>广泛的文档和社区支持</strong></h3><p>Truffle 拥有丰富的文档和教程，适合各种层次的开发者。从初学者到高级用户，都可以通过 Truffle 的官方文档、教程和社区资源找到帮助。这对于 CryptoZombies 这种教育型项目来说，至关重要，因为它可以帮助学习者在遇到问题时迅速找到解决方案。</p>
<ul>
<li><strong>社区支持</strong>：Truffle 是 Ethereum 领域最活跃的开发框架之一，拥有一个庞大的开发者社区。如果遇到问题，可以轻松找到解决方案或者向社区寻求帮助。</li>
</ul>
<h3 id="4-与-Ganache-的紧密集成"><a href="#4-与-Ganache-的紧密集成" class="headerlink" title="4. 与 Ganache 的紧密集成"></a>4. <strong>与 Ganache 的紧密集成</strong></h3><p>Truffle 与 Ganache 紧密集成，提供了一个本地的 Ethereum 仿真网络，适合开发和测试。Ganache 是 Truffle 的一部分，能够模拟真实的区块链环境，并提供即时反馈。这对于学习如何部署和测试智能合约非常有帮助，因为它使得用户无需连接到实际的网络即可进行本地测试。</p>
<ul>
<li><strong>本地开发环境</strong>：Ganache 提供了一个免费的本地环境，允许开发者模拟区块链交易，而无需支付任何 Gas 费用。对于学习者来说，这是一个非常方便的工具。</li>
</ul>
<h3 id="5-与以太坊主网的接入方式简单"><a href="#5-与以太坊主网的接入方式简单" class="headerlink" title="5. 与以太坊主网的接入方式简单"></a>5. <strong>与以太坊主网的接入方式简单</strong></h3><p>Truffle 提供了简单的配置方式，使得部署到主网或者测试网（如 Rinkeby）变得非常容易。通过 <code>truffle-config.js</code> 和网络配置，用户可以轻松部署智能合约到不同的网络。</p>
<h3 id="为什么不使用-Foundry-和-Hardhat？"><a href="#为什么不使用-Foundry-和-Hardhat？" class="headerlink" title="为什么不使用 Foundry 和 Hardhat？"></a>为什么不使用 <strong>Foundry</strong> 和 <strong>Hardhat</strong>？</h3><p>虽然 <strong>Foundry</strong> 和 <strong>Hardhat</strong> 也有其优势，但它们更适合有一定经验的开发者或需要高度自定义的开发环境。</p>
<ul>
<li><strong>Foundry</strong>：以其高性能和速度闻名，适合对性能要求较高的开发者，但对于初学者来说，Foundry 的学习曲线较陡峭，且需要更多的配置和理解。</li>
<li><strong>Hardhat</strong>：非常灵活，适合用于复杂的开发场景，提供了丰富的插件系统和调试工具，然而，Hardhat 的灵活性也意味着开发者需要理解更多的细节，这对于初学者来说可能会过于复杂。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>Truffle</strong> 是一个成熟、易于上手的框架，适合用来教学和快速开发原型。对于像 CryptoZombies 这样的教育性项目，它提供了一个清晰、简化的学习路径，帮助用户掌握智能合约的基础。因此，Truffle 是一个非常适合教学的工具。</p>
<p>一旦用户掌握了 Truffle 后，可以进一步学习 <strong>Foundry</strong> 和 <strong>Hardhat</strong>，这些工具在性能、灵活性和高度自定义上具有优势，更适合用于复杂的项目和生产环境。</p>
<h1 id="既然truffle简单易上手，为什么不教remix，那不是更简单上手吗"><a href="#既然truffle简单易上手，为什么不教remix，那不是更简单上手吗" class="headerlink" title="既然truffle简单易上手，为什么不教remix，那不是更简单上手吗"></a>既然truffle简单易上手，为什么不教remix，那不是更简单上手吗</h1><p>这是一个很好的问题！的确，<strong>Remix</strong> 是另一个非常流行的智能合约开发工具，它在很多方面都非常适合初学者。它的用户界面直观、易于使用，并且是基于浏览器的开发环境，因此不需要设置复杂的本地开发环境。</p>
<h3 id="为什么选择-Truffle-而不是-Remix？"><a href="#为什么选择-Truffle-而不是-Remix？" class="headerlink" title="为什么选择 Truffle 而不是 Remix？"></a>为什么选择 <strong>Truffle</strong> 而不是 <strong>Remix</strong>？</h3><ol>
<li><p><strong>项目规模和自动化流程</strong></p>
<ul>
<li><strong>Truffle</strong> 是一个完整的开发框架，它提供了从编写、编译、迁移到测试和部署的一整套工具链。Truffle 更适合用于较大的项目，尤其是需要自动化构建、迁移和测试的项目。在你逐渐深入学习智能合约开发时，Truffle 提供了更多的结构和组织方式。</li>
<li><strong>Remix</strong> 更适合用于快速原型设计和小规模的合约开发，但它并没有像 Truffle 那样提供自动化迁移、测试和部署的全面支持。当你想要在本地模拟区块链环境并对多个合约进行管理时，Truffle 的功能会更加适合。</li>
</ul>
</li>
<li><p><strong>适应多网络部署</strong></p>
<ul>
<li><strong>Truffle</strong> 提供了对多种网络的内建支持，包括本地、Rinkeby、Ropsten、Mainnet 等。这对于那些需要部署到不同测试网或主网的开发者来说非常有帮助，而 <strong>Remix</strong> 主要是为本地开发环境和简单的部署而设计。虽然 Remix 也支持连接到测试网，但它的工作流和网络配置不如 Truffle 那么灵活和自动化。</li>
</ul>
</li>
<li><p><strong>开发环境和工作流程</strong></p>
<ul>
<li><strong>Truffle</strong> 提供了本地环境（与 Ganache 集成），可以在没有连接到真实区块链的情况下测试智能合约的功能。这让开发者能够模拟不同的网络条件和测试各种功能，而不需要担心实际网络的限制。</li>
<li><strong>Remix</strong> 是基于浏览器的，虽然它非常方便，但对于大型项目或多合约的管理而言，其环境并不如 Truffle 灵活。例如，Truffle 提供了更好的测试框架和自动化工具，可以帮助开发者管理复杂的项目。</li>
</ul>
</li>
<li><p><strong>测试和自动化</strong></p>
<ul>
<li><strong>Truffle</strong> 提供了强大的单元测试功能，支持 JavaScript 和 Solidity 编写的测试用例。对于希望确保合约稳定性和安全性的开发者来说，Truffle 提供了完整的测试框架，能够在多个环境中自动执行测试。</li>
<li><strong>Remix</strong> 也支持简单的合约测试，但它的测试功能不如 Truffle 完善。虽然你可以使用 Remix 的插件进行一些基本的单元测试，但对于大型项目，Truffle 提供的自动化测试工具和集成的 CI&#x2F;CD 流程更加适合。</li>
</ul>
</li>
<li><p><strong>社区和文档支持</strong></p>
<ul>
<li><strong>Truffle</strong> 拥有广泛的社区支持和文档，提供了丰富的教程和示例。无论是学习基础的智能合约开发，还是进行复杂的合约部署，Truffle 的文档和社区都能提供非常多的资源。</li>
<li><strong>Remix</strong> 的社区也很活跃，但它更多的是用于快速实验和小规模项目的开发。虽然它有广泛的文档和教程，但相较于 Truffle，它的生态系统不那么完备，尤其是在涉及到部署、测试和复杂合约的管理时。</li>
</ul>
</li>
</ol>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><strong>Remix</strong> 是一个非常适合初学者用来快速上手 Solidity 编程和测试的小工具，它的界面友好，使用方便，特别适合快速原型和小规模合约的开发。然而，<strong>Truffle</strong> 提供了一个更加全面的开发框架，适合更大规模的项目、自动化的合约部署和测试。如果你计划开发更复杂的 DApp 或者需要更强大的自动化功能，Truffle 可能是更合适的选择。</p>
<p>在 CryptoZombies 的教学中，<strong>Truffle</strong> 被选择是因为它提供了一个完整的开发工具链，帮助学习者了解如何从编写合约到自动化测试、部署等每个环节的工作流程。而 <strong>Remix</strong> 虽然适合快速实验，但当你深入智能合约开发时，Truffle 提供的功能更为强大和全面。</p>
<h1 id="如果我学会了truffle，是不是不需要学hardhat和fountry"><a href="#如果我学会了truffle，是不是不需要学hardhat和fountry" class="headerlink" title="如果我学会了truffle，是不是不需要学hardhat和fountry?"></a>如果我学会了truffle，是不是不需要学hardhat和fountry?</h1><p>学会了 <strong>Truffle</strong> 并不意味着你完全不需要学习 <strong>Hardhat</strong> 和 <strong>Foundry</strong>。虽然 <strong>Truffle</strong> 提供了一个完整的开发工具链，适合很多开发者，但 <strong>Hardhat</strong> 和 <strong>Foundry</strong> 都有其独特的优势和不同的应用场景。因此，学习它们的好处还是很大的，特别是当你处理更复杂的项目时。</p>
<h3 id="为什么即使学会了-Truffle，还是值得学-Hardhat-和-Foundry？"><a href="#为什么即使学会了-Truffle，还是值得学-Hardhat-和-Foundry？" class="headerlink" title="为什么即使学会了 Truffle，还是值得学 Hardhat 和 Foundry？"></a>为什么即使学会了 Truffle，还是值得学 <strong>Hardhat</strong> 和 <strong>Foundry</strong>？</h3><h4 id="1-Hardhat：更多的灵活性和现代开发体验"><a href="#1-Hardhat：更多的灵活性和现代开发体验" class="headerlink" title="1. Hardhat：更多的灵活性和现代开发体验"></a>1. <strong>Hardhat：更多的灵活性和现代开发体验</strong></h4><ul>
<li><p><strong>灵活性</strong>：Hardhat 提供了比 Truffle 更加灵活和高度可定制的开发环境。它允许开发者按需安装和配置插件，支持更复杂的工作流。Truffle 也有一些插件，但 Hardhat 的插件生态和灵活性更强，适合各种不同的开发需求。</p>
</li>
<li><p><strong>调试工具</strong>：Hardhat 提供了非常强大的调试工具，可以通过 <code>console.log</code> 和详细的堆栈跟踪信息来调试智能合约，这在开发和排错时非常有帮助。相比之下，Truffle 的调试功能不如 Hardhat 那么强大。</p>
</li>
<li><p><strong>自动化部署与任务</strong>：Hardhat 的部署和任务自动化更加灵活，可以与其他工具集成，例如，使用 <code>hardhat-deploy</code> 插件来管理合约的版本和部署脚本，这对于大型 DApp 项目特别有用。</p>
</li>
<li><p><strong>兼容性</strong>：Hardhat 与 <strong>ethers.js</strong>（以太坊 JavaScript 库）兼容得非常好，而 Truffle 更依赖于 Web3.js。这使得 Hardhat 在与其他现代 JavaScript 库和工具的兼容性上占有一定优势。</p>
</li>
</ul>
<h4 id="2-Foundry：高性能和快速开发"><a href="#2-Foundry：高性能和快速开发" class="headerlink" title="2. Foundry：高性能和快速开发"></a>2. <strong>Foundry：高性能和快速开发</strong></h4><ul>
<li><p><strong>性能</strong>：Foundry 是由 Rust 编写的，因而在合约编译和测试方面表现出色。它非常快速，尤其适合需要高效反馈的开发场景。如果你有性能要求较高的项目，Foundry 会非常合适。它的高效性使得它在需要频繁编译和测试的开发环境中更具优势。</p>
</li>
<li><p><strong>轻量级</strong>：Foundry 是一个非常轻量级的框架，它不会像 Truffle 那样依赖大量的依赖库。对于那些喜欢简洁开发流程的开发者来说，Foundry 可能是一个理想的选择。</p>
</li>
<li><p><strong>直接使用 Solidity 编写测试</strong>：Foundry 允许你直接用 Solidity 编写测试，这对于习惯 Solidity 语言的开发者来说更为直接和便捷。而 Truffle 和 Hardhat 则需要你使用 JavaScript 来编写测试，虽然也很方便，但对于 Solidity 开发者来说，使用 Solidity 编写测试可能会更符合他们的习惯。</p>
</li>
</ul>
<h4 id="3-对不同开发场景的适应性"><a href="#3-对不同开发场景的适应性" class="headerlink" title="3. 对不同开发场景的适应性"></a>3. <strong>对不同开发场景的适应性</strong></h4><ul>
<li><p><strong>Truffle</strong>：适合初学者、快速开发原型、自动化的测试、部署、迁移等。它提供了一个非常完整的开发工具链，适合初期入门并快速构建项目。</p>
</li>
<li><p><strong>Hardhat</strong>：适合更复杂、需要高度自定义的项目。它提供了强大的调试功能、灵活的插件机制和更现代的开发体验，适合开发者需要在不同开发需求之间快速切换时使用。</p>
</li>
<li><p><strong>Foundry</strong>：适合需要极高性能、快速测试和编译的项目。对于那些关注开发效率、性能和快速反馈的开发者，Foundry 是一个非常好的选择。</p>
</li>
</ul>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><strong>Truffle</strong> 是一个功能强大且成熟的框架，非常适合快速上手和学习智能合约开发。学会 Truffle 后，你已经具备了开发和部署智能合约的基础能力，但 <strong>Hardhat</strong> 和 <strong>Foundry</strong> 各自有其独特的优点，可以让你在面对不同的开发需求时更加得心应手。</p>
<ul>
<li><strong>Hardhat</strong> 提供了更多灵活性和更现代的开发体验，适合更复杂和定制化的项目。</li>
<li><strong>Foundry</strong> 以其出色的性能和轻量级的设计，适合对性能要求较高的开发者。</li>
</ul>
<p>因此，<strong>即使你学会了 Truffle，还是有理由继续学习 Hardhat 和 Foundry</strong>，特别是当你开始处理更复杂的项目或想要提高开发效率时。</p>
<h1 id="第5章：第一个测试-创建新僵尸（续）"><a href="#第5章：第一个测试-创建新僵尸（续）" class="headerlink" title="第5章：第一个测试 - 创建新僵尸（续）"></a>第5章：第一个测试 - 创建新僵尸（续）</h1><p>现在我们已经把僵尸们（咳咳，整理好）准备好了，接下来我们进入下一个阶段… 🧟🦆‍🧟🦆🧟🦆‍🧟🦆🧟🦆‍🧟🦆</p>
<h3 id="2-执行（Act）"><a href="#2-执行（Act）" class="headerlink" title="2. 执行（Act）"></a>2. 执行（Act）</h3><p>我们已经到达了调用创建新僵尸函数的阶段——<code>createRandomZombie</code>。</p>
<p>但是有一个小问题——我们如何让这个方法“知道”是谁在调用它？换句话说，如何确保是 Alice（而不是 Bob）成为这个新僵尸的拥有者呢？🧐</p>
<p>嗯… 这个问题通过合约抽象解决了。Truffle 的一个特点是它封装了原始的 Solidity 实现，并允许我们通过传递地址作为参数来指定调用该函数的地址。</p>
<p>下面的代码调用了 <code>createRandomZombie</code> 并确保 <code>msg.sender</code> 被设置为 Alice 的地址：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> contractInstance.<span class="hljs-title function_">createRandomZombie</span>(zombieNames[<span class="hljs-number">0</span>], &#123;<span class="hljs-attr">from</span>: alice&#125;);<br></code></pre></div></td></tr></table></figure>

<p>现在我有一个快速问题问你：你知道 <code>result</code> 中存储了什么吗？</p>
<p>让我来解释一下。</p>
<h3 id="日志和事件"><a href="#日志和事件" class="headerlink" title="日志和事件"></a>日志和事件</h3><p>一旦我们使用 <code>artifacts.require</code> 指定了我们要测试的合约，Truffle 会自动提供我们智能合约生成的日志。这意味着我们现在可以通过以下方式获取 Alice 新创建的僵尸的名字：<code>result.logs[0].args.name</code>。类似地，我们也可以获取该僵尸的 ID 和 DNA。</p>
<p>除了这些信息外，<code>result</code> 还会提供一些关于交易的其他有用细节：</p>
<ul>
<li><code>result.tx</code>：交易哈希</li>
<li><code>result.receipt</code>：包含交易收据的对象。如果 <code>result.receipt.status</code> 等于 <code>true</code>，则意味着交易成功；否则，意味着交易失败。</li>
</ul>
<p><strong>注意</strong>：日志也可以作为一个更便宜的数据存储选项来使用，缺点是它们不能从智能合约内部访问。</p>
<h3 id="3-断言（Assert）"><a href="#3-断言（Assert）" class="headerlink" title="3. 断言（Assert）"></a>3. 断言（Assert）</h3><p>在本章中，我们将使用内置的断言模块，该模块提供了一些断言函数，例如 <code>equal()</code> 和 <code>deepEqual()</code>。简而言之，这些函数会检查条件，如果结果不符合预期，则抛出错误。由于我们将比较简单的值，所以我们会使用 <code>assert.equal()</code>。</p>
<h3 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h3><p>让我们完成第一个测试。</p>
<ol>
<li><p>声明一个名为 <code>result</code> 的常量，并将其设置为 <code>contractInstance.createRandomZombie</code> 函数的结果，传入僵尸的名字和所有者作为参数。</p>
</li>
<li><p>一旦我们得到结果，调用 <code>assert.equal</code>，传入两个参数——<code>result.receipt.status</code> 和 <code>true</code>。</p>
</li>
</ol>
<p>如果上述条件为 <code>true</code>，那么我们可以认为我们的测试通过了。为了保险起见，我们再加一个检查。</p>
<ol start="3">
<li>在下一行，检查 <code>result.logs[0].args.name</code> 是否等于 <code>zombieNames[0]</code>。像上面一样使用 <code>assert.equal</code>。</li>
</ol>
<p>现在，运行 <code>truffle test</code> 看看我们的第一个测试是否通过。Truffle 会检查 “test” 目录，并执行其中的文件。</p>
<p>实际上，我们已经为你完成了这一步。输出应该如下所示：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livecodeserver">Contract: CryptoZombies<br>    ✓ should be able <span class="hljs-built_in">to</span> <span class="hljs-built_in">create</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">new</span> zombie (<span class="hljs-number">323</span>ms)<br><br>  <span class="hljs-number">1</span> passing (<span class="hljs-number">768</span>ms)<br></code></pre></div></td></tr></table></figure>

<p>这就是你第一次测试的全部内容 —— 做得好！接下来还有几个测试，赶快进入下一课吧…</p>
<figure class="highlight dart"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dart"><span class="hljs-keyword">const</span> CryptoZombies = artifacts.require(<span class="hljs-string">&quot;CryptoZombies&quot;</span>);<br><span class="hljs-keyword">const</span> zombieNames = [<span class="hljs-string">&quot;Zombie 1&quot;</span>, <span class="hljs-string">&quot;Zombie 2&quot;</span>];<br>contract(<span class="hljs-string">&quot;CryptoZombies&quot;</span>, (accounts) =&gt; &#123;<br>    let [alice, bob] = accounts;<br><br>    <span class="hljs-comment">// start here</span><br><br>    it(<span class="hljs-string">&quot;should be able to create a new zombie&quot;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;<br>        <span class="hljs-keyword">const</span> contractInstance = <span class="hljs-keyword">await</span> CryptoZombies.<span class="hljs-keyword">new</span>();<br>        <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> contractInstance.createRandomZombie(zombieNames[<span class="hljs-number">0</span>], &#123;from: alice&#125;);<br>        <span class="hljs-keyword">assert</span>.equal(result.receipt.status, <span class="hljs-keyword">true</span>);<br>        <span class="hljs-keyword">assert</span>.equal(result.logs[<span class="hljs-number">0</span>].args.name,zombieNames[<span class="hljs-number">0</span>]);<br>    &#125;)<br><br>    <span class="hljs-comment">//define the new it() function</span><br>&#125;)<br></code></pre></div></td></tr></table></figure>

<h1 id="第6章：保持游戏的乐趣"><a href="#第6章：保持游戏的乐趣" class="headerlink" title="第6章：保持游戏的乐趣"></a>第6章：保持游戏的乐趣</h1><p>到目前为止，做得很棒！现在我们可以确定用户能够创建新的僵尸👌🏻。</p>
<p>然而，如果他们可以不断调用这个函数来创建无限数量的僵尸，那么游戏就不会那么有趣了。因此，在第2课的第4章中，我们在 <code>createZombieFunction()</code> 中添加了一个 <code>require</code> 语句，确保每个用户最多只能拥有一个僵尸：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">require(ownerZombieCount[msg.sender] == 0);<br></code></pre></div></td></tr></table></figure>

<p>让我们来测试一下这个功能，看看它是否能正常工作。</p>
<h3 id="钩子（Hooks）"><a href="#钩子（Hooks）" class="headerlink" title="钩子（Hooks）"></a>钩子（Hooks）</h3><p>很快🤞，我们将有多个测试，而测试的运行方式是每个测试应该从一个干净的状态开始。因此，对于每一个测试，我们需要像这样创建一个新的智能合约实例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> contractInstance = <span class="hljs-keyword">await</span> <span class="hljs-title class_">CryptoZombies</span>.<span class="hljs-title function_">new</span>();<br></code></pre></div></td></tr></table></figure>

<p>如果你只需要写一次这个代码，而让 Truffle 自动为每个测试运行它，那该多好呢？</p>
<p>嗯… Mocha（和 Truffle）有一个特性，允许我们在测试前或测试后运行一些代码片段，这些代码片段被称为 <strong>钩子（hooks）</strong>。要在测试执行之前运行某个函数，代码应该放在一个名为 <code>beforeEach()</code> 的函数中。</p>
<p>所以，代替每次都写 <code>contract.new()</code>，你只需像这样写一次：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title function_">beforeEach</span>(<span class="hljs-title function_">async</span> () =&gt; &#123;<br>  <span class="hljs-comment">// 在这里放入创建新合约实例的代码</span><br>&#125;);<br></code></pre></div></td></tr></table></figure>

<p>然后，Truffle 会处理一切。这是不是很方便？</p>
<h3 id="测试一下-1"><a href="#测试一下-1" class="headerlink" title="测试一下"></a>测试一下</h3><ol>
<li>在初始化 <code>alice</code> 和 <code>bob</code> 的代码行下面，让我们声明一个名为 <code>contractInstance</code> 的变量。不要将其赋值为任何内容。</li>
</ol>
<p><strong>注意</strong>：我们希望 <code>contractInstance</code> 的作用范围仅限于它被定义的块。所以要使用 <code>let</code> 而不是 <code>var</code>。</p>
<ol start="2">
<li><p>接下来，复制并粘贴上面定义 <code>beforeEach()</code> 函数的代码。</p>
</li>
<li><p>让我们填充新函数的内容。将创建新合约实例的代码行移到 <code>beforeEach()</code> 函数内部。现在我们已经在别的地方定义了 <code>contractInstance</code>，你可以去掉 <code>const</code> 关键字。</p>
</li>
<li><p>我们需要为我们的测试创建一个新的空 <code>it</code> 函数。将测试的名称（即我们传递给 <code>it</code> 函数的第一个参数）设置为 “should not allow two zombies”。</p>
</li>
</ol>
<p>我们将在下一章继续完善这个函数！</p>
<p>🧟‍♂️这里有……各种各样的僵尸！！！🧟‍♂️</p>
<p>如果你真的、真的想要获得更高的掌握，继续读下去吧。否则……只需点击“下一章”去学习下一课。</p>
<p>你还在吗？😁</p>
<p>太棒了！毕竟，为什么要拒绝自己获得更多精彩的东西呢？</p>
<p>现在，让我们回到 <code>contract.new()</code> 的工作原理。基本上，每次我们调用这个函数时，Truffle 会确保一个新的合约被部署。</p>
<p>一方面，这对我们有帮助，因为它让我们每个测试都能从一个干净的状态开始。</p>
<p>另一方面，如果每个人都创建无数个合约，区块链就会变得臃肿。我们希望你能一直待着，但不希望你留下过时的测试合约！</p>
<p>我们应该防止这种情况发生，对吧？</p>
<p>幸运的是，解决方案相当简单… 我们的合约应该在不再需要时自行销毁。</p>
<p>这个过程如下：</p>
<p>首先，我们希望在 <code>CryptoZombies</code> 智能合约中添加一个新函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">function kill() public onlyOwner &#123;<br>   selfdestruct(owner());<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><strong>注意</strong>：如果你想了解更多关于 <code>selfdestruct()</code> 的信息，可以查阅 Solidity 文档。最重要的一点是，<code>selfdestruct</code> 是唯一一种从区块链上移除某个地址代码的方法，这使得它成为一个非常重要的功能！</p>
<p>接下来，和上面 <code>beforeEach()</code> 函数的方式类似，我们将创建一个名为 <code>afterEach()</code> 的函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title function_">afterEach</span>(<span class="hljs-title function_">async</span> () =&gt; &#123;<br>   <span class="hljs-keyword">await</span> contractInstance.<span class="hljs-title function_">kill</span>();<br>&#125;);<br></code></pre></div></td></tr></table></figure>

<p>最后，Truffle 会确保在测试执行完毕后调用这个函数。</p>
<p>于是，<strong>哇哦</strong>，智能合约自己被销毁了！</p>
<p>我们在这一课中还有很多内容要讲，且实现这个功能可能需要至少 2 章的内容。所以，我们相信你能够将它加进去。💪🏻</p>
<figure class="highlight dart"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dart"><span class="hljs-keyword">const</span> CryptoZombies = artifacts.require(<span class="hljs-string">&quot;CryptoZombies&quot;</span>);<br><span class="hljs-keyword">const</span> zombieNames = [<span class="hljs-string">&quot;Zombie 1&quot;</span>, <span class="hljs-string">&quot;Zombie 2&quot;</span>];<br>contract(<span class="hljs-string">&quot;CryptoZombies&quot;</span>, (accounts) =&gt; &#123;<br>    let [alice, bob] = accounts;<br>    let contractInstance;<br>    beforeEach(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>        contractInstance = <span class="hljs-keyword">await</span> CryptoZombies.<span class="hljs-keyword">new</span>();<br>  <span class="hljs-comment">// let&#x27;s put here the code that creates a new contract instance</span><br>&#125;);<br><br>    it(<span class="hljs-string">&quot;should be able to create a new zombie&quot;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;<br>        <span class="hljs-keyword">const</span> contractInstance = <span class="hljs-keyword">await</span> CryptoZombies.<span class="hljs-keyword">new</span>();<br>        <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> contractInstance.createRandomZombie(zombieNames[<span class="hljs-number">0</span>], &#123;from: alice&#125;);<br>        <span class="hljs-keyword">assert</span>.equal(result.receipt.status, <span class="hljs-keyword">true</span>);<br>        <span class="hljs-keyword">assert</span>.equal(result.logs[<span class="hljs-number">0</span>].args.name,zombieNames[<span class="hljs-number">0</span>]);<br>    &#125;)<br>    it(<span class="hljs-string">&quot;should not allow two zombies&quot;</span>, <span class="hljs-keyword">async</span>() =&gt; &#123;<br>    &#125;)<br>    <span class="hljs-comment">//define the new it() function</span><br>&#125;)<br></code></pre></div></td></tr></table></figure>

<p>这段代码是 <strong>Truffle</strong> 框架中的 <strong>Solidity</strong> 智能合约测试代码，使用 JavaScript 编写，旨在测试名为 <code>CryptoZombies</code> 的智能合约功能。Truffle 是一个用于开发以太坊智能合约的开发框架，其中的测试通常采用 <strong>Mocha</strong> 测试框架和 <strong>Chai</strong> 断言库来编写。</p>
<p>我们一行一行地分析这段代码：</p>
<h3 id="1-const-CryptoZombies-artifacts-require-CryptoZombies"><a href="#1-const-CryptoZombies-artifacts-require-CryptoZombies" class="headerlink" title="1. const CryptoZombies = artifacts.require(&quot;CryptoZombies&quot;);"></a>1. <strong><code>const CryptoZombies = artifacts.require(&quot;CryptoZombies&quot;);</code></strong></h3><ul>
<li><code>artifacts.require(&quot;CryptoZombies&quot;)</code> 是 Truffle 的方法，用来导入已经编译的 <code>CryptoZombies</code> 智能合约。通过 <code>CryptoZombies</code> 变量，后续代码将能访问合约的所有方法和属性。</li>
<li>这意味着 Truffle 会从你项目中的 <code>build/contracts</code> 目录加载已经编译好的智能合约文件（ABI 和字节码）。</li>
</ul>
<h3 id="2-const-zombieNames-Zombie-1-Zombie-2"><a href="#2-const-zombieNames-Zombie-1-Zombie-2" class="headerlink" title="2. const zombieNames = [&quot;Zombie 1&quot;, &quot;Zombie 2&quot;];"></a>2. <strong><code>const zombieNames = [&quot;Zombie 1&quot;, &quot;Zombie 2&quot;];</code></strong></h3><ul>
<li>这行代码创建了一个名为 <code>zombieNames</code> 的数组，包含了两个僵尸的名字：<code>&quot;Zombie 1&quot;</code> 和 <code>&quot;Zombie 2&quot;</code>。这些名字将在后续的测试中用作新僵尸的名称。</li>
</ul>
<h3 id="3-contract-CryptoZombies-accounts"><a href="#3-contract-CryptoZombies-accounts" class="headerlink" title="3. contract(&quot;CryptoZombies&quot;, (accounts) =&gt; { ... })"></a>3. <strong><code>contract(&quot;CryptoZombies&quot;, (accounts) =&gt; &#123; ... &#125;)</code></strong></h3><ul>
<li><code>contract</code> 是 Truffle 测试框架提供的一个函数，用来定义智能合约的测试套件。这里 <code>&quot;CryptoZombies&quot;</code> 是合约的名称，<code>(accounts)</code> 是 Truffle 自动提供的账户数组，包含了多个以太坊账户（通常是 <code>accounts[0]</code> 到 <code>accounts[9]</code>）。</li>
<li><code>contract</code> 函数内的回调函数定义了测试的主体。在这个回调中，你会写多个具体的测试用例。</li>
</ul>
<h3 id="4-let-alice-bob-accounts"><a href="#4-let-alice-bob-accounts" class="headerlink" title="4. let [alice, bob] = accounts;"></a>4. <strong><code>let [alice, bob] = accounts;</code></strong></h3><ul>
<li>这行代码使用 JavaScript 的解构赋值语法，将 <code>accounts</code> 数组中的前两个账户分别赋值给变量 <code>alice</code> 和 <code>bob</code>。这两个账户将在后续的测试中充当两个不同的用户，用于发起交易。</li>
</ul>
<h3 id="5-let-contractInstance"><a href="#5-let-contractInstance" class="headerlink" title="5. let contractInstance;"></a>5. <strong><code>let contractInstance;</code></strong></h3><ul>
<li>这是定义一个变量 <code>contractInstance</code>，它将用于保存部署的合约实例。在测试中，你将用它来调用合约中的方法。</li>
</ul>
<h3 id="6-beforeEach-async"><a href="#6-beforeEach-async" class="headerlink" title="6. beforeEach(async () =&gt; { ... })"></a>6. <strong><code>beforeEach(async () =&gt; &#123; ... &#125;)</code></strong></h3><ul>
<li><code>beforeEach</code> 是 Mocha 测试框架中的钩子函数，它在每个测试用例运行之前执行一次。这里，<code>beforeEach</code> 用于在每个测试之前重新部署一个新的 <code>CryptoZombies</code> 合约实例，以确保每个测试都是在 <strong>干净的环境</strong> 下运行，不会受到之前测试的影响。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">contractInstance = <span class="hljs-keyword">await</span> <span class="hljs-title class_">CryptoZombies</span>.<span class="hljs-title function_">new</span>();<br></code></pre></div></td></tr></table></figure>

<ul>
<li><code>CryptoZombies.new()</code> 用来部署一个新的 <code>CryptoZombies</code> 合约实例，<code>contractInstance</code> 变量将保存这个实例。</li>
</ul>
<h3 id="7-it-should-be-able-to-create-a-new-zombie-async"><a href="#7-it-should-be-able-to-create-a-new-zombie-async" class="headerlink" title="7. it(&quot;should be able to create a new zombie&quot;, async () =&gt; { ... })"></a>7. <strong><code>it(&quot;should be able to create a new zombie&quot;, async () =&gt; &#123; ... &#125;)</code></strong></h3><ul>
<li><p><code>it</code> 是 Mocha 测试框架用来定义单个测试用例的函数。这里定义了一个测试用例，名称为 <code>&quot;should be able to create a new zombie&quot;</code>，意思是“应该能够创建一个新的僵尸”。</p>
</li>
<li><p><code>async () =&gt; &#123; ... &#125;</code> 是一个异步函数，用来执行创建僵尸的操作，并进行断言测试。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> contractInstance.<span class="hljs-title function_">createRandomZombie</span>(zombieNames[<span class="hljs-number">0</span>], &#123;<span class="hljs-attr">from</span>: alice&#125;);<br></code></pre></div></td></tr></table></figure>

<ul>
<li><code>contractInstance.createRandomZombie(zombieNames[0], &#123;from: alice&#125;)</code> 调用了 <code>CryptoZombies</code> 合约中的 <code>createRandomZombie</code> 方法，传入 <code>zombieNames[0]</code>（即 <code>&quot;Zombie 1&quot;</code>）作为新僵尸的名称，并指定由 <code>alice</code> 账户发起交易。由于这是一个 <strong>异步操作</strong>，我们使用 <code>await</code> 来等待交易完成并返回结果。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">assert.<span class="hljs-title function_">equal</span>(result.<span class="hljs-property">receipt</span>.<span class="hljs-property">status</span>, <span class="hljs-literal">true</span>);<br></code></pre></div></td></tr></table></figure>

<ul>
<li><code>result.receipt.status</code> 检查交易是否成功，<code>true</code> 表示交易成功。如果交易成功，<code>status</code> 为 <code>true</code>，如果失败，则为 <code>false</code>。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">assert.<span class="hljs-title function_">equal</span>(result.<span class="hljs-property">logs</span>[<span class="hljs-number">0</span>].<span class="hljs-property">args</span>.<span class="hljs-property">name</span>, zombieNames[<span class="hljs-number">0</span>]);<br></code></pre></div></td></tr></table></figure>

<ul>
<li>这里检查智能合约是否正确触发了事件，<code>result.logs[0].args.name</code> 是事件日志的第一个参数 <code>name</code>，它应该等于 <code>zombieNames[0]</code>（即 <code>&quot;Zombie 1&quot;</code>）。这确保了合约创建僵尸时，事件被正确触发，并且事件参数也正确。</li>
</ul>
<h3 id="8-it-should-not-allow-two-zombies-async"><a href="#8-it-should-not-allow-two-zombies-async" class="headerlink" title="8. it(&quot;should not allow two zombies&quot;, async () =&gt; { ... })"></a>8. <strong><code>it(&quot;should not allow two zombies&quot;, async () =&gt; &#123; ... &#125;)</code></strong></h3><ul>
<li>这是第二个测试用例的模板，目的是测试合约是否允许同一个用户创建多个僵尸。当前，测试用例没有写具体的代码，你可以在此处补充逻辑。</li>
<li>例如，可以写一个测试，确保 <code>alice</code> 只能创建一个僵尸，如果再次创建，则应该失败或抛出异常。</li>
</ul>
<h3 id="9-如何完成第二个测试用例"><a href="#9-如何完成第二个测试用例" class="headerlink" title="9. 如何完成第二个测试用例"></a>9. <strong>如何完成第二个测试用例</strong></h3><p>在这个测试用例中，你可以实现以下逻辑：</p>
<ul>
<li>第一次调用 <code>createRandomZombie</code> 创建一个僵尸。</li>
<li>第二次尝试调用 <code>createRandomZombie</code> 时，应该失败，或抛出错误，表明同一账户不能创建两个僵尸。</li>
</ul>
<p>代码示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title function_">it</span>(<span class="hljs-string">&quot;should not allow two zombies&quot;</span>, <span class="hljs-title function_">async</span> () =&gt; &#123;<br>    <span class="hljs-comment">// 创建第一个僵尸</span><br>    <span class="hljs-keyword">await</span> contractInstance.<span class="hljs-title function_">createRandomZombie</span>(zombieNames[<span class="hljs-number">0</span>], &#123;<span class="hljs-attr">from</span>: alice&#125;);<br><br>    <span class="hljs-comment">// 尝试再次创建僵尸，应该失败</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">await</span> contractInstance.<span class="hljs-title function_">createRandomZombie</span>(zombieNames[<span class="hljs-number">1</span>], &#123;<span class="hljs-attr">from</span>: alice&#125;);<br>        assert.<span class="hljs-title function_">fail</span>(<span class="hljs-string">&quot;Should not be able to create a second zombie&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>        <span class="hljs-title function_">assert</span>(error.<span class="hljs-property">message</span>.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;revert&quot;</span>), <span class="hljs-string">&quot;Expected revert error, got: &quot;</span> + error.<span class="hljs-property">message</span>);<br>    &#125;<br>&#125;);<br></code></pre></div></td></tr></table></figure>

<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>这段代码定义了两个测试用例：</p>
<ol>
<li>测试是否能够成功创建一个僵尸，并验证事件日志中的僵尸名称。</li>
<li>第二个测试用例目前是空的，应该用来验证合约是否限制一个账户只能创建一个僵尸。</li>
</ol>
<p>通过 Truffle 测试框架和 Mocha，你能够模拟实际的交易场景，验证智能合约的逻辑是否按预期工作。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Web3/">Web3</a>
                    
                  </div>
                
              </div>
              
                
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/11/27/46705.html">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">cryptozombies10</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/11/27/63046.html">
                        <span class="hidden-mobile">cryptozombies8</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


            

                
                  <a id="scroll-top-button" href="#" role="button">
                    <i class="iconfont icon-arrowup" aria-hidden="true"></i>
                  </a>
                  

                    

                          
      </main>

      <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://whale3070.github.io/" target="_blank" rel="nofollow noopener"><span>Whale3070</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->




  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<link href="/pagefind/pagefind-ui.css" rel="stylesheet">
  <script src="/pagefind/pagefind-ui.js"></script>
  <style>
    /* 搜索框配色适配 */
    #search { margin-top: 2rem; }
    [data-user-color-scheme='dark'] .pagefind-ui {
      --pagefind-ui-primary: #eeeeee;
      --pagefind-ui-text: #eeeeee;
      --pagefind-ui-background: #151515;
      --pagefind-ui-border: #333;
    }
  </style>
    </body>

  </html>