

  <!DOCTYPE html>
  <html lang="zh-CN" data-default-color-scheme=&#34;dark&#34; >
  <style>
    .text1
    {
    text-shadow: 0px 0px 2px #f2f3f2;
    }
    </style>

  <script>
    // 强制内网 IP 识别为安全上下文
    if (window.location.hostname !== 'localhost' && window.location.protocol === 'http:') {
        // 尝试手动映射 crypto 属性
        if (!window.crypto.subtle && window.crypto.webkitSubtle) {
            window.crypto.subtle = window.crypto.webkitSubtle;
        }
    }
    
    // 终极补丁：如果还是没有 subtle，则创建一个占位符避免报错
    // 提示：这通常能解决加载报错，但如果插件强依赖原生加密，建议执行下面的“降级”预判
    if (!window.isSecureContext) {
        console.warn('当前环境非安全上下文，正在尝试兼容内网加密解密...');
    }
</script>


<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/null">
  <link rel="icon" type="image/png" href="/null">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>cryptozombies12-NEO、zkSync - whale3070&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.4.0/styles/github-gist.min.css" />
    
  

  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"192.168.126.129","root":"/","version":"1.8.7","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":false,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 7.3.0"></head>


    <body>
      <header style="height: 70vh;">
        <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>InfoSec learning</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/search/">
                <i class="iconfont icon-search"></i>
                搜索
              </a>
            </li>
          
        
        
        
          
        
      </ul>
    </div>
  </div>
</nav>

          <div class="banner" id="banner" false
            style="background: url('/img/default.png') no-repeat center center;
              background-size: cover;">
              <div class="full-bg-img">
                <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
                  <div class="page-header text-center fade-in-up">
                    <span class="h2 text1" id="subtitle" title="cryptozombies12-NEO、zkSync">
                      
                        cryptozombies12-NEO、zkSync
                      
                    </span>
        
                    
                      <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2025-11-27 14:49" pubdate>
        2025年11月27日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      9.2k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      99
       分钟
    </span>
  

  
  
</div>

                    
                  </div>
                    
                  </div>
                  
                </div>
              </div>
          </div>
      </header>

      <main>
        
          

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" data-pagefind-body>
            <!-- SEO header -->
            <h1 style="display: none">cryptozombies12-NEO、zkSync</h1>
            
            <div class="markdown-body">
              <h1 id="NEO-Name-Service"><a href="#NEO-Name-Service" class="headerlink" title="NEO Name Service"></a>NEO Name Service</h1><p><strong>NEO</strong> 是一个强大而创新的区块链平台，正在革新去中心化应用（dApp）的构建和操作方式。</p>
<p>那么，是什么让 <strong>NEO</strong> 在众多区块链平台中脱颖而出呢？首先，<strong>NEO</strong> 被设计为高可扩展性，能够处理大量的交易每秒。这种可扩展性对于实际应用至关重要，确保即使在网络活动高峰期，用户体验也能保持流畅。</p>
<p>此外，<strong>NEO</strong> 在合规性和监管方面采取了积极的态度，使其成为企业和商界利用区块链技术的理想平台。其以合规为导向的架构促进了传统法律框架的整合，使智能合约和去中心化应用（dApp）能够与现有系统和谐共存。</p>
<p><strong>NEO</strong> 还支持多种编程语言，包括广泛使用的 <strong>C#</strong>、<strong>Java</strong> 和 <strong>Python</strong>，使其对更广泛的开发者群体更具可访问性。这种多样性使得开发者能够利用已有的技能和知识，减少学习曲线并提高生产力。</p>
<p>此外，<strong>NEO</strong> 拥有强大的生态系统，涵盖了各种工具、库和框架。开发者可以利用 <strong>neon-js</strong> JavaScript 库等工具，简化开发过程，轻松创建强大的 dApp。</p>
<p>在本课程中，我们将深入探讨 <strong>NEO Name Service</strong>（”Neo NS”），这是一个基于 <strong>Neo</strong> 区块链的分布式、开放且可扩展的命名系统。它将人类可读的名称映射到各种复杂的数据类型，如 IP 地址、域名别名、内容哈希等。</p>
<p>本课程分为两部分。第一部分将通过编写与 <strong>NEO Name Service</strong> 交互的 <strong>C#</strong> 智能合约，教授你 <strong>Neo</strong> 智能合约开发的一般知识。第二部分将专注于在 <strong>Node.js</strong> 中构建一个基于命令行界面的客户端。</p>
<p>准备好释放你的创造力吧，我们将通过动手练习和实际案例，帮助你充分发挥 <strong>Neo</strong> 区块链的全部潜力！💪🏻</p>
<h1 id="第1章：类与继承"><a href="#第1章：类与继承" class="headerlink" title="第1章：类与继承"></a>第1章：类与继承</h1><p>本课程的第一部分旨在提供知识和技能，使你能够有效地使用 <strong>C#</strong> 编程语言与 <strong>Neo Name Service</strong>（NNS）进行交互。</p>
<p><strong>C#</strong> 是一种功能强大且多用途的编程语言，以其简洁性、强类型和广泛的框架支持而闻名。此外，<strong>C#</strong> 是在 <strong>Neo</strong> 中编写智能合约的良好选择，原因有几个：</p>
<ul>
<li><strong>熟悉度</strong>：<strong>C#</strong> 被广泛使用，并且有一个庞大的开发者社区。许多开发者已经熟悉 <strong>C#</strong> 的语法、概念和工具，这使得它更容易过渡到 <strong>Neo</strong> 的智能合约开发。</li>
<li><strong>Neo 智能合约框架</strong>：<strong>Neo</strong> 提供了一个全面的智能合约框架，专门为 <strong>C#</strong> 提供了库、抽象和工具，使 <strong>Neo</strong> 智能合约的开发更加便捷。</li>
<li><strong>安全性和可靠性</strong>：<strong>C#</strong> 的强类型和静态分析能在编译时捕获许多潜在错误，从而减少运行时问题的风险。此外，<strong>C#</strong> 通过垃圾回收来进行内存管理，帮助避免常见的内存相关问题。</li>
<li><strong>生态系统与工具支持</strong>：<strong>C#</strong> 受益于 <strong>.NET</strong> 生态系统的广泛支持，开发者可以利用现有的库、测试框架和开发环境来简化智能合约开发过程。</li>
</ul>
<p>为了帮助你开始，我们已经在右侧的标签中填充了一些样板代码。以下是你需要注意的代码部分：</p>
<ul>
<li><p><code>using</code> 指令引入了 C# 程序中的命名空间，提供对这些命名空间中定义的类型和功能的访问。我们来逐行分析这些代码：</p>
<ul>
<li><strong>Neo.SmartContract.Framework</strong> - 包含与在 <strong>Neo</strong> 区块链上开发智能合约相关的类和类型，提供了专门为 <strong>Neo</strong> 智能合约开发而设计的各种功能和 API。</li>
<li><strong>Neo.SmartContract.Framework.Attributes</strong> - 包含可以应用于 <strong>Neo</strong> 智能合约中的方法、属性或类的属性，这些属性在编译和执行合约方法时提供附加信息和行为。</li>
<li><strong>Neo.SmartContract.Framework.Native</strong> - 包含与交互 <strong>Neo</strong> 本地合约和资产相关的类和类型，提供访问 <strong>Neo</strong> 内置合约的功能，例如 <strong>GAS</strong> 和 <strong>NEO</strong> 代币。</li>
<li><strong>Neo.SmartContract.Framework.Services</strong> - 提供访问 <strong>Neo</strong> 区块链平台的各种服务和功能的类和类型，包括与存储、交易、执行和其他区块链特定操作相关的功能。</li>
<li><strong>System</strong> - 提供 C# 程序中常用的基础类型、类和功能，如 <code>Object</code>、<code>String</code>、<code>BigInteger</code>。</li>
<li><strong>System.ComponentModel</strong> - 包含与基于组件的编程和设计模式相关的类型和功能。包括用于数据绑定、事件处理和其他组件相关操作的属性和接口。</li>
<li><strong>System.Numerics</strong> - 提供处理任意精度数值值的类型和操作。包括 <code>BigInteger</code> 类，允许操作超出内建数值类型范围的大整数值。</li>
</ul>
</li>
<li><p><strong>命名空间</strong> 关键字用于声明一个命名空间，它是将相关代码元素（如类、接口和其他类型）组织并分组到一个命名范围中的一种方式。命名空间有助于防止命名冲突，并提供更好的代码组织和模块化。我们在 <strong>Neo.SmartContract</strong> 命名空间内创建了一个新的子命名空间 <strong>CryptoZombies</strong>。</p>
</li>
<li><p>我们定义了一组提供代码元数据或附加信息的属性。我们不会逐个解释这些属性，但 <strong>[ContractPermission]</strong> 属性需要特别注意，因为它指定了智能合约的权限。在这个例子中，通配符字符 <code>&quot;*&quot;</code> 被用于 <code>ContractHash</code> 和 <code>Methods</code> 参数，表示合约有权限调用任何其他合约并执行任何方法。换句话说，这个属性允许合约与区块链上的其他合约进行无限制交互。</p>
</li>
</ul>
<h3 id="类：构建结构化和可重用的智能合约"><a href="#类：构建结构化和可重用的智能合约" class="headerlink" title="类：构建结构化和可重用的智能合约"></a>类：构建结构化和可重用的智能合约</h3><p>类是一个基础的编程构造，用来定义智能合约中对象的结构、行为和功能。类作为创建对象（实例）的模板或蓝图，这些对象具有相似的特征和行为。</p>
<p>在 <strong>Neo</strong> 中，类是通过面向对象编程（OOP）原则定义的。它们封装了数据和操作这些数据的方法。类中的数据和方法的组合允许代码的组织和抽象，从而促进模块化、可重用性和可维护性。</p>
<p>以下示例代码创建了一个名为 <code>HelloWorldContract</code> 的类，它将数据（<code>message</code> 字段）和行为（<code>GetMessage()</code> 方法）封装在一个单元中：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldContract</span> : <span class="hljs-title">Framework.SmartContract</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> message = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> <span class="hljs-title">GetMessage</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> message;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>关于此示例需要注意以下几点：</p>
<ul>
<li><strong>public</strong> 关键字是访问修饰符，表示类可以从其包含的作用域之外访问。我们将在下一章详细介绍。</li>
<li><strong>: (冒号)</strong> 表示继承，表示该类继承自 <code>Framework.SmartContract</code> 类。</li>
</ul>
<h3 id="什么是继承？"><a href="#什么是继承？" class="headerlink" title="什么是继承？"></a>什么是继承？</h3><p>继承在 <strong>Neo</strong> 中就像是区块链上的家族关系！就像你可能继承了父亲的迷人外貌或祖母的最佳煎饼秘方一样，在 <strong>Neo</strong> 中，继承允许一个智能合约继承另一个智能合约的特征和功能。它就像是将代码超能力从一代传到下一代！想象一下，你的智能合约是一个自豪的后代，继承了一个强大的祖先的所有方法、属性，甚至是偶尔的冷笑话。这就像是家族关系，只不过是代码！</p>
<p>在 <strong>Neo</strong> 中的继承就像是区块链在说：“嘿，你应该继承你智能合约祖先的所有酷功能。”</p>
<h3 id="动手实践"><a href="#动手实践" class="headerlink" title="动手实践"></a>动手实践</h3><p>声明一个名为 <code>NNSClient</code> 的公共类，继承自 <code>Framework.SmartContract</code>。</p>
<h1 id="Neo-Name-Service和tron有什么区别"><a href="#Neo-Name-Service和tron有什么区别" class="headerlink" title="Neo Name Service和tron有什么区别?"></a>Neo Name Service和tron有什么区别?</h1><p><strong>Neo Name Service (Neo NS)</strong> 和 <strong>TRON</strong> 是两个不同的区块链项目，它们分别具有不同的目标、技术栈和功能。尽管它们都支持去中心化应用（DApps），但它们的目标、架构和具体实现方式有很大的不同。以下是 <strong>Neo Name Service</strong> 和 <strong>TRON</strong> 的一些主要区别：</p>
<h3 id="1-项目目标和定位"><a href="#1-项目目标和定位" class="headerlink" title="1. 项目目标和定位"></a>1. <strong>项目目标和定位</strong></h3><ul>
<li><p><strong>Neo Name Service (Neo NS)</strong>:</p>
<ul>
<li><strong>Neo Name Service</strong> 是基于 <strong>Neo 区块链</strong> 的去中心化域名系统，类似于传统的 <strong>DNS</strong>（域名系统），但它是为区块链和去中心化应用（DApps）设计的。它通过将人类可读的名称映射到各种复杂的数据类型（如 IP 地址、域名别名、内容哈希等），简化了区块链地址的使用。</li>
<li>主要目标是使区块链地址和相关资源更加易于使用和访问，为区块链应用提供 <strong>去中心化的域名解析</strong> 服务。</li>
</ul>
</li>
<li><p><strong>TRON</strong>:</p>
<ul>
<li><strong>TRON</strong> 是一个去中心化的区块链平台，致力于构建全球范围内自由、高效的数字内容娱乐系统，允许开发者创建去中心化应用（DApp），尤其是在 <strong>内容分发</strong> 和 <strong>娱乐</strong> 行业。</li>
<li>TRON 的目标是提供 <strong>高可扩展性、高交易速度和低交易成本</strong>，使开发者能够创建更为灵活和高效的 DApps，尤其是在娱乐、游戏和社交应用领域。</li>
</ul>
</li>
</ul>
<h3 id="2-区块链架构与共识机制"><a href="#2-区块链架构与共识机制" class="headerlink" title="2. 区块链架构与共识机制"></a>2. <strong>区块链架构与共识机制</strong></h3><ul>
<li><p><strong>Neo</strong>:</p>
<ul>
<li><strong>Neo</strong> 使用 <strong>dBFT（Delegated Byzantine Fault Tolerance）</strong> 共识算法，这种算法通过委托节点（<strong>代表节点</strong>）来增加共识效率。它能够处理较高的交易吞吐量，并且提供较低的交易延迟。</li>
<li><strong>Neo</strong> 是一个 <strong>EVM（以太坊虚拟机）兼容</strong> 的平台，支持智能合约，能够通过 <strong>C#</strong>、<strong>Java</strong>、<strong>Python</strong> 等多种编程语言开发智能合约。</li>
</ul>
</li>
<li><p><strong>TRON</strong>:</p>
<ul>
<li><strong>TRON</strong> 使用 <strong>DPoS（Delegated Proof of Stake）</strong> 共识算法，允许用户通过投票选择代表节点来进行交易验证和生产区块。这种共识机制也能够提供高吞吐量和低延迟。</li>
<li>TRON 也支持智能合约，但它专门为 <strong>TRON 虚拟机（TVM）</strong> 提供支持，支持用 <strong>Solidity</strong> 和 <strong>Java</strong> 等语言开发合约。</li>
</ul>
</li>
</ul>
<h3 id="3-交易速度与费用"><a href="#3-交易速度与费用" class="headerlink" title="3. 交易速度与费用"></a>3. <strong>交易速度与费用</strong></h3><ul>
<li><p><strong>Neo</strong>:</p>
<ul>
<li><strong>Neo</strong> 设计了一个 <strong>高效、低成本的交易机制</strong>，使得它能够在不牺牲去中心化的情况下，支持更高的交易吞吐量。</li>
<li><strong>Neo</strong> 的交易费用非常低，特别是对于智能合约的部署和调用。</li>
</ul>
</li>
<li><p><strong>TRON</strong>:</p>
<ul>
<li><strong>TRON</strong> 以 <strong>高吞吐量</strong> 和 <strong>低交易费用</strong> 著称，特别适合需要频繁交易的 DApps 和平台（如在线游戏、娱乐内容平台等）。TRON 网络声称每秒可以处理 <strong>2000+</strong> 笔交易，这使其在需要快速交易的场景中具有优势。</li>
</ul>
</li>
</ul>
<h3 id="4-智能合约支持"><a href="#4-智能合约支持" class="headerlink" title="4. 智能合约支持"></a>4. <strong>智能合约支持</strong></h3><ul>
<li><p><strong>Neo</strong>:</p>
<ul>
<li><strong>Neo</strong> 支持多个编程语言（包括 <strong>C#</strong>、<strong>Java</strong> 和 <strong>Python</strong>），使得更多的开发者能够快速上手并构建智能合约。</li>
<li>Neo 提供的 <strong>智能合约框架</strong> 对开发者非常友好，提供了多种工具来简化合约开发和部署。</li>
</ul>
</li>
<li><p><strong>TRON</strong>:</p>
<ul>
<li><strong>TRON</strong> 主要通过 <strong>TRON 虚拟机（TVM）</strong> 来运行智能合约，支持的编程语言主要是 <strong>Solidity</strong>（与以太坊相似），以及部分支持 Java。</li>
<li>TRON 提供了强大的开发工具和支持生态系统，帮助开发者构建去中心化应用。</li>
</ul>
</li>
</ul>
<h3 id="5-去中心化域名系统（Neo-NS-与-TRON）"><a href="#5-去中心化域名系统（Neo-NS-与-TRON）" class="headerlink" title="5. 去中心化域名系统（Neo NS 与 TRON）"></a>5. <strong>去中心化域名系统（Neo NS 与 TRON）</strong></h3><ul>
<li><p><strong>Neo Name Service (Neo NS)</strong>:</p>
<ul>
<li><strong>Neo NS</strong> 是 Neo 区块链上专门为去中心化应用设计的域名系统。它允许用户为自己的账户、智能合约或其他资源设置可读的名称，便于在区块链上引用和访问。</li>
<li><strong>Neo NS</strong> 通过映射人类可读的名称到地址（例如，IP 地址、内容哈希等），为区块链应用提供了类似于传统互联网中的 <strong>DNS</strong>（域名系统）的功能。</li>
</ul>
</li>
<li><p><strong>TRON</strong>:</p>
<ul>
<li><strong>TRON</strong> 本身并没有专门的去中心化域名服务（DNS）系统像 <strong>Neo NS</strong> 那样，但它支持用户在 <strong>TRON 生态系统</strong> 中开发和使用 DApp，支持通过智能合约实现去中心化的资源管理和服务。</li>
</ul>
</li>
</ul>
<h3 id="6-生态系统与应用场景"><a href="#6-生态系统与应用场景" class="headerlink" title="6. 生态系统与应用场景"></a>6. <strong>生态系统与应用场景</strong></h3><ul>
<li><p><strong>Neo</strong>:</p>
<ul>
<li><strong>Neo</strong> 的生态系统非常注重 <strong>企业级应用</strong> 和 <strong>合规性</strong>，它被许多企业和政府项目采用，提供了一个更加合规的区块链平台。Neo 适合金融、资产管理、身份认证等多个领域的应用。</li>
<li><strong>Neo</strong> 在 <strong>去中心化金融（DeFi）</strong> 和 <strong>数字资产管理</strong> 等领域也有广泛的应用。</li>
</ul>
</li>
<li><p><strong>TRON</strong>:</p>
<ul>
<li><strong>TRON</strong> 更注重 <strong>娱乐和内容创作</strong>，特别是在 <strong>去中心化内容分发平台</strong>（如视频流、社交媒体、游戏等）方面有显著优势。TRON 的目标是通过提供低交易费用和高吞吐量来支持这些领域的大规模应用。</li>
<li><strong>TRON</strong> 特别适合应用于 <strong>游戏、社交媒体</strong> 和 <strong>娱乐平台</strong>，例如，像 <strong>BitTorrent</strong> 这样的去中心化文件共享平台也已经加入 TRON 网络。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>Neo Name Service (Neo NS)</strong> 主要是一个去中心化的域名系统，专为 Neo 区块链设计，用于映射可读名称到各种复杂的数据类型，并支持多个编程语言。</li>
<li><strong>TRON</strong> 是一个高效、低成本的区块链平台，专注于去中心化应用，特别是在娱乐和内容分发领域，并通过 TRON 虚拟机（TVM）支持智能合约。</li>
</ul>
<p>两者虽然都是区块链平台，但在目标、架构、智能合约语言和应用场景上有所不同。<strong>Neo</strong> 强调企业级应用和合规性，而 <strong>TRON</strong> 更侧重于内容创作和娱乐行业的去中心化应用。</p>
<h1 id="Neo-支持多个编程语言（包括-C-、Java-和-Python），使得更多的开发者能够快速上手并构建智能合约。那我学solidity干什么？c-和python我都会啊"><a href="#Neo-支持多个编程语言（包括-C-、Java-和-Python），使得更多的开发者能够快速上手并构建智能合约。那我学solidity干什么？c-和python我都会啊" class="headerlink" title="Neo 支持多个编程语言（包括 C#、Java 和 Python），使得更多的开发者能够快速上手并构建智能合约。那我学solidity干什么？c#和python我都会啊"></a>Neo 支持多个编程语言（包括 C#、Java 和 Python），使得更多的开发者能够快速上手并构建智能合约。那我学solidity干什么？c#和python我都会啊</h1><p>如果你已经熟悉 <strong>C#</strong> 和 <strong>Python</strong>，而 <strong>Neo</strong> 支持这些语言用于智能合约开发，那么你可能会问，为什么还要学习 <strong>Solidity</strong>，特别是当你已经能用 <strong>C#</strong> 和 <strong>Python</strong> 开发智能合约时？</p>
<p>这里有几个原因可以帮助你理解 <strong>Solidity</strong> 学习的价值，以及在不同区块链平台上的作用：</p>
<h3 id="1-Solidity-是以太坊的标准智能合约语言"><a href="#1-Solidity-是以太坊的标准智能合约语言" class="headerlink" title="1. Solidity 是以太坊的标准智能合约语言"></a>1. <strong>Solidity 是以太坊的标准智能合约语言</strong></h3><ul>
<li><strong>Solidity</strong> 是 <strong>以太坊</strong> 和其他与 <strong>EVM（以太坊虚拟机）兼容</strong> 的区块链平台（如 <strong>Binance Smart Chain</strong>、<strong>Avalanche</strong> 等）上开发智能合约的标准语言。以太坊是目前 <strong>智能合约</strong> 和 <strong>去中心化应用（DApp）</strong> 开发中最广泛使用的平台之一，许多区块链项目和 DApp 都基于以太坊生态系统。</li>
<li>由于 <strong>Solidity</strong> 是以太坊生态系统的核心语言，学习 <strong>Solidity</strong> 可以让你在 <strong>以太坊</strong> 及其兼容平台上构建智能合约，扩大你的开发能力和职业发展前景。</li>
</ul>
<h3 id="2-Solidity-在去中心化金融（DeFi）和其他-DApp-领域的广泛应用"><a href="#2-Solidity-在去中心化金融（DeFi）和其他-DApp-领域的广泛应用" class="headerlink" title="2. Solidity 在去中心化金融（DeFi）和其他 DApp 领域的广泛应用"></a>2. <strong>Solidity 在去中心化金融（DeFi）和其他 DApp 领域的广泛应用</strong></h3><ul>
<li><strong>Solidity</strong> 被大量用于 <strong>去中心化金融（DeFi）</strong> 和 <strong>NFT</strong> 等热门领域。以太坊是 <strong>DeFi</strong> 和 <strong>NFT</strong> 的主力平台，几乎所有的大型 DeFi 协议（如 <strong>Uniswap</strong>、<strong>Aave</strong>、<strong>Compound</strong>）和 NFT 项目（如 <strong>CryptoPunks</strong>、<strong>Bored Ape Yacht Club</strong>）都基于 <strong>Solidity</strong> 和 <strong>以太坊</strong>。</li>
<li>如果你对 <strong>DeFi</strong> 或 <strong>NFT</strong> 开发感兴趣，掌握 <strong>Solidity</strong> 是非常必要的，它是这些技术的核心。</li>
</ul>
<h3 id="3-多平台开发的灵活性"><a href="#3-多平台开发的灵活性" class="headerlink" title="3. 多平台开发的灵活性"></a>3. <strong>多平台开发的灵活性</strong></h3><ul>
<li>学习 <strong>Solidity</strong> 能让你具备 <strong>跨平台开发</strong> 的能力。虽然 <strong>Neo</strong> 提供了 <strong>C#</strong> 和 <strong>Python</strong> 的支持，允许你使用这些语言开发智能合约，但如果你想开发 <strong>去中心化应用（DApp）</strong> 并希望能够跨多个区块链平台（如 <strong>Ethereum</strong>、<strong>Binance Smart Chain</strong>、<strong>Avalanche</strong> 等）进行开发，那么掌握 <strong>Solidity</strong> 就变得非常有用。</li>
<li><strong>Solidity</strong> 是 <strong>EVM 兼容链</strong> 中的核心语言，而这些链（如 <strong>以太坊</strong>、<strong>Polygon</strong>、<strong>Fantom</strong>、<strong>Arbitrum</strong> 等）占据了整个区块链生态系统的大部分市场份额。</li>
</ul>
<h3 id="4-学习-Solidity-能增强你的职业竞争力"><a href="#4-学习-Solidity-能增强你的职业竞争力" class="headerlink" title="4. 学习 Solidity 能增强你的职业竞争力"></a>4. <strong>学习 <strong>Solidity</strong> 能增强你的职业竞争力</strong></h3><ul>
<li><strong>Solidity</strong> 是区块链领域中最受欢迎和需求最大的技能之一。许多 <strong>区块链公司</strong> 和 <strong>去中心化应用</strong> 开发团队需要 <strong>Solidity 开发者</strong>，因此掌握 <strong>Solidity</strong> 使你具备了进入这一行业的强大竞争力。</li>
<li>在求职市场上，能够在多个平台上进行智能合约开发（如 <strong>Neo</strong>、<strong>Ethereum</strong> 等）会使你具备更多的就业机会。</li>
</ul>
<h3 id="5-Neo-与-Ethereum-的不同目标和架构"><a href="#5-Neo-与-Ethereum-的不同目标和架构" class="headerlink" title="5. Neo 与 Ethereum 的不同目标和架构"></a>5. <strong>Neo 与 Ethereum 的不同目标和架构</strong></h3><ul>
<li>虽然 <strong>Neo</strong> 确实支持 <strong>C#</strong> 和 <strong>Python</strong>，并为这些语言提供了强大的框架支持，但 <strong>Neo</strong> 与 <strong>Ethereum</strong> 在目标和生态系统上有不同的定位。</li>
<li><strong>Neo</strong> 强调企业级应用，特别是在 <strong>合规性</strong> 和 <strong>数字资产管理</strong> 方面，而 <strong>Ethereum</strong> 更加注重 <strong>去中心化金融</strong>、<strong>NFT</strong> 和 <strong>智能合约的灵活性</strong>。</li>
<li><strong>Solidity</strong> 在以太坊生态中有着独特的地位，并且大多数创新的 <strong>DeFi 协议</strong> 和 <strong>NFT 市场</strong> 都是在 <strong>Ethereum</strong> 上进行开发的。如果你想要在这些领域有更多的机会，学习 <strong>Solidity</strong> 是一个明智的选择。</li>
</ul>
<h3 id="6-语言的生态系统和工具支持"><a href="#6-语言的生态系统和工具支持" class="headerlink" title="6. 语言的生态系统和工具支持"></a>6. <strong>语言的生态系统和工具支持</strong></h3><ul>
<li><strong>Solidity</strong> 拥有非常丰富的生态系统和开发工具支持。例如，<strong>Truffle</strong>、<strong>Hardhat</strong> 等框架帮助开发者编写、测试和部署智能合约。此外，许多前端库（如 <strong>Web3.js</strong> 和 <strong>ethers.js</strong>）以及钱包（如 <strong>MetaMask</strong>）也都围绕 <strong>Solidity</strong> 进行开发，提供了无缝的集成体验。</li>
<li>如果你想利用这些工具来加速开发过程，学习 <strong>Solidity</strong> 是必不可少的。</li>
</ul>
<h3 id="7-C-和-Python-与-Solidity-的互补性"><a href="#7-C-和-Python-与-Solidity-的互补性" class="headerlink" title="7. C# 和 Python 与 Solidity 的互补性"></a>7. <strong>C# 和 Python 与 Solidity 的互补性</strong></h3><ul>
<li>你并不需要放弃 <strong>C#</strong> 或 <strong>Python</strong>。相反，学习 <strong>Solidity</strong> 可以与你现有的技能互补。你可以利用 <strong>C#</strong> 或 <strong>Python</strong> 开发 <strong>Neo</strong> 上的智能合约，而 <strong>Solidity</strong> 则可以让你在以太坊及其他 <strong>EVM 兼容链</strong> 上开发智能合约。</li>
<li>如果你熟悉 <strong>C#</strong> 和 <strong>Python</strong>，可以通过与 <strong>Solidity</strong> 一起使用这些语言来提升你的跨平台开发能力，拓展你的开发范围。</li>
</ul>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>虽然 <strong>Neo</strong> 支持 <strong>C#</strong> 和 <strong>Python</strong> 开发智能合约，但学习 <strong>Solidity</strong> 依然是非常重要的，因为它是 <strong>以太坊</strong> 和 <strong>EVM 兼容区块链平台</strong> 上的核心语言。通过学习 <strong>Solidity</strong>，你可以在 <strong>DeFi</strong>、<strong>NFT</strong> 和 <strong>去中心化应用</strong> 的开发领域拥有更多的机会，并在跨平台开发和就业市场中占据优势。</p>
<p>如果你已经熟悉 <strong>C#</strong> 和 <strong>Python</strong>，那么学习 <strong>Solidity</strong> 会是你技能的有力补充，使你能够在 <strong>多个区块链平台</strong> 上进行开发，并为将来可能遇到的 <strong>去中心化金融（DeFi）</strong> 和 <strong>NFT</strong> 领域的需求做好准备。</p>
<p>答案：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> Neo.SmartContract.Framework;<br><span class="hljs-keyword">using</span> Neo.SmartContract.Framework.Attributes;<br><span class="hljs-keyword">using</span> Neo.SmartContract.Framework.Native;<br><span class="hljs-keyword">using</span> Neo.SmartContract.Framework.Services;<br><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.ComponentModel;<br><span class="hljs-keyword">using</span> System.Numerics;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">Neo.SmartContract.CryptoZombies</span><br>&#123;<br>    [<span class="hljs-meta">DisplayName(<span class="hljs-string">&quot;TestNNS&quot;</span>)</span>]<br>    [<span class="hljs-meta">ManifestExtra(<span class="hljs-string">&quot;Author&quot;</span>, <span class="hljs-string">&quot;CryptoZombies&quot;</span>)</span>]<br>    [<span class="hljs-meta">ManifestExtra(<span class="hljs-string">&quot;Email&quot;</span>, <span class="hljs-string">&quot;hello@cryptozombies.io&quot;</span>)</span>]<br>    [<span class="hljs-meta">ManifestExtra(<span class="hljs-string">&quot;Description&quot;</span>, <span class="hljs-string">&quot;This is a a client for invoking NNS&quot;</span>)</span>]<br>    [<span class="hljs-meta">ContractPermission(<span class="hljs-string">&quot;*&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>)</span>]<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">NNSClient</span> : <span class="hljs-title">Framework.SmartContract</span> <br>    &#123;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="有必要学NEO吗？"><a href="#有必要学NEO吗？" class="headerlink" title="有必要学NEO吗？"></a>有必要学NEO吗？</h1><p>NEO 是一个强大而创新的区块链平台，正在革新去中心化应用（dApp）的构建和操作方式。我如果做solidity开发，有必要学这个吗。注意我香港高才通只有2年时间找工作，非必要不学。我的时间有限</p>
<p><strong>NEO</strong> 确实是一个强大且创新的区块链平台，特别是在 <strong>去中心化应用（DApp）</strong> 方面有着显著的优势。但如果你主要专注于 <strong>Solidity 开发</strong>，而且你的时间有限，是否学习 <strong>NEO</strong> 取决于几个因素，尤其是你希望从事的职业方向和市场需求。</p>
<h3 id="1-Solidity-开发与-NEO-的差异"><a href="#1-Solidity-开发与-NEO-的差异" class="headerlink" title="1. Solidity 开发与 NEO 的差异"></a>1. <strong>Solidity 开发与 NEO 的差异</strong></h3><ul>
<li><strong>Solidity</strong> 是以太坊及其兼容链的主要智能合约语言，广泛应用于 <strong>去中心化金融（DeFi）</strong>、<strong>NFT</strong> 等领域。如果你专注于 <strong>Solidity</strong>，你将更多地涉及到以太坊生态系统中的应用，这个生态系统有着广泛的市场需求，尤其是在 <strong>DeFi</strong> 和 <strong>NFT</strong> 等热门领域。</li>
<li><strong>NEO</strong> 作为一个区块链平台，支持多种编程语言（如 <strong>C#</strong>、<strong>Java</strong> 和 <strong>Python</strong>），而它的智能合约开发通常不使用 <strong>Solidity</strong>，而是 <strong>C#</strong> 等语言。虽然 <strong>Neo Name Service (Neo NS)</strong> 和 <strong>Neo</strong> 区块链在一些应用中有它的优势，但它的应用和市场份额相对较小，尤其是在 <strong>DeFi</strong> 和 <strong>NFT</strong> 等主流区块链应用领域。</li>
</ul>
<h3 id="2-香港市场的需求"><a href="#2-香港市场的需求" class="headerlink" title="2. 香港市场的需求"></a>2. <strong>香港市场的需求</strong></h3><ul>
<li>在香港的区块链市场，<strong>Solidity 开发</strong> 仍然是最受欢迎和最有需求的技能之一。香港作为亚洲的金融中心，很多金融科技公司和区块链初创企业都在使用以太坊及其兼容链开发 <strong>DeFi</strong> 和其他去中心化应用。<strong>Solidity</strong> 开发者在香港的就业机会相对较多，尤其是在 <strong>去中心化金融（DeFi）</strong>、<strong>NFT</strong> 和其他区块链相关领域。</li>
<li><strong>NEO</strong> 作为一个 <strong>企业级平台</strong>，在某些特定领域（如企业级应用、身份验证等）可能有应用场景，但其市场需求和就业机会相较于 <strong>Solidity</strong> 的 <strong>以太坊生态系统</strong> 要小一些。</li>
</ul>
<h3 id="3-NEO-学习的必要性"><a href="#3-NEO-学习的必要性" class="headerlink" title="3. NEO 学习的必要性"></a>3. <strong>NEO 学习的必要性</strong></h3><ul>
<li>如果你的主要目标是 <strong>Solidity 开发</strong>，并且你计划在 <strong>DeFi</strong>、<strong>NFT</strong> 或其他以太坊相关的区块链领域工作，<strong>学习 NEO</strong> 并不是一个必要的步骤。你的时间有限，专注于 <strong>Solidity</strong> 和 <strong>以太坊生态系统</strong> 将更有效率，并且可以为你在香港的区块链市场提供更多的就业机会。</li>
<li>然而，如果你对 <strong>Neo Name Service (Neo NS)</strong> 或 <strong>企业级应用</strong> 开发感兴趣，并且想探索其他区块链平台，那么学习 <strong>Neo</strong> 是有价值的，但这并不影响你学习 <strong>Solidity</strong> 和 <strong>以太坊</strong> 的基础。</li>
</ul>
<h3 id="4-考虑时间有限的情况下"><a href="#4-考虑时间有限的情况下" class="headerlink" title="4. 考虑时间有限的情况下"></a>4. <strong>考虑时间有限的情况下</strong></h3><ul>
<li>既然你提到时间有限，而且你的目标是 <strong>尽快找到工作</strong>，那么学习 <strong>Solidity</strong> 和 <strong>以太坊</strong> 是最有效的选择。通过专注于 <strong>Solidity</strong>，你可以在 <strong>DeFi</strong>、<strong>NFT</strong>、<strong>去中心化应用（DApp）</strong> 等领域获得更多机会，而这些领域在区块链行业中仍然是需求最强烈的。</li>
</ul>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li>**如果你的目标是找到一份区块链开发的工作，特别是在香港这样的市场，**并且你主要对 <strong>Solidity 开发</strong> 感兴趣，那么 <strong>学习 NEO 并不是必须的</strong>。专注于 <strong>Solidity</strong> 和 <strong>以太坊</strong> 生态系统将使你在有限的时间内提升自己在区块链领域的竞争力。</li>
<li><strong>NEO</strong> 在一些特定的企业应用和去中心化领域可能有市场，但相对来说，它的需求和市场份额较小，特别是与 <strong>Solidity</strong> 和 <strong>以太坊</strong> 相比。</li>
</ul>
<p>如果你的时间有限，专注于 <strong>Solidity 开发</strong> 和 <strong>以太坊生态系统</strong> 是更明智的选择，尤其是在香港这样的市场，需求大且前景广阔。</p>
<h1 id="有必要学zkSync吗？"><a href="#有必要学zkSync吗？" class="headerlink" title="有必要学zkSync吗？"></a>有必要学zkSync吗？</h1><p>要成为一名 <strong>Solidity 开发者</strong>，学习 <strong>zkSync</strong> 并不是必需的，但它可能会对你未来的技能提升和工作机会产生影响，特别是如果你有意从事 <strong>去中心化金融（DeFi）</strong> 或其他需要高吞吐量和低交易费用的区块链应用。</p>
<h3 id="为什么-zkSync-可能有用？"><a href="#为什么-zkSync-可能有用？" class="headerlink" title="为什么 zkSync 可能有用？"></a>为什么 <strong>zkSync</strong> 可能有用？</h3><p><strong>zkSync</strong> 是一个基于 <strong>零知识卷积（ZK-rollups）</strong> 的二层扩展解决方案，它与 <strong>以太坊</strong> 兼容，能够显著提高交易速度，减少费用，同时保持以太坊的安全性。以下是你为什么可能想要了解 <strong>zkSync</strong> 的几个原因：</p>
<ol>
<li><p><strong>提升交易效率：</strong></p>
<ul>
<li><strong>zkSync</strong> 通过 <strong>ZK-rollup</strong> 技术将大量的交易数据处理和计算从主链转移到链外，从而提高交易吞吐量，减少交易费用。如果你从事 <strong>DeFi</strong> 或 <strong>NFT</strong> 项目开发，使用 <strong>zkSync</strong> 进行高效的交易处理可能是一个很好的选择。</li>
</ul>
</li>
<li><p><strong>零知识证明和扩展性：</strong></p>
<ul>
<li><strong>zkSync</strong> 利用 <strong>零知识证明</strong>（zkp）技术，这是一个在区块链开发中日益重要的领域。理解和使用这些技术可以帮助你在开发更复杂的区块链应用时具备竞争优势，特别是在需要隐私保护和高扩展性的应用场景下。</li>
</ul>
</li>
<li><p><strong>与以太坊兼容：</strong></p>
<ul>
<li><strong>zkSync</strong> 是 <strong>以太坊兼容</strong> 的，这意味着如果你已经熟悉 <strong>Solidity</strong> 和 <strong>以太坊</strong>，那么迁移到 <strong>zkSync</strong> 开发会更加容易。你可以利用现有的工具和生态系统（如 <strong>Truffle</strong>、<strong>Hardhat</strong> 等）来部署和交互智能合约。</li>
</ul>
</li>
<li><p><strong>去中心化金融（DeFi）和区块链应用的需求：</strong></p>
<ul>
<li>目前，越来越多的 <strong>DeFi</strong> 项目和 <strong>NFT</strong> 平台使用 <strong>zkSync</strong> 作为扩展解决方案，以应对以太坊主网的交易成本和速度瓶颈。了解 <strong>zkSync</strong> 可能会让你在这些项目中更具市场竞争力。</li>
</ul>
</li>
</ol>
<h3 id="是否必须学习-zkSync？"><a href="#是否必须学习-zkSync？" class="headerlink" title="是否必须学习 zkSync？"></a>是否必须学习 zkSync？</h3><p>对于大多数 <strong>Solidity 开发者</strong> 来说，学习 <strong>zkSync</strong> 并不是必须的，尤其是如果你的目标是专注于 <strong>以太坊主网</strong> 或其他 <strong>EVM 兼容链</strong>（如 <strong>Polygon</strong>、<strong>Binance Smart Chain</strong>）上的开发。<strong>Solidity</strong> 是 <strong>以太坊</strong> 和 <strong>EVM 兼容区块链</strong> 的核心开发语言，而大多数去中心化应用和智能合约开发者仍然专注于这些平台。</p>
<p>如果你的目标是专注于 <strong>Solidity 开发</strong>，那么你应该将主要精力放在以下几个方面：</p>
<ul>
<li>熟悉 <strong>Solidity</strong> 语言的语法和特性。</li>
<li>了解 <strong>以太坊智能合约</strong> 的生命周期、部署和交互。</li>
<li>学习如何优化合约，减少 <strong>gas 费用</strong>。</li>
<li>熟悉 <strong>Web3.js</strong> 或 <strong>ethers.js</strong> 等库，用于前端与智能合约的交互。</li>
</ul>
<h3 id="在什么情况下需要学习-zkSync？"><a href="#在什么情况下需要学习-zkSync？" class="headerlink" title="在什么情况下需要学习 zkSync？"></a>在什么情况下需要学习 zkSync？</h3><ul>
<li>如果你正在考虑开发 <strong>去中心化金融（DeFi）</strong> 或 <strong>NFT</strong> 应用，且对 <strong>交易吞吐量</strong> 和 <strong>低交易费用</strong> 有较高要求，了解 <strong>zkSync</strong> 会对你有帮助。</li>
<li>如果你希望深入研究 <strong>零知识证明（zkp）</strong> 技术，或者希望参与扩展解决方案的开发，学习 <strong>zkSync</strong> 是非常有价值的。</li>
<li>如果你已经熟悉 <strong>Solidity</strong> 并且希望拓展开发技能到 <strong>以太坊二层扩展</strong>（如 <strong>zkSync</strong> 或 <strong>Optimism</strong>），那么学习 <strong>zkSync</strong> 将为你打开一个新的技术领域。</li>
</ul>
<h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><ul>
<li><strong>学习 zkSync 不是成为 Solidity 开发者的必备技能</strong>，但它可以帮助你在 <strong>DeFi</strong> 和其他需要高效扩展的应用领域中提高竞争力。</li>
<li>如果你希望专注于 <strong>Solidity 开发</strong> 和 <strong>以太坊生态系统</strong>，可以优先集中精力在 <strong>Solidity</strong> 和 <strong>以太坊主网</strong> 的开发上。</li>
<li>如果你有时间和兴趣，学习 <strong>zkSync</strong> 将使你对 <strong>区块链扩展解决方案</strong> 和 <strong>零知识证明</strong> 等技术有更深的理解，为你提供更多的开发机会，尤其是在未来的 <strong>去中心化应用</strong> 开发中。</li>
</ul>
<p>在有限的时间内，<strong>Solidity</strong> 是一个强大的起点，而 <strong>zkSync</strong> 可以作为一个有趣的拓展领域，等你在区块链开发的基础上进一步发展时再深入学习。</p>
<h1 id="第1章：准备工作"><a href="#第1章：准备工作" class="headerlink" title="第1章：准备工作"></a>第1章：准备工作</h1><p>以太坊和zkSync都使用一种名为JSON-RPC的语言，这种语言对人类不可读。幸运的是，它们提供了库来隐藏所有复杂的细节，因此你只需要了解一些JavaScript。</p>
<p>☞ 如果你对JavaScript不熟悉，可以先去其他地方学习一下教程，然后再开始这节课。</p>
<h2 id="初始化你的Node-js项目"><a href="#初始化你的Node-js项目" class="headerlink" title="初始化你的Node.js项目"></a>初始化你的Node.js项目</h2><p>每个Node.js项目必须至少包含一个package.json文件，通常位于项目的根目录。这个文件标识了项目并列出了项目所依赖的包，从而使你的构建具有可重现性。</p>
<p>你可以使用文本编辑器手动创建package.json文件，但最快的方式是运行<code>npm init</code>命令并加上<code>-y</code>标志，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">npm init -y<br></code></pre></div></td></tr></table></figure>

<p>那么，<code>-y</code>标志是什么意思呢？</p>
<p><code>-y</code>标志表示你希望接受npm根据当前目录提取的信息自动建议的所有默认值。</p>
<p>安装依赖<br>我们假设你已经在电脑上安装了npm和node，现在我们要让你安装ethers和zksync。</p>
<p>使用npm安装包的语法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">npm install &lt;package-name&gt;<br></code></pre></div></td></tr></table></figure>

<h2 id="进行测试"><a href="#进行测试" class="headerlink" title="进行测试"></a>进行测试</h2><p>你首先要做的事情是初始化你的新项目并接受所有默认设置。如果你不记得怎么做，查看上面的示例。首先，尝试自己完成，避免查看答案。</p>
<p>现在，让我们使用<code>npm install</code>命令安装ethers和zksync。</p>
<p>注意：指定要安装的包的顺序应该不影响结果，但由于我们的命令行解释器相当基础，除非你先指定ethers，否则它不会认为答案是正确的。</p>
<h1 id="第2章：让我们了解zkSync"><a href="#第2章：让我们了解zkSync" class="headerlink" title="第2章：让我们了解zkSync"></a><strong>第2章：让我们了解zkSync</strong></h1><p>现在你已经初始化了一个新的Node.js项目并安装了所需的依赖项，接下来让我们深入了解zkSync的工作原理。</p>
<p>zkSync使用了一种叫做zk-SNARKs的技术，zk-SNARK代表的是“零知识简洁非交互式知识证明”。</p>
<p>如果这听起来让你一头雾水，你并不孤单。继续阅读，我们将为你解释这意味着什么。</p>
<p><strong>零知识证明</strong></p>
<p>不深入细节的讲解，零知识证明允许Alice（被称为证明者）向Bob（被称为验证者）证明她知道某件事情是正确的，但不透露任何其他信息。</p>
<p>例如，通过zk-SNARK，Bob知道Alice的账户余额超过0.5 ETH，但Bob无法从Alice提供的证明中获取任何其他信息。</p>
<p>掌握了这一知识后，让我们更深入地了解zkSync是如何工作的。</p>
<p>zkSync依赖于一个部署在以太坊网络上的智能合约来保存所有资产，而大部分计算工作都在链下进行。每次你签署交易时，协议会将交易提交给操作员，操作员将多个交易（可能是成千上万的交易）打包成一个区块，并计算以下内容：</p>
<ul>
<li>加密承诺（根哈希）</li>
<li>加密证明（SNARK）</li>
<li>状态变化（∆），代表每笔交易的一小段数据</li>
</ul>
<p>所有这些信息会被发送到运行在以太坊网络上的智能合约。这使得有兴趣的方可以在任何给定时刻重建状态。</p>
<p>SNARK验证比逐一验证每笔交易便宜得多，而将状态存储在链下也比将其存储在EVM中便宜得多。</p>
<p>这大大提高了可扩展性并节省了交易成本。</p>
<p>☞ 本课的范围不包括深入探讨zk-SNARK是如何工作的。如果你完成了这篇课程，可以去阅读《Why and How zk-SNARK Works》系列文章，进一步了解。</p>
<p><strong>创建提供者</strong></p>
<p>在你与zkSync进行交互之前，你需要创建一个叫做提供者（provider）的东西。提供者像一个桥梁，使得JavaScript函数调用能够与zkSync兼容。其优点是，你不需要理解它是如何在底层运作的就可以使用它。</p>
<p><strong>实践</strong></p>
<p>在本课中，你将创建两个Node.JS应用程序——<code>alice.js</code>和<code>bob.js</code>，大部分逻辑将由这两个应用共享。你如何确保不会重复编写相同的代码呢？为避免这种情况，你应该创建一个单独的文件来存放所有这些通用逻辑。我们已经为你创建了一个名为<code>utils.js</code>的JavaScript文件框架。接下来，让我们填充它。</p>
<p>在右侧标签中，创建一个异步函数，命名为<code>getZkSyncProvider</code>。它接收两个参数：</p>
<ul>
<li><code>zksync</code>：指向zkSync JavaScript模块的对象。</li>
<li><code>networkName</code>：指定应用程序连接的网络名称的字符串。</li>
</ul>
<p>现在不用担心这些变量，我们稍后会讲解它们。</p>
<p>函数的第一行应该使用<code>let</code>关键字声明一个名为<code>zkSyncProvider</code>的变量。</p>
<p>接下来，你的函数应该创建一个新的提供者。但是，创建新提供者的代码可能会失败并抛出错误。为了防止应用程序崩溃并打印堆栈跟踪，你必须将所有内容包装在<code>try/catch</code>语句中，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-comment">// 初始化提供者</span><br>&#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>  <span class="hljs-comment">// 显示错误消息</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>在<code>try</code>块中，你的函数应该通过<code>await zksync.getDefaultProvider</code>来设置<code>zkSyncProvider</code>。这个函数接受一个参数——<code>networkName</code>。</p>
<p>在<code>catch</code>块中，粘贴以下两行代码：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Unable to connect to zkSync.&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error)<br></code></pre></div></td></tr></table></figure>

<p>记住，这些代码只会在<code>try</code>块中抛出异常时执行！</p>
<p>现在，让我们写下函数的最后一行。在<code>try/catch</code>块之外，只需返回<code>zkSyncProvider</code>。</p>
<h1 id="什么是zkSync"><a href="#什么是zkSync" class="headerlink" title="什么是zkSync?"></a>什么是zkSync?</h1><p>zkSync 是一个为 Ethereum（以太坊） 设计的“Layer‑2 扩容解决方案”（Layer‑2 scaling solution）。它的目的是让以太坊网络更快、更便宜、更高效，同时保持安全性与去中心化。(<a target="_blank" rel="noopener" href="https://www.cryptopolitan.com/zh-cn/30-questions-and-answers-about-zksync/?utm_source=chatgpt.com" title="关于 Ethereum Layer-2 解决方案 ZkSync 的 30 个问答 ...">cryptopolitan.com</a>)</p>
<h2 id="✅-zkSync-的关键特性"><a href="#✅-zkSync-的关键特性" class="headerlink" title="✅ zkSync 的关键特性"></a>✅ zkSync 的关键特性</h2><ul>
<li><strong>采用 “零知识汇总”（zk‑rollups &#x2F; ZK‑Rollup）技术</strong>：<br>zkSync 会把很多笔交易打包（roll up）在链下处理，然后生成一个加密“有效性证明”（zero‑knowledge proof, ZKP），最后只将这个证明提交到以太坊主链（Layer 1）。因此，以太坊主网不需要逐笔验证所有交易，只需验证这个证明即可。(<a target="_blank" rel="noopener" href="https://dappradar.com/blog/what-is-zksync?utm_source=chatgpt.com" title="What is zkSync: A Deep Dive into Ethereum’s zk-rollup Scaling Innovation">DappRadar</a>)</li>
<li><strong>更高吞吐量 + 更低交易费</strong>：<br>因为链下批量处理交易，并只提交小量数据到主网，zkSync 可以显著提高交易速度／吞吐量（相比直接在主网交易） — 同时大幅降低 Gas 费或手续费。(<a target="_blank" rel="noopener" href="https://www.binance.com/zh-CN/academy/articles/what-is-zksync-and-how-does-it-work?utm_source=chatgpt.com" title="ZKsync 的概念及其运作方式介绍 | Binance Academy">Binance</a>)</li>
<li><strong>继承以太坊的安全性和去中心化</strong>：<br>虽然交易在链下处理，但最终状态的“确认”（finality）仍锚定在以太坊主链上，也就是说你依然享有以太坊层面的安全保障。(<a target="_blank" rel="noopener" href="https://www.nansen.ai/post/what-is-zksync?utm_source=chatgpt.com" title="What is zkSync? A Complete Guide to Ethereum’s Layer-2 Scaling Solution">nansen.ai</a>)</li>
<li><strong>对 Ethereum 智能合约 &#x2F; dApp 的兼容性</strong>：<br>zkSync 通常与以太坊虚拟机（EVM）兼容，使得现有为以太坊开发的去中心化应用（dApp）可以较容易地迁移或同时支持 zkSync。(<a target="_blank" rel="noopener" href="https://www.binance.com/zh-CN/academy/articles/what-is-zksync-and-how-does-it-work?utm_source=chatgpt.com" title="ZKsync 的概念及其运作方式介绍 | Binance Academy">Binance</a>)</li>
</ul>
<h2 id="🧠-为什么存在-zkSync？它解决了什么问题"><a href="#🧠-为什么存在-zkSync？它解决了什么问题" class="headerlink" title="🧠 为什么存在 zkSync？它解决了什么问题"></a>🧠 为什么存在 zkSync？它解决了什么问题</h2><p>以太坊主网（Layer 1）虽然安全、去中心化，但在网络拥堵的时候交易费（Gas）很高、交易确认慢、吞吐量有限。对于想要大量、小额、快速交易的应用场景（如支付、DeFi、小额转账、NFT、游戏等），成本与速度成为瓶颈。</p>
<p>zkSync 通过 “链下批量 + 零知识证明 + 链上最终确认” 的方式，<strong>解决了可扩展性和高费用的问题</strong>，让以太坊更适合大规模、日常的使用。</p>
<p>因此，zkSync 被很多项目和用户视为推动以太坊「主流化」—— 让区块链不仅仅适合大额交易、投机或存储资产，也适合高频、轻量、普通用途 —— 的关键基础设施。(<a target="_blank" rel="noopener" href="https://www.cryptopolitan.com/zh-cn/30-questions-and-answers-about-zksync/?utm_source=chatgpt.com" title="关于 Ethereum Layer-2 解决方案 ZkSync 的 30 个问答 ...">cryptopolitan.com</a>)</p>
<h2 id="🌐-zkSync-当前状态-生态"><a href="#🌐-zkSync-当前状态-生态" class="headerlink" title="🌐 zkSync 当前状态 &amp; 生态"></a>🌐 zkSync 当前状态 &amp; 生态</h2><ul>
<li>zkSync 的主网解决方案版本中，有一个子项目&#x2F;网络叫 zkSync Era —— 它是 zkSync 的主要网络之一。(<a target="_blank" rel="noopener" href="https://blog.gtokentool.com/post/3520.html?utm_source=chatgpt.com" title="什么是 zkSync 时代？_加密百科_GTokenTool博客">blog.gtokentool.com</a>)</li>
<li>截至 2025 年，zkSync 的生态系统非常活跃，已经成为以太坊 Layer‑2 中资金规模较大、采用较多的方案之一。(<a target="_blank" rel="noopener" href="https://www.jb51.net/blockchain/1006024.html?utm_source=chatgpt.com" title="什么是 ZKsync ？2025年ZKsync生态系统中值得关注的10 ...">jb51.net</a>)</li>
<li>它不仅用于简单的代币交易，也被用于 DeFi（去中心化金融）、资产代币化、跨链桥接、以及其他智能合约／dApp 场景 — 成为一个完整的扩展生态。(<a target="_blank" rel="noopener" href="https://www.jb51.net/blockchain/1006024.html?utm_source=chatgpt.com" title="什么是 ZKsync ？2025年ZKsync生态系统中值得关注的10 ...">jb51.net</a>)</li>
</ul>
<h2 id="🆚-zkSync-与其他扩容方案的比较"><a href="#🆚-zkSync-与其他扩容方案的比较" class="headerlink" title="🆚 zkSync 与其他扩容方案的比较"></a>🆚 zkSync 与其他扩容方案的比较</h2><p>与一些使用其他技术的 Layer‑2 方案相比（例如“乐观汇总 &#x2F; Optimistic Rollups”），zkSync 的优势在于：</p>
<ul>
<li>交易确认速度更快 — 因为验证通过加密证明即时完成，无需等待质疑期（optimistic rollup 通常有延迟窗口以防欺诈）(<a target="_blank" rel="noopener" href="https://www.binance.com/zh-CN/academy/articles/what-is-zksync-and-how-does-it-work?utm_source=chatgpt.com" title="ZKsync 的概念及其运作方式介绍 | Binance Academy">Binance</a>)</li>
<li>安全性更高 — 零知识证明方式本质上比“假设有效 + 后验质疑”的方式更确定、安全。(<a target="_blank" rel="noopener" href="https://www.binance.com/zh-CN/academy/articles/what-is-zksync-and-how-does-it-work?utm_source=chatgpt.com" title="ZKsync 的概念及其运作方式介绍 | Binance Academy">Binance</a>)</li>
<li>对开发者更友好 — EVM 兼容让以太坊上的智能合约容易迁移／兼容。(<a target="_blank" rel="noopener" href="https://www.binance.com/zh-CN/academy/articles/what-is-zksync-and-how-does-it-work?utm_source=chatgpt.com" title="ZKsync 的概念及其运作方式介绍 | Binance Academy">Binance</a>)</li>
</ul>
<p>不过，不同方案都有自己的权衡：例如某些其他方案可能在灵活性或跨链互操作性方面有优势 — 选择哪一种方案，取决于应用场景与需求。</p>
<p>如果你愿意，我可以 <strong>画图</strong> 给你看 zkSync 与以太坊主链、以太坊传统交易、Optimistic Rollup 等方案之间 <strong>结构与流程差异</strong> —— 这样更直观，也更便于理解。你要这样吗？</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Web3/">Web3</a>
                    
                  </div>
                
              </div>
              
                
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/12/02/19536.html">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">javascript</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/11/27/30384.html">
                        <span class="hidden-mobile">cryptozombies11-TronBox</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


            

                
                  <a id="scroll-top-button" href="#" role="button">
                    <i class="iconfont icon-arrowup" aria-hidden="true"></i>
                  </a>
                  

                    

                          
      </main>

      <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://whale3070.github.io/" target="_blank" rel="nofollow noopener"><span>Whale3070</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->




  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>





  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<link href="/pagefind/pagefind-ui.css" rel="stylesheet">
  <script src="/pagefind/pagefind-ui.js"></script>
  <style>
    /* 搜索框配色适配 */
    #search { margin-top: 2rem; }
    [data-user-color-scheme='dark'] .pagefind-ui {
      --pagefind-ui-primary: #eeeeee;
      --pagefind-ui-text: #eeeeee;
      --pagefind-ui-background: #151515;
      --pagefind-ui-border: #333;
    }
  </style>
    </body>

  </html>