

  <!DOCTYPE html>
  <html lang="zh-CN" data-default-color-scheme=&#34;dark&#34; >
  <style>
    .text1
    {
    text-shadow: 0px 0px 2px #f2f3f2;
    }
    </style>

  

<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/null">
  <link rel="icon" type="image/png" href="/null">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>cryptozombies8 - whale3070&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"192.168.126.129","root":"/","version":"1.8.7","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 7.3.0"></head>


    <body>
      <header style="height: 70vh;">
        <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>InfoSec learning</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/search/">
                <i class="iconfont icon-search"></i>
                搜索
              </a>
            </li>
          
        
        
        
          
        
      </ul>
    </div>
  </div>
</nav>

          <div class="banner" id="banner" false
            style="background: url('/img/default.png') no-repeat center center;
              background-size: cover;">
              <div class="full-bg-img">
                <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
                  <div class="page-header text-center fade-in-up">
                    <span class="h2 text1" id="subtitle" title="cryptozombies8">
                      
                        cryptozombies8
                      
                    </span>
        
                    
                      <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2025-11-27 14:48" pubdate>
        2025年11月27日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      13.7k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      152
       分钟
    </span>
  

  
  
</div>

                    
                  </div>
                    
                  </div>
                  
                </div>
              </div>
          </div>
      </header>

      <main>
        
          

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" data-pagefind-body>
            <!-- SEO header -->
            <h1 style="display: none">cryptozombies8</h1>
            
            <div class="markdown-body">
              <h1 id="第六章：部署我们的智能合约"><a href="#第六章：部署我们的智能合约" class="headerlink" title="第六章：部署我们的智能合约"></a>第六章：部署我们的智能合约</h1><p>太好了！最难的部分已经完成 —— 实际上部署到 Rinkeby 网络将会非常简单。为此，Truffle 依赖于一种叫做 <strong>迁移</strong> 的机制。</p>
<h3 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h3><p>虽然“迁移”听起来像是有很多东西在移动，但实际上，迁移只是一个 JavaScript 文件，它告诉 Truffle 如何修改我们智能合约的状态。</p>
<p>显然，第一次迁移只是将智能合约部署到区块链上。其他的迁移则是部署新的代码版本，以添加新功能或修复 bug。</p>
<p>简而言之，迁移为我们提供了一种方便的方式来跟踪我们对代码所做的更改。</p>
<p>如果你要部署多个合约，则每个合约必须创建一个单独的迁移文件。迁移总是按顺序执行的——1、2、3，依此类推。</p>
<p>在本节课中，我们将仅部署到 Rinkeby 网络。部署到主网需要使用真实的资金支付 Gas 费用，而且一旦部署，我们就无法修改代码。因此，最好先在 Rinkeby 网络上部署并彻底测试代码。</p>
<h3 id="获取一些-Ether"><a href="#获取一些-Ether" class="headerlink" title="获取一些 Ether"></a>获取一些 Ether</h3><p>在进行部署之前，确保你的账户中有足够的 Ether。获取用于测试的 Ether 最简单的方式是通过一个叫做 <strong>水龙头（faucet）</strong> 的服务。我们推荐使用运行在 Rinkeby 上的 <strong>Authenticated Faucet</strong>。按照说明操作，几分钟后，你的地址将会被充值一些 Ether。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>现在一切准备就绪，是时候将合约部署到 Rinkeby 网络了。为此，在终端中运行 <code>truffle migrate --network rinkeby</code> 命令。注意，迁移是按顺序执行的😉。</p>
<p><strong>注意</strong>：<code>truffle deploy</code> 只是 <code>truffle migrate</code> 的别名。然而，由于我们的命令行解释器非常基础，除非你使用 <code>migrate</code> 命令，否则它不会认为答案是正确的。</p>
<p>部署到主网并不复杂。一旦智能合约通过了测试，你只需要运行以下命令：<code>truffle migrate --network mainnet</code>。别忘了，你需要为 Gas 费用支付！我们相信你能做好这部分。</p>
<p>如果一切顺利，你将看到类似于右侧的响应。</p>
<h1 id="第7章：在-Loom-上使用-Truffle！"><a href="#第7章：在-Loom-上使用-Truffle！" class="headerlink" title="第7章：在 Loom 上使用 Truffle！"></a><strong>第7章：在 Loom 上使用 Truffle！</strong></h1><p>这看起来可能不算什么，但你刚刚部署了 CryptoZombies 智能合约！</p>
<p>即使 Truffle 帮了很大的忙，这也不是一项小成就，所以为自己点赞吧。</p>
<p><strong>Loom Basechain</strong><br>现在，如果你想在以太坊上构建 DApp，有一点你需要知道——在主网，每个交易都需要用户支付 gas 费用。但这对于面向用户的 DApp 或游戏来说并不理想，容易破坏用户体验。</p>
<p>相比之下，在 Loom 上，用户可以享受更快速且无需 gas 费用的交易，这使得它更加适合游戏和其他非金融应用。</p>
<p>这意味着你的 Loom 僵尸将会是更快的僵尸！</p>
<p>这还不是全部——部署到 Loom 和部署到 Rinkeby 或以太坊主网没有区别。如果你知道如何在一个网络上部署，你也知道如何在其他网络上部署。</p>
<p>在接下来的章节中，我们将带你一步步完成如何部署到 Loom。</p>
<p><strong>loom-truffle-provider</strong><br>我们 Loom 团队使用 Truffle 来构建、测试和部署智能合约。为了让我们的工作更轻松，我们开发了一个叫做 provider 的工具，使 Truffle 可以像部署到 Rinkeby 或以太坊主网一样部署到 Loom。</p>
<p>简单来说，provider 就像一座桥梁，使 Web3 调用可以兼容 Loom。它的优点是，你使用它时不需要理解它是如何在后台工作的。</p>
<p><strong>实践测试</strong><br>我们将 loom-truffle-provider 作为 npm 包提供。让我们来安装它。</p>
<p><strong>注意</strong>：这次不需要将这个包设置为全局可用。</p>
<h1 id="第8章：部署到-Loom-测试网"><a href="#第8章：部署到-Loom-测试网" class="headerlink" title="第8章：部署到 Loom 测试网"></a><strong>第8章：部署到 Loom 测试网</strong></h1><p>在本章中，我们将把智能合约部署到 Loom 测试网，但在进行部署之前，需要做一些准备工作。</p>
<p>首先，我们需要创建自己的 Loom 私钥。最简单的方法是按照这个教程下载并安装 Loom。</p>
<p>接下来，创建私钥非常简单：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$./loom genkey -a public_key -k private_key<br><span class="hljs-built_in">local</span> address: 0x42F401139048AB106c9e25DCae0Cf4b1Df985c39<br><span class="hljs-built_in">local</span> address <span class="hljs-built_in">base64</span>: QvQBE5BIqxBsniXcrgz0sd+YXDk=<br><span class="hljs-variable">$cat</span> private_key<br>/i0Qi8e/E+kVEIJLRPV5HJgn0sQBVi88EQw/Mq4ePFD1JGV1Nm14dA446BsPe3ajte3t/tpj7HaHDL84+Ce4Dg==<br></code></pre></div></td></tr></table></figure>

<p><strong>注意</strong>：切勿泄露你的私钥！我们这样做只是为了简化操作。</p>
<h2 id="更新-truffle-js"><a href="#更新-truffle-js" class="headerlink" title="更新 truffle.js"></a><strong>更新 truffle.js</strong></h2><p>我们首先需要做的事情是初始化 <code>loom-truffle-provider</code>。它的语法与我们之前用于 <code>HDWalletProvider</code> 的语法类似：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">LoomTruffleProvider</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;loom-truffle-provider&#x27;</span>);<br></code></pre></div></td></tr></table></figure>

<p>接下来，就像我们在第5章中做的那样，我们需要让 Truffle 知道如何在 Loom 测试网上进行部署。为此，让我们在 <code>truffle.js</code> 中添加一个新的对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-attr">loom_testnet</span>: &#123;<br>  <span class="hljs-attr">provider</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> privateKey = <span class="hljs-string">&#x27;YOUR_PRIVATE_KEY&#x27;</span>;<br>    <span class="hljs-keyword">const</span> chainId = <span class="hljs-string">&#x27;extdev-plasma-us1&#x27;</span>;<br>    <span class="hljs-keyword">const</span> writeUrl = <span class="hljs-string">&#x27;http://extdev-plasma-us1.dappchains.com:80/rpc&#x27;</span>;<br>    <span class="hljs-keyword">const</span> readUrl = <span class="hljs-string">&#x27;http://extdev-plasma-us1.dappchains.com:80/query&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoomTruffleProvider</span>(chainId, writeUrl, readUrl, privateKey);<br>  &#125;,<br>  <span class="hljs-attr">network_id</span>: <span class="hljs-string">&#x27;9545242630824&#x27;</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="实践测试"><a href="#实践测试" class="headerlink" title="实践测试"></a><strong>实践测试</strong></h2><ol>
<li>添加初始化 <code>LoomTruffleProvider</code> 的代码行。</li>
<li>将 <code>loom_testnet</code> 配置放在文件的底部。</li>
</ol>
<h1 id="第9章：继续部署到-Loom"><a href="#第9章：继续部署到-Loom" class="headerlink" title="第9章：继续部署到 Loom"></a>第9章：继续部署到 Loom</h1><p>现在我们已经准备好，只需一个命令就能将合约部署到 Loom Testnet。</p>
<h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p>运行 <code>truffle migrate --network loom_testnet</code> 并检查输出。</p>
<p>是的，你让这一切看起来如此简单！💪🏻</p>
<h1 id="第10章：部署到-Basechain"><a href="#第10章：部署到-Basechain" class="headerlink" title="第10章：部署到 Basechain"></a>第10章：部署到 Basechain</h1><p>恭喜你！你已经成功部署到 Loom Testnet。但你能猜到接下来会发生什么吗？🤔</p>
<p>没错！本章将带你完成将合约部署到 <strong>Basechain</strong>（也就是我们的主网）的过程。</p>
<p>以下是本章你将做的简要步骤：</p>
<ul>
<li><p><strong>创建一个新的私钥</strong></p>
</li>
<li><p>创建一个新的私钥非常简单。但因为我们现在是在部署到主网，所以需要更加重视安全性。因此，我们将向你展示如何安全地将私钥传递给 Truffle。</p>
</li>
<li><p><strong>通过向 <code>truffle.js</code> 配置文件添加新对象来告诉 Truffle 如何部署到 Basechain</strong><br> 你需要告诉 Truffle 如何将智能合约部署到 Basechain。</p>
</li>
<li><p><strong>将部署密钥加入白名单，以便可以部署到 Basechain</strong><br> 通过将部署密钥添加到白名单中，你将能够在 Basechain 上进行部署。</p>
</li>
<li><p><strong>最后，实际部署智能合约</strong><br> 我们将完成所有步骤，最终将智能合约部署到 Basechain。</p>
</li>
</ul>
<h3 id="创建一个新的私钥"><a href="#创建一个新的私钥" class="headerlink" title="创建一个新的私钥"></a>创建一个新的私钥</h3><p>你已经知道如何创建私钥了。然而，在这一步中，我们需要改变保存私钥的文件名：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">./loom genkey -a mainnet_public_key -k mainnet_private_key<br><span class="hljs-built_in">local</span> address: 0x07419790A773Cc6a2840f1c092240922B61eC778<br><span class="hljs-built_in">local</span> address <span class="hljs-built_in">base64</span>: B0GXkKdzzGooQPHAkiQJIrYex3g=<br></code></pre></div></td></tr></table></figure>

<h3 id="安全地将私钥传递给-Truffle"><a href="#安全地将私钥传递给-Truffle" class="headerlink" title="安全地将私钥传递给 Truffle"></a>安全地将私钥传递给 Truffle</h3><p>接下来，我们要做的是防止私钥文件被推送到 GitHub。为此，我们可以创建一个名为 <code>.gitignore</code> 的新文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> .gitignore<br></code></pre></div></td></tr></table></figure>

<p>现在，让我们通过以下命令告诉 GitHub 忽略保存私钥的文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> mainnet_private_key &gt;&gt; .gitignore<br></code></pre></div></td></tr></table></figure>

<p>现在我们已经确保我们的秘密不会被推送到 GitHub，接下来，我们需要编辑 <code>truffle.js</code> 配置文件，并让 Truffle 从这个文件中读取私钥。</p>
<p>首先，让我们导入几个必要的内容：</p>
<figure class="highlight isbl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs isbl"><span class="hljs-variable">const</span> &#123; <span class="hljs-variable">readFileSync</span> &#125; = <span class="hljs-function"><span class="hljs-title">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)</span><br><span class="hljs-variable">const</span> <span class="hljs-variable">path</span> = <span class="hljs-function"><span class="hljs-title">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)</span><br><span class="hljs-variable">const</span> &#123; <span class="hljs-variable">join</span> &#125; = <span class="hljs-function"><span class="hljs-title">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)</span><br></code></pre></div></td></tr></table></figure>

<p>接下来，我们需要定义一个函数，从文件中读取私钥，并初始化一个新的 <code>LoomTruffleProvider</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getLoomProviderWithPrivateKey</span>(<span class="hljs-params">privateKeyPath, chainId, writeUrl, readUrl</span>) &#123;<br>  <span class="hljs-keyword">const</span> privateKey = <span class="hljs-title function_">readFileSync</span>(privateKeyPath, <span class="hljs-string">&#x27;utf-8&#x27;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoomTruffleProvider</span>(chainId, writeUrl, readUrl, privateKey);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>这非常简单，对吧？</p>
<h3 id="告诉-Truffle-如何部署到-Basechain"><a href="#告诉-Truffle-如何部署到-Basechain" class="headerlink" title="告诉 Truffle 如何部署到 Basechain"></a>告诉 Truffle 如何部署到 Basechain</h3><p>现在，我们必须让 Truffle 知道如何部署到 Basechain。为此，我们需要在 <code>truffle.js</code> 中添加一个新的对象。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs actionscript">basechain: &#123;<br>  provider: <span class="hljs-keyword">function</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">const</span> chainId = <span class="hljs-string">&#x27;default&#x27;</span>;<br>    <span class="hljs-keyword">const</span> writeUrl = <span class="hljs-string">&#x27;http://basechain.dappchains.com/rpc&#x27;</span>;<br>    <span class="hljs-keyword">const</span> readUrl = <span class="hljs-string">&#x27;http://basechain.dappchains.com/query&#x27;</span>;<br>    <span class="hljs-keyword">const</span> privateKeyPath = path.join(__dirname, <span class="hljs-string">&#x27;mainnet_private_key&#x27;</span>);<br>    <span class="hljs-keyword">const</span> loomTruffleProvider = getLoomProviderWithPrivateKey(privateKeyPath, chainId, writeUrl, readUrl);<br>    <span class="hljs-keyword">return</span> loomTruffleProvider;<br>    &#125;,<br>  network_id: <span class="hljs-string">&#x27;*&#x27;</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>此时，你的 <code>truffle.js</code> 文件应该类似于以下内容：</p>
<figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-comment">// Initialize HDWalletProvider</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">HDWalletProvider</span> = <span class="hljs-keyword">require</span>(<span class="hljs-string">&quot;truffle-hdwallet-provider&quot;</span>);<br><br><span class="hljs-keyword">const</span> &#123; readFileSync &#125; = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">path</span> = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><span class="hljs-keyword">const</span> &#123; join &#125; = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><br><br><span class="hljs-comment">// Set your own mnemonic here</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">mnemonic</span> = <span class="hljs-string">&quot;YOUR_MNEMONIC&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getLoomProviderWithPrivateKey</span> (<span class="hljs-params">privateKeyPath, chainId, writeUrl, readUrl</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">privateKey</span> = <span class="hljs-title function_ invoke__">readFileSync</span>(privateKeyPath, <span class="hljs-string">&#x27;utf-8&#x27;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoomTruffleProvider</span>(chainId, writeUrl, readUrl, privateKey);<br>&#125;<br><br><span class="hljs-comment">// Module exports to make this configuration available to Truffle itself</span><br>module.exports = &#123;<br>  <span class="hljs-comment">// Object with configuration for each network</span><br>  networks: &#123;<br>    <span class="hljs-comment">// Configuration for mainnet</span><br>    mainnet: &#123;<br>      provider: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-comment">// Setting the provider with the Infura Rinkeby address and Token</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HDWalletProvider</span>(mnemonic, <span class="hljs-string">&quot;https://mainnet.infura.io/v3/YOUR_TOKEN&quot;</span>)<br>      &#125;,<br>      network_id: <span class="hljs-string">&quot;1&quot;</span><br>    &#125;,<br>    <span class="hljs-comment">// Configuration for rinkeby network</span><br>    rinkeby: &#123;<br>      <span class="hljs-comment">// Special function to setup the provider</span><br>      provider: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-comment">// Setting the provider with the Infura Rinkeby address and Token</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HDWalletProvider</span>(mnemonic, <span class="hljs-string">&quot;https://rinkeby.infura.io/v3/YOUR_TOKEN&quot;</span>)<br>      &#125;,<br>      <span class="hljs-comment">// Network id is 4 for Rinkeby</span><br>      network_id: <span class="hljs-number">4</span><br>    &#125;,<br><br>    basechain: &#123;<br>      provider: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">chainId</span> = <span class="hljs-string">&#x27;default&#x27;</span>;<br>        <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">writeUrl</span> = <span class="hljs-string">&#x27;http://basechain.dappchains.com/rpc&#x27;</span>;<br>        <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">readUrl</span> = <span class="hljs-string">&#x27;http://basechain.dappchains.com/query&#x27;</span>;<br>        <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">privateKeyPath</span> = path.<span class="hljs-title function_ invoke__">join</span>(__dirname, <span class="hljs-string">&#x27;mainnet_private_key&#x27;</span>);<br>        <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">loomTruffleProvider</span> = <span class="hljs-title function_ invoke__">getLoomProviderWithPrivateKey</span>(privateKeyPath, chainId, writeUrl, readUrl);<br>        <span class="hljs-keyword">return</span> loomTruffleProvider;<br>        &#125;,<br>      network_id: <span class="hljs-string">&#x27;*&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>

<h3 id="将你的部署密钥加入白名单"><a href="#将你的部署密钥加入白名单" class="headerlink" title="将你的部署密钥加入白名单"></a>将你的部署密钥加入白名单</h3><p>在部署到 Basechain 之前，你需要通过遵循我们的 <strong>部署到主网</strong> 指南来将你的密钥加入白名单。现在不用担心这些，但请记住，在完成本教程后，你必须执行这些步骤。</p>
<p>我们已经完成了所有这些步骤，现在我们准备好部署到 Basechain 了！</p>
<h3 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h3><p>运行 <code>truffle migrate --network basechain</code>。</p>
<p>太棒了，你刚刚将智能合约部署到了 Basechain！</p>
<p>做得好！👏🏻👏🏻👏🏻</p>
<p>你已经掌握了使用 Truffle 部署智能合约的技巧！</p>
<p>记住，基于 Loom 开发可以带来更快、更便宜（无 Gas 费用）的交易，这使得它成为创建区块链游戏和面向用户的 DApp 的完美选择。同时，你的用户也将享受 Ethereum 所提供的保证安全性！</p>
<p>另一个需要记住的点是，部署到 Loom 与部署到 Ethereum 主网非常相似。现在，你知道如何进行这两者的部署了，只需要小心选择下一个项目使用哪个平台😉。</p>
<p>不过，这只是一个示例 —— 我们做出了一些简化的决策，以便让本课更加易于理解。</p>
<p>为了进一步扩展你的知识，前往开发者文档页面。</p>
<p>祝你编码愉快！</p>
<h1 id="第1章：开始设置"><a href="#第1章：开始设置" class="headerlink" title="第1章：开始设置"></a>第1章：开始设置</h1><p>在本课中，我们将介绍以太坊智能合约测试的理论，重点讨论 Truffle、Mocha 和 Chai。为了充分理解这些内容，你需要具备中级水平的 Solidity 和 JavaScript 知识。</p>
<p>如果你之前没有接触过 Solidity，或者你想复习一些概念，可以先从我们的第一课开始学习。</p>
<p>如果你不太熟悉 JavaScript，建议先去学习其他地方的教程，再来学习本课。</p>
<h3 id="让我们看看我们的项目"><a href="#让我们看看我们的项目" class="headerlink" title="让我们看看我们的项目"></a>让我们看看我们的项目</h3><p>如果你按照之前的课程操作，你应该已经构建了一个以僵尸为主题的游戏，基本上已经完成了，且你的文件结构应该像这样：</p>
<figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">├── build<br>  ├── contracts<br>      ├── Migrations<span class="hljs-selector-class">.json</span><br>      ├── CryptoZombies<span class="hljs-selector-class">.json</span><br>      ├── erc721<span class="hljs-selector-class">.json</span><br>      ├── ownable<span class="hljs-selector-class">.json</span><br>      ├── safemath<span class="hljs-selector-class">.json</span><br>      ├── zombieattack<span class="hljs-selector-class">.json</span><br>      ├── zombiefactory<span class="hljs-selector-class">.json</span><br>      ├── zombiefeeding<span class="hljs-selector-class">.json</span><br>      ├── zombiehelper<span class="hljs-selector-class">.json</span><br>      ├── zombieownership<span class="hljs-selector-class">.json</span><br>├── contracts<br>  ├── Migrations<span class="hljs-selector-class">.sol</span><br>  ├── CryptoZombies<span class="hljs-selector-class">.sol</span><br>  ├── erc721<span class="hljs-selector-class">.sol</span><br>  ├── ownable<span class="hljs-selector-class">.sol</span><br>  ├── safemath<span class="hljs-selector-class">.sol</span><br>  ├── zombieattack<span class="hljs-selector-class">.sol</span><br>  ├── zombiefactory<span class="hljs-selector-class">.sol</span><br>  ├── zombiefeeding<span class="hljs-selector-class">.sol</span><br>  ├── zombiehelper<span class="hljs-selector-class">.sol</span><br>  ├── zombieownership<span class="hljs-selector-class">.sol</span><br>├── migrations<br>└── test<br>. package-lock<span class="hljs-selector-class">.json</span><br>. truffle-config<span class="hljs-selector-class">.js</span><br>. truffle.js<br></code></pre></div></td></tr></table></figure>

<p>看到 <code>test</code> 文件夹了吗？这就是我们将放置测试文件的地方。</p>
<p>Truffle 支持用 JavaScript 和 Solidity 编写的测试，但为了简化这节课的内容，我们将只使用 JavaScript 来编写测试。</p>
<h3 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h3><p>最佳实践是为每个合约创建一个单独的测试文件，并将其命名为智能合约的名称。这样可以在长期管理测试时更加简便，尤其是当你的项目不断增长和变化时。</p>
<p>在右侧的终端中运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> <span class="hljs-built_in">test</span>/CryptoZombies.js<br></code></pre></div></td></tr></table></figure>

<h1 id="第2章：开始设置（续）"><a href="#第2章：开始设置（续）" class="headerlink" title="第2章：开始设置（续）"></a>第2章：开始设置（续）</h1><p>继续前进。在本章中，我们将继续设置环境，以便我们可以编写和运行我们的测试。</p>
<h3 id="构建产物"><a href="#构建产物" class="headerlink" title="构建产物"></a>构建产物</h3><p>每次你编译一个智能合约时，Solidity 编译器会生成一个 JSON 文件（称为构建产物），该文件包含合约的二进制表示，并将其保存在 <code>build/contracts</code> 文件夹中。</p>
<p>接下来，当你运行迁移时，Truffle 会更新这个文件，包含与该网络相关的信息。</p>
<p>每次开始编写一个新的测试套件时，你需要做的第一件事是加载你想要与之交互的合约的构建产物。这样，Truffle 就会知道如何以合约能够理解的方式格式化我们的函数调用。</p>
<p>让我们看一个简单的例子。</p>
<p>假设有一个叫做 <code>MyAwesomeContract</code> 的合约。我们可以像下面这样加载构建产物：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyAwesomeContract</span> = artifacts.<span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;MyAwesomeContract&quot;</span>);<br></code></pre></div></td></tr></table></figure>

<p>这个函数返回一个叫做 <strong>合约抽象</strong>（contract abstraction）的东西。简而言之，合约抽象隐藏了与 Ethereum 交互的复杂性，并提供了一个便捷的 JavaScript 接口来与我们的 Solidity 智能合约进行交互。我们将在接下来的章节中使用它。</p>
<h3 id="contract-函数"><a href="#contract-函数" class="headerlink" title="contract() 函数"></a><code>contract()</code> 函数</h3><p>在幕后，Truffle 在 Mocha 上添加了一个简单的封装，以简化测试。由于我们课程的重点是以太坊开发，我们不会花太多时间解释 Mocha 的细节。如果你有兴趣了解更多关于 Mocha 的内容，可以在完成本课后访问他们的网站。目前，你只需要理解我们在这里讲解的内容——如何：</p>
<ul>
<li><strong>通过调用名为 <code>contract()</code> 的函数来分组测试</strong>。它扩展了 Mocha 的 <code>describe()</code>，提供了用于测试的账户列表，并进行一些清理工作。</li>
</ul>
<p><code>contract()</code> 接受两个参数。第一个参数是一个字符串，必须说明我们要测试的内容。第二个参数是一个回调函数，我们将在其中实际编写测试。</p>
<ul>
<li><strong>执行它们</strong>：我们将通过调用一个名为 <code>it()</code> 的函数来执行测试，<code>it()</code> 也接受两个参数：一个字符串，描述测试实际做的事情，以及一个回调函数。</li>
</ul>
<p>把它们放在一起，下面是一个简单的测试：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title function_">contract</span>(<span class="hljs-string">&quot;MyAwesomeContract&quot;</span>, <span class="hljs-function">(<span class="hljs-params">accounts</span>) =&gt;</span> &#123;<br>  <span class="hljs-title function_">it</span>(<span class="hljs-string">&quot;should be able to receive Ethers&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 测试代码</span><br>  &#125;);<br>&#125;);<br></code></pre></div></td></tr></table></figure>

<p><strong>注意</strong>：一个设计良好的测试应当清楚地说明代码实际做了什么。确保测试套件和测试用例的描述能够连贯地结合在一起，像是在写文档一样。</p>
<p>你将编写的每个测试都遵循这个简单的模式。很容易理解吧？😁</p>
<h3 id="测试一下-1"><a href="#测试一下-1" class="headerlink" title="测试一下"></a>测试一下</h3><p>现在我们已经创建了一个空的 <code>CryptoZombies.js</code> 文件，让我们来填写它。</p>
<ol>
<li><p>第一行代码应该声明一个名为 <code>CryptoZombies</code> 的常量，并将其设置为 <code>artifacts.require</code> 函数的结果，参数是我们要测试的合约的名称。</p>
</li>
<li><p>接下来，复制并粘贴上面的测试代码。</p>
</li>
<li><p>更改 <code>contract()</code> 调用方式，使第一个参数是我们智能合约的名称。</p>
</li>
</ol>
<p><strong>注意</strong>：不要担心 <code>accounts</code> 参数。我们将在下一章解释它。</p>
<ol start="4">
<li>传递给 <code>it()</code> 函数的第一个参数（在我们的例子中是 “should be able to receive Ethers”）应该是我们的测试名称。由于我们将从创建一个新僵尸开始，确保第一个参数设置为 “should be able to create a new zombie”。</li>
</ol>
<p>我们都准备好了。让我们继续进入下一章。</p>
<h1 id="第3章：第一个测试-创建新僵尸"><a href="#第3章：第一个测试-创建新僵尸" class="headerlink" title="第3章：第一个测试 - 创建新僵尸"></a>第3章：第一个测试 - 创建新僵尸</h1><p>在部署到 Ethereum 之前，最好先在本地测试你的智能合约。</p>
<p>你可以使用一个叫做 <strong>Ganache</strong> 的工具，它可以设置一个本地的 Ethereum 网络。</p>
<p>每次启动 Ganache 时，它会创建 10 个测试账户，并给予它们 100 个 Ether，以便简化测试。由于 Ganache 和 Truffle 紧密集成，我们可以通过之前章节提到的 <code>accounts</code> 数组访问这些账户。</p>
<p>但如果我们直接使用 <code>accounts[0]</code> 和 <code>accounts[1]</code>，测试代码就不太易读，对吧？</p>
<p>为了提高可读性，我们将使用两个占位符名字——<strong>Alice</strong> 和 <strong>Bob</strong>。所以，在 <code>contract()</code> 函数中，我们可以这样初始化它们：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> [alice, bob] = accounts;<br></code></pre></div></td></tr></table></figure>

<p><strong>注意</strong>：请原谅这个简单的语法。通常在 JavaScript 中，变量名使用小写字母。</p>
<h3 id="为什么是-Alice-和-Bob？"><a href="#为什么是-Alice-和-Bob？" class="headerlink" title="为什么是 Alice 和 Bob？"></a>为什么是 Alice 和 Bob？</h3><p>Alice 和 Bob 或者 “A 和 B” 在密码学、物理学、编程等领域有着悠久的传统，是常用的名字。这背后有一段简短但有趣的历史，值得你在完成本课后去阅读。</p>
<p>现在，让我们继续进行第一个测试。</p>
<h3 id="创建新僵尸"><a href="#创建新僵尸" class="headerlink" title="创建新僵尸"></a>创建新僵尸</h3><p>假设 Alice 想要玩我们的精彩游戏。如果是这样，她首先想要做的就是创建她自己的僵尸 🧟。为此，前端（或者在我们的例子中是 Truffle）需要调用 <code>createRandomZombie</code> 函数。</p>
<p><strong>注意</strong>：作为复习，以下是我们合约中的 Solidity 代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs solidity">function createRandomZombie(string _name) public &#123;<br>  require(ownerZombieCount[msg.sender] == 0);<br>  uint randDna = _generateRandomDna(_name);<br>  randDna = randDna - randDna % 100;<br>  _createZombie(_name, randDna);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>我们将从测试这个函数开始。</p>
<h3 id="测试一下-2"><a href="#测试一下-2" class="headerlink" title="测试一下"></a>测试一下</h3><p><code>contract()</code> 函数的第一行应该声明两个变量，分别命名为 <code>alice</code> 和 <code>bob</code>，并按照上面的方式初始化它们。</p>
<p>接下来，我们需要正确地调用 <code>it()</code> 函数。第二个参数（回调函数）将与区块链进行交互，这意味着该函数是异步的。只需要在函数前面加上 <code>async</code> 关键字。这样，每次调用该函数时，使用 <code>await</code> 关键字，测试将会等待函数返回结果。</p>
<p>解释 Promise 如何工作超出了本课的范围。完成本课后，你可以查阅官方文档，进一步扩展你的知识。</p>
<h1 id="第4章：第一个测试-创建新僵尸（续）"><a href="#第4章：第一个测试-创建新僵尸（续）" class="headerlink" title="第4章：第一个测试 - 创建新僵尸（续）"></a>第4章：第一个测试 - 创建新僵尸（续）</h1><p>做得好！现在我们已经为第一个测试创建了一个框架，让我带你了解一下测试是如何工作的。</p>
<p>通常，每个测试都有以下几个阶段：</p>
<ol>
<li><strong>设置（set up）</strong>：在这个阶段，我们定义初始状态并初始化输入。</li>
<li><strong>执行（act）</strong>：在这个阶段，我们实际测试代码。始终确保每次只测试一件事情。</li>
<li><strong>断言（assert）</strong>：在这个阶段，我们检查结果。</li>
</ol>
<p>让我们更详细地看看我们的测试应该做些什么。</p>
<h3 id="1-设置"><a href="#1-设置" class="headerlink" title="1. 设置"></a>1. 设置</h3><p>在第二章中，你学会了如何创建合约抽象。然而，正如它的名字所示，合约抽象只是一个抽象。为了真正与智能合约交互，我们必须创建一个 JavaScript 对象，它将作为合约的实例。继续以 MyAwesomeContract 为例，我们可以使用合约抽象来初始化我们的实例，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> contractInstance = <span class="hljs-keyword">await</span> <span class="hljs-title class_">MyAwesomeContract</span>.<span class="hljs-title function_">new</span>();<br></code></pre></div></td></tr></table></figure>

<p>很好，那么接下来是什么呢？</p>
<p>调用 <code>createRandomZombie</code> 需要我们传入僵尸的名字作为参数。所以，接下来的步骤是为 Alice 的僵尸命名。我们可以给她的僵尸取个名字，比如“Alice 的超酷僵尸”。</p>
<p>然而，如果我们对每个测试都这样做，代码可能会显得不太优雅。更好的方法是初始化一个全局数组，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> zombieNames = [<span class="hljs-string">&quot;Zombie #1&quot;</span>, <span class="hljs-string">&quot;Zombie #2&quot;</span>];<br></code></pre></div></td></tr></table></figure>

<p>然后，像下面这样调用合约的方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">contractInstance.<span class="hljs-title function_">createRandomZombie</span>(zombieNames[<span class="hljs-number">0</span>]);<br></code></pre></div></td></tr></table></figure>

<p><strong>注意</strong>：使用数组来存储僵尸的名字非常方便，举个例子，如果你想写一个创建 1000 个僵尸的测试，而不是只创建一个或两个，这会非常有用😉。</p>
<h3 id="测试一下-3"><a href="#测试一下-3" class="headerlink" title="测试一下"></a>测试一下</h3><p>我们已经为你初始化了 <code>zombieNames</code> 数组。</p>
<p>现在，让我们创建合约的实例。声明一个新的常量 <code>contractInstance</code>，并将其设置为 <code>CryptoZombies.new()</code> 函数的结果。</p>
<p><code>CryptoZombies.new()</code> 会与区块链进行交互。这意味着它是一个异步函数。让我们在函数调用前加上 <code>await</code> 关键字。</p>
<hr>
<p>解释一下这些js代码：</p>
<figure class="highlight dart"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dart"><span class="hljs-keyword">const</span> CryptoZombies = artifacts.require(<span class="hljs-string">&quot;CryptoZombies&quot;</span>);<br><span class="hljs-keyword">const</span> zombieNames = [<span class="hljs-string">&quot;Zombie 1&quot;</span>, <span class="hljs-string">&quot;Zombie 2&quot;</span>];<br>contract(<span class="hljs-string">&quot;CryptoZombies&quot;</span>, (accounts) =&gt; &#123;<br>    let [alice, bob] = accounts;<br>    it(<span class="hljs-string">&quot;should be able to create a new zombie&quot;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;<br>        <span class="hljs-comment">// start here</span><br>        <span class="hljs-keyword">const</span> contractInstance = <span class="hljs-keyword">await</span> CryptoZombies.<span class="hljs-keyword">new</span>();<br>    &#125;)<br>&#125;)<br></code></pre></div></td></tr></table></figure>

<p>这段 JavaScript 代码是使用 <strong>Truffle</strong> 框架编写的智能合约测试代码，目的是测试 <code>CryptoZombies</code> 合约的功能。下面是每部分代码的解释：</p>
<h3 id="1-const-CryptoZombies-artifacts-require-quot-CryptoZombies-quot"><a href="#1-const-CryptoZombies-artifacts-require-quot-CryptoZombies-quot" class="headerlink" title="1. const CryptoZombies = artifacts.require(&quot;CryptoZombies&quot;);"></a>1. <code>const CryptoZombies = artifacts.require(&quot;CryptoZombies&quot;);</code></h3><p>这行代码导入了 <code>CryptoZombies</code> 智能合约。<code>artifacts.require</code> 是 Truffle 提供的一个方法，用来加载合约的 ABI 和字节码，并准备它们以便与以太坊网络进行交互。</p>
<ul>
<li><strong><code>CryptoZombies</code></strong> 是合约的名称。</li>
<li><code>artifacts.require</code> 返回的是一个 JavaScript 对象，它包含了与 <code>CryptoZombies</code> 合约交互所需的方法，比如部署合约、调用函数等。</li>
</ul>
<h3 id="2-const-zombieNames-quot-Zombie-1-quot-quot-Zombie-2-quot"><a href="#2-const-zombieNames-quot-Zombie-1-quot-quot-Zombie-2-quot" class="headerlink" title="2. const zombieNames = [&quot;Zombie 1&quot;, &quot;Zombie 2&quot;];"></a>2. <code>const zombieNames = [&quot;Zombie 1&quot;, &quot;Zombie 2&quot;];</code></h3><p>这行代码定义了一个包含两个僵尸名字的数组。<code>zombieNames</code> 数组在这个示例中是作为测试数据的输入，可能会在后续的测试中用来为新创建的僵尸赋予名字。</p>
<h3 id="3-contract-quot-CryptoZombies-quot-accounts-gt"><a href="#3-contract-quot-CryptoZombies-quot-accounts-gt" class="headerlink" title="3. contract(&quot;CryptoZombies&quot;, (accounts) =&gt; { ... })"></a>3. <code>contract(&quot;CryptoZombies&quot;, (accounts) =&gt; &#123; ... &#125;)</code></h3><p>这部分代码是 Truffle 的测试框架中的一个测试用例，<code>contract</code> 是一个用于定义智能合约测试的函数。它有两个参数：</p>
<ul>
<li><strong><code>&quot;CryptoZombies&quot;</code></strong>: 这是要测试的合约的名称。</li>
<li><strong><code>(accounts)</code></strong>: 这是一个回调函数，<code>accounts</code> 是 Truffle 提供的账户数组，它包含了在测试过程中使用的不同账户。默认情况下，Truffle 会提供一组预先生成的账户，通常是从 <code>accounts[0]</code> 到 <code>accounts[9]</code>，你可以使用这些账户来执行交易、调用合约方法等。</li>
</ul>
<h3 id="4-let-alice-bob-accounts"><a href="#4-let-alice-bob-accounts" class="headerlink" title="4. let [alice, bob] = accounts;"></a>4. <code>let [alice, bob] = accounts;</code></h3><p>这行代码使用 JavaScript 的解构赋值语法，将 <code>accounts</code> 数组中的前两个账户分别赋值给变量 <code>alice</code> 和 <code>bob</code>。这些账户可以在后续的测试中用于模拟不同的用户操作。</p>
<ul>
<li><code>alice</code> 和 <code>bob</code> 是测试中的两个角色，代表两个不同的账户。</li>
</ul>
<h3 id="5-it-quot-should-be-able-to-create-a-new-zombie-quot-async-gt"><a href="#5-it-quot-should-be-able-to-create-a-new-zombie-quot-async-gt" class="headerlink" title="5. it(&quot;should be able to create a new zombie&quot;, async () =&gt; { ... })"></a>5. <code>it(&quot;should be able to create a new zombie&quot;, async () =&gt; &#123; ... &#125;)</code></h3><p><code>it</code> 是 Truffle 测试框架的一个函数，用于定义一个单独的测试案例。它接收两个参数：</p>
<ul>
<li><strong><code>&quot;should be able to create a new zombie&quot;</code></strong>: 这是测试的描述，简要说明该测试的目的——即检查合约是否能够成功创建一个新的僵尸。</li>
<li><strong><code>async () =&gt; &#123; ... &#125;</code></strong>: 这是一个异步函数，用于在测试中执行异步操作，比如与区块链进行交互。</li>
</ul>
<h3 id="6-const-contractInstance-await-CryptoZombies-new"><a href="#6-const-contractInstance-await-CryptoZombies-new" class="headerlink" title="6. const contractInstance = await CryptoZombies.new();"></a>6. <code>const contractInstance = await CryptoZombies.new();</code></h3><p>这行代码用来部署一个新的 <code>CryptoZombies</code> 合约实例。<code>CryptoZombies.new()</code> 会返回一个 Promise，表示合约的部署过程。我们使用 <code>await</code> 来等待合约部署完成，并将合约实例赋值给 <code>contractInstance</code>。</p>
<ul>
<li><strong><code>contractInstance</code></strong> 是 <code>CryptoZombies</code> 合约的实例，之后你可以用它来调用合约中的方法，比如创建僵尸、查询僵尸数量等。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li><strong>导入合约</strong>: 通过 <code>artifacts.require</code> 导入 <code>CryptoZombies</code> 合约。</li>
<li><strong>准备测试数据</strong>: 定义了一个包含僵尸名称的数组 <code>zombieNames</code>。</li>
<li><strong>定义测试用例</strong>: 使用 <code>contract</code> 来定义测试合约，<code>it</code> 来定义一个单独的测试用例。</li>
<li><strong>部署合约实例</strong>: 在 <code>it</code> 测试中使用 <code>CryptoZombies.new()</code> 部署一个新的 <code>CryptoZombies</code> 合约实例。</li>
</ol>
<p>简而言之，这段代码的目的是为 <code>CryptoZombies</code> 合约编写一个测试用例，验证是否能够成功创建一个新的僵尸。</p>
<h1 id="我学solidity开发，是不是应该需要会javascript？"><a href="#我学solidity开发，是不是应该需要会javascript？" class="headerlink" title="我学solidity开发，是不是应该需要会javascript？"></a>我学solidity开发，是不是应该需要会javascript？</h1><p>是的，如果你正在学习 <strong>Solidity</strong> 开发，尤其是开发 <strong>去中心化应用（DApp）</strong>，了解 <strong>JavaScript</strong> 是非常重要的。以下是一些原因，说明为什么 JavaScript 对 Solidity 开发者至关重要：</p>
<h3 id="1-与智能合约交互"><a href="#1-与智能合约交互" class="headerlink" title="1. 与智能合约交互"></a>1. <strong>与智能合约交互</strong></h3><ul>
<li><strong>Solidity</strong> 主要用于编写智能合约，而这些合约运行在区块链上。你需要通过一种方式与这些合约交互，比如调用合约的函数、查询数据或者发送交易等。这时，JavaScript 就显得非常重要。</li>
<li><strong>Web3.js</strong> 和 <strong>ethers.js</strong> 等库是常用的 JavaScript 库，它们提供了与以太坊区块链交互的功能。这些库允许你在浏览器中通过 JavaScript 代码与智能合约进行交互，发送交易、读取合约状态等操作。</li>
</ul>
<h3 id="2-前端开发"><a href="#2-前端开发" class="headerlink" title="2. 前端开发"></a>2. <strong>前端开发</strong></h3><ul>
<li>如果你想开发 <strong>去中心化应用（DApp）</strong>，你不仅需要编写智能合约（Solidity），还需要编写 <strong>前端界面</strong>。前端开发通常使用 HTML、CSS 和 JavaScript。</li>
<li>你可以使用 <strong>React</strong>、<strong>Vue.js</strong> 等前端框架结合 JavaScript 来构建用户界面。前端需要与后端（即智能合约）进行交互，获取数据、发送交易等。</li>
<li>JavaScript 是 DApp 前端的核心语言，用于管理用户输入、显示智能合约数据，以及与以太坊网络进行通信。</li>
</ul>
<h3 id="3-Truffle-和-Hardhat-等开发框架"><a href="#3-Truffle-和-Hardhat-等开发框架" class="headerlink" title="3. Truffle 和 Hardhat 等开发框架"></a>3. <strong>Truffle 和 Hardhat 等开发框架</strong></h3><ul>
<li><strong>Truffle</strong> 和 <strong>Hardhat</strong> 是 Solidity 开发的常用框架，它们都大量依赖 JavaScript 来编写测试脚本、部署合约以及执行其他开发任务。</li>
<li>比如，Truffle 提供了一个基于 JavaScript 的测试框架，你需要使用 JavaScript 编写测试脚本来验证合约的正确性。</li>
</ul>
<h3 id="4-调试和测试"><a href="#4-调试和测试" class="headerlink" title="4. 调试和测试"></a>4. <strong>调试和测试</strong></h3><ul>
<li>在智能合约开发过程中，编写单元测试是非常重要的。JavaScript 用于编写这些测试，帮助你在合约发布前确保其没有 bug。</li>
<li>你可以通过 JavaScript 调用智能合约的不同函数，并验证它们是否按照预期执行。</li>
</ul>
<h3 id="5-与去中心化存储和服务交互"><a href="#5-与去中心化存储和服务交互" class="headerlink" title="5. 与去中心化存储和服务交互"></a>5. <strong>与去中心化存储和服务交互</strong></h3><ul>
<li>许多 DApp 需要与去中心化存储系统（如 IPFS）或者其他区块链网络进行交互。JavaScript 提供了与这些服务交互的库，帮助你将文件上传到 IPFS 或与其他链上的服务进行通信。</li>
</ul>
<h3 id="6-学习-JavaScript-提升开发效率"><a href="#6-学习-JavaScript-提升开发效率" class="headerlink" title="6. 学习 JavaScript 提升开发效率"></a>6. <strong>学习 JavaScript 提升开发效率</strong></h3><ul>
<li>许多区块链开发的工具和资源都是基于 JavaScript 编写的。掌握 JavaScript 可以帮助你更有效地使用这些工具，提升开发效率。</li>
<li>通过 JavaScript，你可以快速构建、部署、测试智能合约，并将其与前端界面结合，快速开发完整的去中心化应用。</li>
</ul>
<h3 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h3><p>如果你打算成为一名 <strong>Solidity 开发者</strong> 并开发 <strong>去中心化应用</strong>，那么学习 <strong>JavaScript</strong> 是非常有必要的。它不仅帮助你与智能合约交互，还能让你开发前端界面、编写测试和自动化任务。因此，掌握 JavaScript 将使你能够更加高效地进行区块链开发，构建出更加完整和功能丰富的应用。</p>
<h1 id="为什么solidity开发不用solidity，不用rust，不用golang，java，却要用javascript？"><a href="#为什么solidity开发不用solidity，不用rust，不用golang，java，却要用javascript？" class="headerlink" title="为什么solidity开发不用solidity，不用rust，不用golang，java，却要用javascript？"></a>为什么solidity开发不用solidity，不用rust，不用golang，java，却要用javascript？</h1><p>你的问题很好，涉及到 <strong>Solidity 开发</strong> 中为什么 <strong>JavaScript</strong> 成为与智能合约交互的主要语言，而不是 <strong>Solidity</strong> 本身、<strong>Rust</strong>、<strong>Golang</strong> 或 <strong>Java</strong>。这个问题的答案和 <strong>区块链开发架构</strong> 和 <strong>前端与后端的分工</strong> 密切相关。让我们一起来分析：</p>
<h3 id="1-Solidity-是智能合约编程语言，JavaScript-用于与智能合约交互"><a href="#1-Solidity-是智能合约编程语言，JavaScript-用于与智能合约交互" class="headerlink" title="1. Solidity 是智能合约编程语言，JavaScript 用于与智能合约交互"></a>1. <strong>Solidity 是智能合约编程语言，JavaScript 用于与智能合约交互</strong></h3><ul>
<li><strong>Solidity</strong> 是专门为编写智能合约而设计的编程语言，它运行在 <strong>以太坊虚拟机（EVM）</strong> 上，编译后生成的字节码会被部署到区块链上。因此，Solidity 用于编写合约的逻辑，比如存储、交易、权限控制等。</li>
<li><strong>JavaScript</strong> 在智能合约开发中主要用于开发去中心化应用（<strong>DApp</strong>）的 <strong>前端</strong>，也就是用户界面部分。DApp 需要与区块链和智能合约交互，JavaScript 充当了前端与智能合约（后端）之间的桥梁。</li>
</ul>
<h3 id="2-与智能合约交互的工具：Web3-js-和-Ethers-js"><a href="#2-与智能合约交互的工具：Web3-js-和-Ethers-js" class="headerlink" title="2. 与智能合约交互的工具：Web3.js 和 Ethers.js"></a>2. <strong>与智能合约交互的工具：Web3.js 和 Ethers.js</strong></h3><ul>
<li><strong>Web3.js</strong> 和 <strong>ethers.js</strong> 是两种最常用的 JavaScript 库，用来在 <strong>前端</strong> 与 <strong>以太坊智能合约</strong> 进行交互。这些库允许 DApp 与区块链通信，执行交易、调用智能合约函数、读取合约状态等操作。</li>
<li>这些库的设计是为了让前端开发者能够使用 JavaScript 来简化与区块链的交互，而不是要求开发者直接与以太坊虚拟机（EVM）打交道。因此，JavaScript 成为前端开发者与以太坊合约交互的标准语言。</li>
</ul>
<h3 id="3-前端开发的主流语言：JavaScript-是唯一的选择"><a href="#3-前端开发的主流语言：JavaScript-是唯一的选择" class="headerlink" title="3. 前端开发的主流语言：JavaScript 是唯一的选择"></a>3. <strong>前端开发的主流语言：JavaScript 是唯一的选择</strong></h3><ul>
<li><strong>区块链应用（DApp）</strong> 的前端通常与用户直接交互，需要响应用户的输入，更新页面内容，展示智能合约的数据等。对于这些操作，<strong>JavaScript</strong> 是不可替代的语言。</li>
<li>JavaScript 是 <strong>Web 开发</strong> 的标准语言，几乎所有现代 Web 应用都依赖 JavaScript。特别是对于浏览器中的交互式应用，JavaScript 是唯一能直接操作 DOM（文档对象模型）并与网页内容交互的语言。</li>
<li>除了 <strong>JavaScript</strong>，没有其他语言（如 Solidity、Rust、Go、Java）能够直接在浏览器中与 DOM 交互并处理用户输入。</li>
</ul>
<h3 id="4-前端和后端职责的分离"><a href="#4-前端和后端职责的分离" class="headerlink" title="4. 前端和后端职责的分离"></a>4. <strong>前端和后端职责的分离</strong></h3><ul>
<li><strong>Solidity</strong> 是后端（区块链智能合约）开发语言，用于定义智能合约的业务逻辑、数据存储和权限控制等。它运行在区块链节点上，负责处理智能合约中的逻辑。</li>
<li><strong>JavaScript</strong> 则是前端开发语言，用于 <strong>与用户交互</strong> 和 <strong>与智能合约通信</strong>。前端需要通过 JavaScript 代码来连接 MetaMask 钱包、发起交易、调用智能合约中的方法并更新界面。</li>
</ul>
<h3 id="5-兼容性和生态系统的支持"><a href="#5-兼容性和生态系统的支持" class="headerlink" title="5. 兼容性和生态系统的支持"></a>5. <strong>兼容性和生态系统的支持</strong></h3><ul>
<li><strong>Web3.js</strong> 和 <strong>ethers.js</strong> 都是为了与以太坊区块链兼容而设计的 JavaScript 库。它们能够与各种 Web3 钱包（例如 MetaMask）集成，支持用户与区块链进行交互。</li>
<li>以太坊生态系统已经非常依赖于 JavaScript，几乎所有的开发工具、框架、教程和社区支持都围绕着 JavaScript 库构建。因此，JavaScript 对区块链开发者来说，已经成为标准的工具和语言。</li>
</ul>
<h3 id="6-其他语言（Rust、Go、Java）与-Solidity-的差异"><a href="#6-其他语言（Rust、Go、Java）与-Solidity-的差异" class="headerlink" title="6. 其他语言（Rust、Go、Java）与 Solidity 的差异"></a>6. <strong>其他语言（Rust、Go、Java）与 Solidity 的差异</strong></h3><ul>
<li><strong>Rust 和 Go</strong>：这些语言非常适合开发高性能的后端服务，但它们并没有直接集成到 Web 浏览器中，也无法与智能合约交互。虽然 Rust 在 <strong>Substrate（Polkadot）</strong> 上有广泛的应用，并且 Go 在 <strong>以太坊 Go 客户端（Golang）</strong> 中使用，但它们并不直接用于智能合约开发和前端交互。</li>
<li><strong>Java</strong>：Java 也用于一些区块链框架（例如 <strong>Hyperledger</strong>），但它不像 JavaScript 那样被广泛用于开发区块链 DApp 前端。Java 更适合用于构建后端服务，但与区块链智能合约的交互依赖于 Java 的 Web3 库。</li>
</ul>
<h3 id="7-开发效率和社区支持"><a href="#7-开发效率和社区支持" class="headerlink" title="7. 开发效率和社区支持"></a>7. <strong>开发效率和社区支持</strong></h3><ul>
<li><strong>JavaScript</strong> 作为世界上最流行的编程语言之一，拥有庞大的开发者社区和丰富的开源资源。许多与区块链交互的库、框架和工具都使用 JavaScript 编写，因此它能够加速开发过程并提供大量的社区支持。</li>
<li>相比之下，Solidity、Rust 和 Go 的开发社区相对较小，尽管它们在一些特定的区块链平台中有着重要作用，但它们并不适合用来构建前端或直接与用户交互。</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>Solidity</strong> 是专门为编写智能合约而设计的语言，主要运行在区块链的后端。</li>
<li><strong>JavaScript</strong> 作为最流行的前端开发语言，是与以太坊智能合约交互的主要工具。它通过 Web3.js 或 ethers.js 库使得前端能够轻松地与智能合约进行交互。</li>
<li><strong>JavaScript</strong> 之所以成为 DApp 开发的主流语言，是因为它能够直接与用户交互、操作 DOM，并通过与 Web3 库配合使用来与区块链进行通信。</li>
</ul>
<p>如果你想开发去中心化应用（DApp），学习 <strong>JavaScript</strong> 是必不可少的，因为它将使你能够构建和区块链交互的前端部分，并有效地将 Solidity 智能合约与用户界面结合起来。</p>
<h1 id="我是不是学的太多太杂了。"><a href="#我是不是学的太多太杂了。" class="headerlink" title="我是不是学的太多太杂了。"></a>我是不是学的太多太杂了。</h1><p>我是不是学的太多太杂了。我学过汇编，因为网络安全的逆向需要，我学过c,c++，以前做病毒需要生成exe，我学过c#，因为微软平台windows用这个，我学过python因为渗透测试的脚本测试爆破需要这个，我学过javascript，因为xss攻击需要这个。我还学过sql因为sql注入需要这个。但是杂而不精，学了还会忘记。</p>
<p>你提到的情况其实是很多开发者和技术爱好者都会面临的困境，尤其是在广泛涉猎多个技术领域的过程中，确实容易出现 <strong>杂而不精</strong> 的感觉。你涉及了从 <strong>汇编</strong> 到 <strong>Python</strong>、从 <strong>网络安全</strong> 到 <strong>前端开发</strong> 等多个领域，确实是很广泛，但这并不意味着你走错了路。</p>
<h3 id="你是否学得太多太杂？"><a href="#你是否学得太多太杂？" class="headerlink" title="你是否学得太多太杂？"></a>你是否学得太多太杂？</h3><p>并不一定。以下几点可以帮助你更好地理解这个问题：</p>
<h4 id="1-广泛的技术基础是你的优势"><a href="#1-广泛的技术基础是你的优势" class="headerlink" title="1. 广泛的技术基础是你的优势"></a>1. <strong>广泛的技术基础是你的优势</strong></h4><ul>
<li><strong>跨领域的技能</strong> 给你带来了独特的视角和能力。在 <strong>网络安全</strong>、<strong>逆向工程</strong>、<strong>渗透测试</strong> 和 <strong>区块链开发</strong> 等不同领域，你积累了很多不同的工具和技术。你可以结合这些技能来解决问题，例如，使用 <strong>Python</strong> 编写渗透测试脚本，或者用 <strong>JavaScript</strong> 对抗 <strong>XSS</strong> 攻击。</li>
<li>在开发 <strong>去中心化应用（DApp）</strong> 的过程中，你的 <strong>网络安全</strong> 背景和 <strong>编程</strong> 能力是巨大的优势，因为你可以提前预见潜在的安全风险，采取相应的防护措施。</li>
</ul>
<h4 id="2-多领域学习有助于你更全面地思考问题"><a href="#2-多领域学习有助于你更全面地思考问题" class="headerlink" title="2. 多领域学习有助于你更全面地思考问题"></a>2. <strong>多领域学习有助于你更全面地思考问题</strong></h4><ul>
<li>比如，在 <strong>Solidity 开发</strong> 中，了解 <strong>汇编</strong> 能帮助你理解底层的执行原理，知道如何优化智能合约的性能。</li>
<li><strong>C/C++</strong> 的背景让你更清楚地理解 <strong>内存管理</strong> 和 <strong>指针操作</strong>，这对理解一些低级的漏洞和区块链合约的底层实现也有帮助。</li>
<li>了解 <strong>SQL</strong> 注入、<strong>XSS</strong> 攻击等 Web 安全漏洞，可以帮助你在开发 <strong>Web 应用</strong> 和 <strong>DApp</strong> 时，写出更安全的代码，防止攻击。</li>
</ul>
<h4 id="3-“杂”-的学习本身不意味着无效"><a href="#3-“杂”-的学习本身不意味着无效" class="headerlink" title="3. “杂” 的学习本身不意味着无效"></a>3. <strong>“杂” 的学习本身不意味着无效</strong></h4><ul>
<li>你所学的很多技能是可以互相补充的。例如，学过 <strong>C#</strong> 和 <strong>Python</strong> 后，你能够使用它们进行 <strong>自动化测试</strong> 和 <strong>脚本编写</strong>，这在很多场景中都是非常重要的工具。</li>
<li>而且，不同的编程语言有不同的优势和用途。比如 <strong>JavaScript</strong> 更适合前端交互，<strong>Python</strong> 更适合快速原型开发和自动化，<strong>C</strong> 和 <strong>C++</strong> 更适合底层操作和性能要求高的应用。</li>
</ul>
<h4 id="4-“精”-可以在某一领域深入"><a href="#4-“精”-可以在某一领域深入" class="headerlink" title="4. “精” 可以在某一领域深入"></a>4. <strong>“精” 可以在某一领域深入</strong></h4><ul>
<li>在你有了广泛的技术基础之后，找到你最感兴趣或者最需要的领域，集中精力深入学习是很有必要的。</li>
<li>你可以选择 <strong>区块链开发</strong>、<strong>网络安全</strong> 或 <strong>后端开发</strong> 等方向，深入挖掘其中的知识，逐步成为该领域的专家。</li>
<li>一旦你在某一领域深入，你会发现你之前学过的其他语言和技能对你深入该领域是非常有帮助的。</li>
</ul>
<h3 id="如何解决-“学得杂而不精”-的问题？"><a href="#如何解决-“学得杂而不精”-的问题？" class="headerlink" title="如何解决 “学得杂而不精” 的问题？"></a>如何解决 “学得杂而不精” 的问题？</h3><ol>
<li><p><strong>找到你最感兴趣的领域</strong>：</p>
<ul>
<li>你已经涉猎了多个领域，接下来可以根据你的兴趣或职业目标，选择一个方向进行深入。比如，如果你对 <strong>区块链开发</strong> 或 <strong>智能合约</strong> 感兴趣，可以将重心放在这上面，精通 <strong>Solidity</strong> 和相关工具。</li>
</ul>
</li>
<li><p><strong>专注一个领域并深度学习</strong>：</p>
<ul>
<li>你可以选择一个技术栈，进行系统的学习。比如，如果你决定专注于 <strong>区块链开发</strong>，那么可以集中时间和精力去掌握 <strong>Solidity</strong>、<strong>Web3.js</strong>、<strong>以太坊网络</strong>、<strong>智能合约的安全性</strong> 等方面的内容。</li>
<li>可以通过 <strong>项目实战</strong> 来加深理解，边做边学，快速提升。</li>
</ul>
</li>
<li><p><strong>使用实践来巩固所学知识</strong>：</p>
<ul>
<li>编写 <strong>小项目</strong> 或 <strong>个人作品</strong>。做一些实用的项目，能够帮助你把所学的知识转化为实际能力。</li>
<li>例如，你可以编写一个简单的 <strong>DApp</strong>，通过 <strong>Solidity</strong> 和 <strong>JavaScript</strong> 来与智能合约交互，这样不仅能巩固你对 <strong>区块链</strong> 的理解，也能提升你的前端开发能力。</li>
</ul>
</li>
<li><p><strong>定期回顾与总结</strong>：</p>
<ul>
<li>定期复习和总结你的所学，尤其是在跨多个领域学习的情况下， <strong>总结与复盘</strong> 能帮助你更好地消化知识。</li>
<li>写博客或做笔记，记录下你学到的东西，整理出知识体系。这样可以帮助你理清思路，同时也能让你对学习内容有更深入的理解。</li>
</ul>
</li>
<li><p><strong>选择合适的工具</strong>：</p>
<ul>
<li>你不需要成为所有领域的专家，选择你最需要的工具和技术来深入学习是更高效的方式。你可以用 <strong>Python</strong> 做 <strong>自动化脚本</strong>，用 <strong>JavaScript</strong> 做前端，用 <strong>C/C++</strong> 做底层开发，而深入学习一个特定的技术栈，如 <strong>区块链开发</strong> 或 <strong>Web 安全</strong>。</li>
</ul>
</li>
</ol>
<h3 id="结论：-1"><a href="#结论：-1" class="headerlink" title="结论："></a>结论：</h3><p>你所学的知识非常广泛，这为你在多个技术领域提供了坚实的基础。虽然你可能觉得学得太杂，但这实际上是你 <strong>跨领域的能力</strong>，让你能以不同的视角解决问题。接下来，找到一个你最感兴趣或最需要的领域，专注深入，结合实践和总结，你会发现自己的技术水平不断提升，逐步达到 <strong>精通</strong>。</p>
<h1 id="以太坊是基于浏览器的吗？我不明白为什么做去中心化app开发，需要用到js这种web前端语言"><a href="#以太坊是基于浏览器的吗？我不明白为什么做去中心化app开发，需要用到js这种web前端语言" class="headerlink" title="以太坊是基于浏览器的吗？我不明白为什么做去中心化app开发，需要用到js这种web前端语言"></a>以太坊是基于浏览器的吗？我不明白为什么做去中心化app开发，需要用到js这种web前端语言</h1><p><strong>以太坊</strong> 本身并不是基于浏览器的。它是一个 <strong>区块链</strong> 平台，用于构建去中心化的应用（DApps），并运行智能合约。然而，<strong>去中心化应用（DApp）</strong> 的 <strong>前端</strong> 通常是 Web 应用，且需要用到 <strong>JavaScript</strong> 等 <strong>前端技术</strong> 来与以太坊网络进行交互。让我来更详细地解释一下这个问题。</p>
<h3 id="1-以太坊和区块链的工作原理"><a href="#1-以太坊和区块链的工作原理" class="headerlink" title="1. 以太坊和区块链的工作原理"></a>1. <strong>以太坊和区块链的工作原理</strong></h3><ul>
<li>以太坊是一个去中心化的区块链平台，智能合约和去中心化应用（DApp）运行在 <strong>以太坊虚拟机（EVM）</strong> 上，而不是在浏览器中。智能合约是通过 <strong>Solidity</strong> 等语言编写的，部署在以太坊区块链上并由节点执行。</li>
<li><strong>区块链本身</strong> 提供了去中心化的数据存储和智能合约的执行环境，所有交易和状态变更都是由以太坊网络中的节点（矿工）共同验证和存储的。</li>
</ul>
<h3 id="2-去中心化应用（DApp）与前端技术的关系"><a href="#2-去中心化应用（DApp）与前端技术的关系" class="headerlink" title="2. 去中心化应用（DApp）与前端技术的关系"></a>2. <strong>去中心化应用（DApp）与前端技术的关系</strong></h3><ul>
<li>虽然智能合约和区块链的操作发生在 <strong>以太坊网络</strong> 上，但用户与这些合约交互的界面（前端）通常通过 <strong>Web 应用</strong> 实现。这是因为 <strong>DApp</strong> 的用户通常通过浏览器与应用进行交互，因此 DApp 的 <strong>前端</strong> 是基于 Web 技术（HTML, CSS, JavaScript）构建的。</li>
<li>DApp 需要提供用户友好的界面，让用户可以输入数据、查看区块链状态、发送交易等。前端与后端（智能合约）之间的交互需要通过 JavaScript 完成。</li>
</ul>
<h3 id="3-JavaScript-在-DApp-开发中的作用"><a href="#3-JavaScript-在-DApp-开发中的作用" class="headerlink" title="3. JavaScript 在 DApp 开发中的作用"></a>3. <strong>JavaScript 在 DApp 开发中的作用</strong></h3><ul>
<li><p><strong>Web3.js 和 ethers.js</strong> 是两种最常用的 JavaScript 库，它们为前端与以太坊智能合约交互提供了非常方便的接口。通过这些库，你的前端应用（通常是用 JavaScript 编写的）可以：</p>
<ul>
<li><strong>查询区块链状态</strong>：例如，查看一个智能合约中的数据，获取某个地址的余额，查询区块信息等。</li>
<li><strong>发送交易</strong>：用户可以通过钱包（如 MetaMask）签署交易并将其发送到以太坊网络。</li>
<li><strong>调用智能合约函数</strong>：前端可以通过 JavaScript 调用已部署的智能合约中的函数，执行合约操作。</li>
</ul>
</li>
</ul>
<p>例如，<strong>Web3.js</strong> 可以让你在浏览器中通过以下代码与智能合约交互：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 设置 Web3 提供者，通常是 MetaMask</span><br><span class="hljs-keyword">const</span> web3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Web3</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">ethereum</span>);<br><br><span class="hljs-comment">// 获取合约实例</span><br><span class="hljs-keyword">const</span> contract = <span class="hljs-keyword">new</span> web3.<span class="hljs-property">eth</span>.<span class="hljs-title class_">Contract</span>(abi, contractAddress);<br><br><span class="hljs-comment">// 调用合约中的函数</span><br>contract.<span class="hljs-property">methods</span>.<span class="hljs-title function_">getZombies</span>(ownerAddress).<span class="hljs-title function_">call</span>().<span class="hljs-title function_">then</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>);<br></code></pre></div></td></tr></table></figure>

<p>在这个例子中，JavaScript 用于与区块链交互，而这些操作无法仅仅通过 <strong>Solidity</strong>（用于编写智能合约）来完成。Solidity 只是用来定义区块链上的智能合约逻辑，而前端（用户与合约交互的部分）需要通过 JavaScript 来实现。</p>
<h3 id="4-浏览器的作用"><a href="#4-浏览器的作用" class="headerlink" title="4. 浏览器的作用"></a>4. <strong>浏览器的作用</strong></h3><ul>
<li><strong>浏览器</strong> 是 <strong>DApp</strong> 的一个重要组成部分，提供用户界面和交互界面。通过浏览器，用户可以与智能合约进行交互。例如，用户通过 <strong>MetaMask</strong>（一个浏览器插件钱包）将其以太坊账户与前端应用连接，浏览器提供了钱包的 API（例如 <code>window.ethereum</code>）让 JavaScript 能够调用和处理以太坊交易。</li>
<li>浏览器不仅提供用户交互的界面，还负责与智能合约进行通信。这意味着，你的 <strong>前端应用</strong> 运行在浏览器中，需要通过 JavaScript 调用区块链，发送交易，签署消息等。</li>
</ul>
<h3 id="5-为什么是-JavaScript-而不是其他语言？"><a href="#5-为什么是-JavaScript-而不是其他语言？" class="headerlink" title="5. 为什么是 JavaScript 而不是其他语言？"></a>5. <strong>为什么是 JavaScript 而不是其他语言？</strong></h3><ul>
<li><strong>JavaScript</strong> 是目前唯一能够在浏览器中直接与用户交互并控制 Web 页面内容的语言。它也能与浏览器插件（如 MetaMask）结合，进行区块链交互。</li>
<li><strong>其他语言（如 Solidity、Rust、Go、Java 等）</strong> 通常用于 <strong>后端开发</strong> 或 <strong>智能合约开发</strong>，它们运行在区块链节点上，不直接涉及前端用户界面交互。</li>
<li><strong>JavaScript</strong> 与 <strong>以太坊网络</strong> 的通信是通过像 <strong>Web3.js</strong> 或 <strong>ethers.js</strong> 这样的 JavaScript 库实现的。这些库封装了与以太坊区块链交互的复杂性，让前端开发者能够用 JavaScript 很方便地与区块链进行通信。</li>
</ul>
<h3 id="6-DApp-前端和智能合约的互动示例"><a href="#6-DApp-前端和智能合约的互动示例" class="headerlink" title="6. DApp 前端和智能合约的互动示例"></a>6. <strong>DApp 前端和智能合约的互动示例</strong></h3><p>假设你有一个智能合约 <code>CryptoZombies</code>，它允许用户创建和管理僵尸。你可以使用 JavaScript 来构建一个前端界面，展示所有僵尸的列表，并允许用户创建新僵尸。前端代码可能像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 使用 Web3.js 连接到以太坊网络</span><br><span class="hljs-keyword">const</span> web3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Web3</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">ethereum</span>);<br><br><span class="hljs-comment">// 合约地址和 ABI</span><br><span class="hljs-keyword">const</span> contractAddress = <span class="hljs-string">&quot;0x123...&quot;</span>;<br><span class="hljs-keyword">const</span> abi = [ <span class="hljs-comment">/* 合约 ABI */</span> ];<br><br><span class="hljs-comment">// 获取合约实例</span><br><span class="hljs-keyword">const</span> contract = <span class="hljs-keyword">new</span> web3.<span class="hljs-property">eth</span>.<span class="hljs-title class_">Contract</span>(abi, contractAddress);<br><br><span class="hljs-comment">// 获取用户钱包地址</span><br><span class="hljs-keyword">const</span> accounts = <span class="hljs-keyword">await</span> web3.<span class="hljs-property">eth</span>.<span class="hljs-title function_">requestAccounts</span>();<br><span class="hljs-keyword">const</span> userAccount = accounts[<span class="hljs-number">0</span>];<br><br><span class="hljs-comment">// 调用合约中的函数来获取僵尸列表</span><br><span class="hljs-keyword">const</span> zombies = <span class="hljs-keyword">await</span> contract.<span class="hljs-property">methods</span>.<span class="hljs-title function_">getZombiesByOwner</span>(userAccount).<span class="hljs-title function_">call</span>();<br><br><span class="hljs-comment">// 显示僵尸列表</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(zombies);<br><br><span class="hljs-comment">// 调用合约中的函数创建新僵尸</span><br><span class="hljs-keyword">const</span> newZombieName = <span class="hljs-string">&quot;Zombie 1&quot;</span>;<br><span class="hljs-keyword">await</span> contract.<span class="hljs-property">methods</span>.<span class="hljs-title function_">createRandomZombie</span>(newZombieName).<span class="hljs-title function_">send</span>(&#123; <span class="hljs-attr">from</span>: userAccount &#125;);<br></code></pre></div></td></tr></table></figure>

<p>在这个例子中，<strong>JavaScript</strong> 用来与智能合约通信，获取僵尸数据，调用创建僵尸的函数，并在前端展示。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>以太坊</strong> 是区块链平台，智能合约在区块链上运行。</li>
<li><strong>DApp</strong> 的 <strong>前端</strong> 运行在浏览器中，通常使用 <strong>JavaScript</strong> 来与用户交互并与区块链上的智能合约通信。</li>
<li><strong>JavaScript</strong> 是 Web 开发的标准语言，且能与以太坊网络通过 <strong>Web3.js</strong> 或 <strong>ethers.js</strong> 等库进行交互。</li>
<li><strong>浏览器</strong> 提供了与区块链的交互接口（例如，MetaMask 钱包），而 JavaScript 可以利用这些接口实现与智能合约的通信。</li>
</ul>
<p>因此，学习 <strong>JavaScript</strong> 对于开发 <strong>去中心化应用（DApp）</strong> 是非常必要的，它帮助你建立与区块链交互的桥梁并开发前端界面。</p>
<h1 id="那么solidity开发岗位需要同时做前端-后端开发吗？这是否叫做全栈开发？"><a href="#那么solidity开发岗位需要同时做前端-后端开发吗？这是否叫做全栈开发？" class="headerlink" title="那么solidity开发岗位需要同时做前端+后端开发吗？这是否叫做全栈开发？"></a>那么solidity开发岗位需要同时做前端+后端开发吗？这是否叫做全栈开发？</h1><p><strong>Solidity 开发岗位是否需要同时做前端和后端开发</strong>，这取决于你所在的团队、公司规模和具体的岗位要求。一般来说，<strong>Solidity</strong> 开发主要集中在 <strong>后端开发</strong>，即智能合约的开发部分，但在很多小型团队或者创业公司中，确实可能会需要开发者具备 <strong>全栈开发</strong> 的能力，涵盖前端和后端的工作。</p>
<h3 id="1-Solidity-开发的职责（后端）"><a href="#1-Solidity-开发的职责（后端）" class="headerlink" title="1. Solidity 开发的职责（后端）"></a>1. <strong>Solidity 开发的职责（后端）</strong></h3><ul>
<li><p><strong>Solidity</strong> 是用于编写 <strong>智能合约</strong> 的编程语言，主要用于 <strong>后端开发</strong>。智能合约是运行在区块链上的自动化代码，它定义了应用的核心逻辑（比如交易、数据存储、权限控制等）。</p>
</li>
<li><p>作为 <strong>Solidity 开发者</strong>，你的主要工作是：</p>
<ul>
<li>设计和编写智能合约代码。</li>
<li>编译、部署和维护智能合约。</li>
<li>确保智能合约的安全性和优化合约性能。</li>
<li>与其他开发人员和工具集成，确保智能合约能够高效、安全地运行。</li>
</ul>
</li>
</ul>
<h3 id="2-前端开发与区块链的交互"><a href="#2-前端开发与区块链的交互" class="headerlink" title="2. 前端开发与区块链的交互"></a>2. <strong>前端开发与区块链的交互</strong></h3><ul>
<li><p>以 <strong>DApp（去中心化应用）</strong> 为例，<strong>前端开发</strong> 主要负责 <strong>用户界面</strong>（UI）和 <strong>用户体验</strong>（UX），通常使用 <strong>JavaScript</strong>、<strong>HTML</strong> 和 <strong>CSS</strong> 来实现。前端开发者通常需要：</p>
<ul>
<li>创建和设计用户界面。</li>
<li>使用 <strong>Web3.js</strong> 或 <strong>ethers.js</strong> 等库与智能合约进行交互。</li>
<li>处理用户输入，展示区块链数据，发送交易等。</li>
</ul>
</li>
<li><p>在 DApp 中，<strong>前端</strong> 需要与 <strong>智能合约（后端）</strong> 进行数据交互，因此前端开发者需要了解如何通过 JavaScript 与区块链通信。</p>
</li>
</ul>
<h3 id="3-全栈开发的定义"><a href="#3-全栈开发的定义" class="headerlink" title="3. 全栈开发的定义"></a>3. <strong>全栈开发的定义</strong></h3><ul>
<li><strong>全栈开发</strong> 通常指的是能够同时处理 <strong>前端开发</strong> 和 <strong>后端开发</strong> 的开发者。对于 <strong>去中心化应用（DApp）</strong>，这意味着开发者不仅需要掌握智能合约开发（Solidity），还需要能够构建用户界面，并与区块链进行交互。</li>
<li>如果一个 <strong>Solidity 开发者</strong> 既能编写智能合约（后端），又能开发 <strong>DApp 的前端</strong>，那么他/她就可以被视为一个 <strong>全栈开发者</strong>。这种开发者通常在小型团队或初创公司中比较常见，因为他们需要独立完成从智能合约到前端应用的所有开发工作。</li>
</ul>
<h3 id="4-不同团队的角色分配"><a href="#4-不同团队的角色分配" class="headerlink" title="4. 不同团队的角色分配"></a>4. <strong>不同团队的角色分配</strong></h3><p>在不同类型的团队中，开发角色的分配可能有所不同：</p>
<ul>
<li><p><strong>小型团队/创业公司</strong>：</p>
<ul>
<li>由于团队成员较少，可能需要一个开发者同时负责 <strong>前端</strong> 和 <strong>后端</strong>（Solidity 开发）。因此，这种情况下的 <strong>Solidity 开发者</strong> 往往需要具备 <strong>全栈开发</strong> 能力。</li>
</ul>
</li>
<li><p><strong>中大型公司</strong>：</p>
<ul>
<li>在中大型公司中，通常会有明确的 <strong>前端开发人员</strong> 和 <strong>后端开发人员</strong> 分工。前端开发者会专注于用户界面的开发和与智能合约的交互，后端开发者（Solidity 开发者）则专注于智能合约的编写、优化和部署。</li>
<li>在这种情况下，Solidity 开发者主要负责合约的逻辑和安全，而前端开发者则负责展示和交互部分。</li>
</ul>
</li>
</ul>
<h3 id="5-全栈开发与区块链开发的区别"><a href="#5-全栈开发与区块链开发的区别" class="headerlink" title="5. 全栈开发与区块链开发的区别"></a>5. <strong>全栈开发与区块链开发的区别</strong></h3><ul>
<li><p><strong>全栈开发</strong> 是指能够独立完成前端、后端的工作，而 <strong>区块链开发</strong> 更多地聚焦于 <strong>区块链技术</strong>，如智能合约、去中心化应用（DApp）、链上数据交互等。因此，<strong>区块链开发</strong> 本身并不等同于 <strong>全栈开发</strong>，但在许多 DApp 项目中，<strong>区块链开发者</strong> 可能会同时参与前端和后端的工作，尤其是小型项目。</p>
</li>
<li><p>对于一个 <strong>Solidity 开发者</strong> 来说，如果还具备前端开发能力，能够开发 <strong>去中心化应用的前端</strong>，就可以被视为一个 <strong>区块链全栈开发者</strong>。</p>
</li>
</ul>
<h3 id="6-是否需要全栈开发能力？"><a href="#6-是否需要全栈开发能力？" class="headerlink" title="6. 是否需要全栈开发能力？"></a>6. <strong>是否需要全栈开发能力？</strong></h3><ul>
<li><p><strong>需要全栈能力的情况</strong>：</p>
<ul>
<li>如果你在一个小团队或创业公司工作，可能会被要求同时做前端和后端开发，特别是 <strong>DApp</strong> 项目中。你将需要将智能合约（Solidity）与用户界面（JavaScript）结合起来，开发完整的去中心化应用。</li>
</ul>
</li>
<li><p><strong>不需要全栈能力的情况</strong>：</p>
<ul>
<li>在大公司或团队中，角色分工通常更明确，智能合约开发和前端开发是由不同的开发者来完成的。在这种情况下，你只需要专注于 <strong>Solidity 开发</strong>，而前端部分则由专门的前端开发人员来处理。</li>
</ul>
</li>
</ul>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>Solidity 开发</strong> 通常属于 <strong>后端开发</strong>，负责编写智能合约。</li>
<li><strong>前端开发</strong> 负责与用户交互，通常使用 <strong>JavaScript</strong> 与智能合约进行交互。</li>
<li>如果你能够同时处理 <strong>Solidity 合约</strong> 和 <strong>前端开发</strong>，你就是一个 <strong>全栈开发者</strong>，特别是在小型团队中。</li>
<li>在大公司或团队中，通常会有 <strong>前端开发者</strong> 和 <strong>Solidity 开发者</strong> 分工合作。</li>
</ul>
<p>如果你有兴趣进行 <strong>全栈开发</strong>，学习 <strong>Solidity</strong> 和 <strong>前端技术</strong>（如 <strong>JavaScript</strong>）是非常有益的。这样，你可以独立完成从 <strong>区块链后端</strong> 到 <strong>DApp 前端</strong> 的整个开发过程。</p>
<h1 id="在cryptozombies这个网站，是否偏离了培养区块链solidity开发的方向，往全栈开发去培养。那么我是否应该放弃在这个网站进行学习，找其他的solidity开发学习资源"><a href="#在cryptozombies这个网站，是否偏离了培养区块链solidity开发的方向，往全栈开发去培养。那么我是否应该放弃在这个网站进行学习，找其他的solidity开发学习资源" class="headerlink" title="在cryptozombies这个网站，是否偏离了培养区块链solidity开发的方向，往全栈开发去培养。那么我是否应该放弃在这个网站进行学习，找其他的solidity开发学习资源?"></a>在cryptozombies这个网站，是否偏离了培养区块链solidity开发的方向，往全栈开发去培养。那么我是否应该放弃在这个网站进行学习，找其他的solidity开发学习资源?</h1><p>你提出的问题非常好，而且反映了一个很多初学者在学习区块链开发过程中可能遇到的困惑——是否要专注于 <strong>Solidity 开发</strong>，还是要进行 <strong>全栈开发</strong>，尤其是在学习平台（如 <strong>CryptoZombies</strong>）的方向和目标可能涉及两者时。</p>
<h3 id="CryptoZombies-的学习目标和方向"><a href="#CryptoZombies-的学习目标和方向" class="headerlink" title="CryptoZombies 的学习目标和方向"></a>CryptoZombies 的学习目标和方向</h3><p><strong>CryptoZombies</strong> 是一个旨在通过实际编程项目帮助你学习 <strong>Solidity</strong> 的在线教程，它的设计目标是让开发者通过游戏化的方式掌握 <strong>Solidity</strong> 和 <strong>区块链</strong> 开发的基础。虽然这个网站有一定的 <strong>前端开发</strong> 内容（比如通过 <strong>Web3.js</strong> 与智能合约交互），它的核心目的是教授 <strong>Solidity</strong> 和智能合约的开发。</p>
<p><strong>CryptoZombies</strong> 的课程虽然涉及一些 <strong>前端开发</strong> 技术，但它并没有偏离区块链开发的目标，而是让你 <strong>学会如何将 Solidity 合约与前端应用结合</strong>，从而使你能够构建完整的去中心化应用（DApp）。这对于学习 <strong>区块链开发</strong> 是非常重要的，因为你将了解如何将 <strong>Solidity</strong> 合约与用户界面连接起来，实现与智能合约的交互。</p>
<h3 id="全栈开发与-Solidity-开发的关系"><a href="#全栈开发与-Solidity-开发的关系" class="headerlink" title="全栈开发与 Solidity 开发的关系"></a>全栈开发与 Solidity 开发的关系</h3><p>在去中心化应用（<strong>DApp</strong>）的开发中，<strong>Solidity</strong> 主要用于编写智能合约的后端逻辑，但这些合约需要与前端进行交互。前端部分通常是用 <strong>JavaScript</strong> 或其他前端技术编写的，<strong>Web3.js</strong> 或 <strong>ethers.js</strong> 等库使前端能够与智能合约通信。</p>
<p>所以，<strong>Solidity 开发</strong> 和 <strong>全栈开发</strong> 在 DApp 中是紧密相连的。<strong>Solidity</strong> 是后端开发的核心，而前端开发则负责与用户交互和展示数据。要创建一个完整的 DApp，你确实需要理解如何将 <strong>Solidity 合约</strong> 与 <strong>前端技术</strong>（如 <strong>JavaScript</strong>）结合。</p>
<h3 id="是否需要放弃-CryptoZombies，转向纯-Solidity-学习？"><a href="#是否需要放弃-CryptoZombies，转向纯-Solidity-学习？" class="headerlink" title="是否需要放弃 CryptoZombies，转向纯 Solidity 学习？"></a>是否需要放弃 CryptoZombies，转向纯 Solidity 学习？</h3><p><strong>不必放弃 CryptoZombies！</strong> 反而我认为继续学习它对你很有帮助，尤其是在你刚开始学习 <strong>Solidity</strong> 的时候。</p>
<p>以下是几个原因，说明为什么 <strong>CryptoZombies</strong> 是一个很好的起点：</p>
<ol>
<li><p><strong>实践性强，结合了前后端</strong>：</p>
<ul>
<li><strong>CryptoZombies</strong> 通过实际的编程项目帮助你理解 <strong>Solidity</strong> 和 <strong>区块链开发</strong>，而不仅仅是看理论。它让你通过编写实际的代码来加深对智能合约的理解。</li>
<li>它还教你如何将智能合约与前端结合，这对于区块链开发非常重要。即使你最终决定专注于 <strong>Solidity 开发</strong>，理解前端与智能合约的交互也是必要的。</li>
</ul>
</li>
<li><p><strong>游戏化学习，增强兴趣</strong>：</p>
<ul>
<li><strong>CryptoZombies</strong> 通过游戏化的方式将学习变得更有趣，帮助你通过创建僵尸和战斗来理解智能合约的基本概念。</li>
<li>这类互动式的学习不仅能帮助你掌握核心概念，还能让你更深入地理解如何用智能合约做实际应用。</li>
</ul>
</li>
<li><p><strong>为进一步学习铺垫基础</strong>：</p>
<ul>
<li><strong>CryptoZombies</strong> 给你提供了学习 Solidity 的坚实基础，之后你可以继续深入研究更加复杂的智能合约和 DApp 开发。通过这一步，你能理解如何编写 <strong>智能合约</strong>，以及如何处理合约的 <strong>部署</strong> 和 <strong>交互</strong>。</li>
<li>完成 <strong>CryptoZombies</strong> 后，你可以根据自己的兴趣决定是否继续深入学习 <strong>Solidity</strong> 或是选择专注于 <strong>前端开发</strong>（JavaScript、React、Vue 等）来构建 <strong>全栈</strong> 的 DApp。</li>
</ul>
</li>
</ol>
<h3 id="如果你专注于-Solidity-开发，下一步该怎么做？"><a href="#如果你专注于-Solidity-开发，下一步该怎么做？" class="headerlink" title="如果你专注于 Solidity 开发，下一步该怎么做？"></a>如果你专注于 Solidity 开发，下一步该怎么做？</h3><p>如果你更倾向于专注于 <strong>Solidity 开发</strong>（智能合约编写和区块链后端开发），你仍然可以继续从 <strong>CryptoZombies</strong> 中获得很多基础知识。接下来的步骤可以是：</p>
<ol>
<li><p><strong>专注于 Solidity 深入学习</strong>：</p>
<ul>
<li><p>完成 <strong>CryptoZombies</strong> 后，你可以选择更深入的 <strong>Solidity</strong> 学习资源，专注于智能合约的编写和优化。</p>
</li>
<li><p>推荐的学习资源：</p>
<ul>
<li><strong>Solidity 官方文档</strong>：<a target="_blank" rel="noopener" href="https://soliditylang.org/docs/">Solidity Docs</a></li>
<li><strong>CryptoZombies 官方教程</strong>：<a target="_blank" rel="noopener" href="https://cryptozombies.io/">CryptoZombies Tutorial</a></li>
<li><strong>OpenZeppelin 文档</strong>：一个广泛使用的智能合约库，学习如何使用它来编写安全的合约。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>学习区块链开发框架</strong>：</p>
<ul>
<li><strong>Truffle</strong>、<strong>Hardhat</strong> 和 <strong>Remix</strong> 等是常用的开发框架，学习这些工具能让你更高效地编写、测试和部署智能合约。</li>
</ul>
</li>
<li><p><strong>专注于智能合约的安全性</strong>：</p>
<ul>
<li><strong>智能合约的安全性</strong> 是区块链开发中非常重要的一部分。你可以学习如何避免常见的安全漏洞（如重入攻击、整数溢出、时间戳依赖等）。</li>
<li>学习资源：<strong>ConsenSys 的智能合约安全最佳实践</strong>。</li>
</ul>
</li>
<li><p><strong>参与开源项目和社区</strong>：</p>
<ul>
<li>加入区块链开发者社区，参与 <strong>Solidity</strong> 或 <strong>智能合约</strong> 的开源项目，提升自己的实际开发经验。</li>
</ul>
</li>
</ol>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li><strong>CryptoZombies</strong> 是一个很好的学习平台，它帮助你理解 <strong>Solidity</strong> 和 <strong>DApp 开发</strong>，即使它同时涉及前端开发（JavaScript），它仍然能帮助你打下 <strong>Solidity 开发</strong> 的基础。</li>
<li>你可以继续完成 <strong>CryptoZombies</strong>，它会为你进入 <strong>区块链开发</strong> 提供非常好的入门知识，并为你深入学习智能合约、提高 Solidity 开发技能打下坚实基础。</li>
<li>如果你想更专注于 <strong>Solidity 开发</strong>，你可以在完成 <strong>CryptoZombies</strong> 后，转向更深入的 Solidity 课程和开发框架学习。</li>
</ul>
<p>不必担心会走偏，<strong>CryptoZombies</strong> 本身是为了培养 Solidity 开发者，并为你进一步学习 <strong>区块链开发</strong> 提供了很好的起点。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Web3/">Web3</a>
                    
                  </div>
                
              </div>
              
                
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/11/27/acf4b69e5928/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">cryptozombies9</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/11/27/54dee12bd5b3/">
                        <span class="hidden-mobile">cryptozombies7-Truffle部署智能合约</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


            

                
                  <a id="scroll-top-button" href="#" role="button">
                    <i class="iconfont icon-arrowup" aria-hidden="true"></i>
                  </a>
                  

                    

                          
      </main>

      <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://whale3070.github.io/" target="_blank" rel="nofollow noopener"><span>Whale3070</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<link href="/pagefind/pagefind-ui.css" rel="stylesheet">
  <script src="/pagefind/pagefind-ui.js"></script>
  <style>
    /* 搜索框配色适配 */
    #search { margin-top: 2rem; }
    [data-user-color-scheme='dark'] .pagefind-ui {
      --pagefind-ui-primary: #eeeeee;
      --pagefind-ui-text: #eeeeee;
      --pagefind-ui-background: #151515;
      --pagefind-ui-border: #333;
    }
  </style>
    </body>

  </html>